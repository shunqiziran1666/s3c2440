diff -urN u-boot-1.1.6/board/100ask24x0/100ask24x0.c u-boot-1.1.6_fdt/board/100ask24x0/100ask24x0.c
--- u-boot-1.1.6/board/100ask24x0/100ask24x0.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/board/100ask24x0/100ask24x0.c	2018-10-22 15:53:21.537641225 +0800
@@ -0,0 +1,96 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <s3c2410.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+    S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+    S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+    /* set up the I/O ports */
+    gpio->GPACON = 0x007FFFFF;
+    gpio->GPBCON = 0x00044555;
+    gpio->GPBUP = 0x000007FF;
+    gpio->GPCCON = 0xAAAAAAAA;
+    gpio->GPCUP = 0x0000FFFF;
+    gpio->GPDCON = 0xAAAAAAAA;
+    gpio->GPDUP = 0x0000FFFF;
+    gpio->GPECON = 0xAAAAAAAA;
+    gpio->GPEUP = 0x0000FFFF;
+    gpio->GPFCON = 0x000055AA;
+    gpio->GPFUP = 0x000000FF;
+    gpio->GPGCON = 0xFF95FFBA;
+    gpio->GPGUP = 0x0000FFFF;
+    gpio->GPHCON = 0x002AFAAA;
+    gpio->GPHUP = 0x000007FF;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+    {
+        /* arch number of SMDK2410-Board */
+        gd->bd->bi_arch_number = MACH_TYPE_SMDK2410;
+    }
+    else
+    {
+        /* arch number of SMDK2440-Board */
+        gd->bd->bi_arch_number = MACH_TYPE_S3C2440;
+    }
+
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = 0x30000100;
+#if 0
+    icache_enable();
+    dcache_enable();
+#endif
+    return 0;
+}
+
+int dram_init (void)
+{
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+    return 0;
+}
+
+ulong board_flash_get_legacy(ulong base, int banknum, flash_info_t *info)
+{	
+	info->portwidth = CFG_FLASH_CFI_WIDTH;
+	info->chipwidth = CFG_FLASH_CFI_WIDTH;
+	info->interface = FLASH_CFI_X16;
+	return 1;
+}
+
+
diff -urN u-boot-1.1.6/board/100ask24x0/boot_init.c u-boot-1.1.6_fdt/board/100ask24x0/boot_init.c
--- u-boot-1.1.6/board/100ask24x0/boot_init.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/board/100ask24x0/boot_init.c	2018-10-22 15:53:21.537641225 +0800
@@ -0,0 +1,567 @@
+#include <common.h>
+#include <s3c2410.h>
+
+#define BUSY            1
+
+#define NAND_SECTOR_SIZE    512
+#define NAND_BLOCK_MASK     (NAND_SECTOR_SIZE - 1)
+
+#define NAND_SECTOR_SIZE_LP    2048
+#define NAND_BLOCK_MASK_LP     (NAND_SECTOR_SIZE_LP - 1)
+
+/* 供外部调用的函数 */
+void nand_init_ll(void);
+void nand_read_ll(unsigned char *buf, unsigned long start_addr, int size);
+
+/* NAND Flash操作的总入口, 它们将调用S3C2410或S3C2440的相应函数 */
+static void nand_reset(void);
+static void wait_idle(void);
+static void nand_select_chip(void);
+static void nand_deselect_chip(void);
+static void write_cmd(int cmd);
+static void write_addr(unsigned int addr);
+static unsigned char read_data(void);
+
+/* S3C2410的NAND Flash处理函数 */
+static void s3c2410_nand_reset(void);
+static void s3c2410_wait_idle(void);
+static void s3c2410_nand_select_chip(void);
+static void s3c2410_nand_deselect_chip(void);
+static void s3c2410_write_cmd(int cmd);
+static void s3c2410_write_addr(unsigned int addr);
+static unsigned char s3c2410_read_data(void);
+
+/* S3C2440的NAND Flash处理函数 */
+static void s3c2440_nand_reset(void);
+static void s3c2440_wait_idle(void);
+static void s3c2440_nand_select_chip(void);
+static void s3c2440_nand_deselect_chip(void);
+static void s3c2440_write_cmd(int cmd);
+static void s3c2440_write_addr(unsigned int addr);
+static unsigned char s3c2440_read_data(void);
+
+/* S3C2410的NAND Flash操作函数 */
+
+/* 复位 */
+static void s3c2410_nand_reset(void)
+{
+    s3c2410_nand_select_chip();
+    s3c2410_write_cmd(0xff);  // 复位命令
+    s3c2410_wait_idle();
+    s3c2410_nand_deselect_chip();
+}
+
+/* 等待NAND Flash就绪 */
+static void s3c2410_wait_idle(void)
+{
+    int i;
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+	
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFSTAT;
+    while(!(*p & BUSY))
+        for(i=0; i<10; i++);
+}
+
+/* 发出片选信号 */
+static void s3c2410_nand_select_chip(void)
+{
+    int i;
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    s3c2410nand->NFCONF &= ~(1<<11);
+    for(i=0; i<10; i++);    
+}
+
+/* 取消片选信号 */
+static void s3c2410_nand_deselect_chip(void)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    s3c2410nand->NFCONF |= (1<<11);
+}
+
+/* 发出命令 */
+static void s3c2410_write_cmd(int cmd)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFCMD;
+    *p = cmd;
+}
+
+/* 发出地址 */
+static void s3c2410_write_addr(unsigned int addr)
+{
+    int i;
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFADDR;
+    
+    *p = addr & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 9) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 17) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 25) & 0xff;
+    for(i=0; i<10; i++);
+}
+
+/* 读取数据 */
+static unsigned char s3c2410_read_data(void)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFDATA;
+    return *p;
+}
+
+/* S3C2440的NAND Flash操作函数 */
+
+/* 复位 */
+static void s3c2440_nand_reset(void)
+{
+    s3c2440_nand_select_chip();
+    s3c2440_write_cmd(0xff);  // 复位命令
+    s3c2440_wait_idle();
+    s3c2440_nand_deselect_chip();
+}
+
+/* 等待NAND Flash就绪 */
+static void s3c2440_wait_idle(void)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFSTAT;
+
+    while(!(*p & BUSY))
+        for(i=0; i<10; i++);
+}
+
+/* 发出片选信号 */
+static void s3c2440_nand_select_chip(void)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    s3c2440nand->NFCONT &= ~(1<<1);
+    for(i=0; i<10; i++);    
+}
+
+/* 取消片选信号 */
+static void s3c2440_nand_deselect_chip(void)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    s3c2440nand->NFCONT |= (1<<1);
+}
+
+/* 发出命令 */
+static void s3c2440_write_cmd(int cmd)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFCMD;
+    *p = cmd;
+}
+
+/* 发出地址 */
+static void s3c2440_write_addr(unsigned int addr)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
+    
+    *p = addr & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 9) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 17) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 25) & 0xff;
+    for(i=0; i<10; i++);
+}
+
+
+/* 发出地址 */
+static void s3c2440_write_addr_lp(unsigned int addr)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
+	int col, page;
+
+	col = addr & NAND_BLOCK_MASK_LP;
+	page = addr / NAND_SECTOR_SIZE_LP;
+	
+    *p = col & 0xff;			/* Column Address A0~A7 */
+    for(i=0; i<10; i++);		
+    *p = (col >> 8) & 0x0f;		/* Column Address A8~A11 */
+    for(i=0; i<10; i++);
+    *p = page & 0xff;			/* Row Address A12~A19 */
+    for(i=0; i<10; i++);
+    *p = (page >> 8) & 0xff;	/* Row Address A20~A27 */
+    for(i=0; i<10; i++);
+    *p = (page >> 16) & 0x03;	/* Row Address A28~A29 */
+    for(i=0; i<10; i++);
+}
+
+/* 读取数据 */
+static unsigned char s3c2440_read_data(void)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFDATA;
+    return *p;
+}
+
+
+/* 在第一次使用NAND Flash前，复位一下NAND Flash */
+static void nand_reset(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_nand_reset();
+	}
+	else
+	{
+	    s3c2440_nand_reset();
+	}
+}
+
+static void wait_idle(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_wait_idle();
+	}
+	else
+	{
+	    s3c2440_wait_idle();
+	}
+}
+
+static void nand_select_chip(void)
+{
+    int i;
+	
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_nand_select_chip();
+	}
+	else
+	{
+	    s3c2440_nand_select_chip();
+	}
+	
+    for(i=0; i<10; i++);
+}
+
+static void nand_deselect_chip(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_nand_deselect_chip();
+	}
+	else
+	{
+	    s3c2440_nand_deselect_chip();
+	}	
+}
+
+static void write_cmd(int cmd)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_write_cmd(cmd);
+	}
+	else
+	{
+	    s3c2440_write_cmd(cmd);
+	}	
+}
+static void write_addr(unsigned int addr)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_write_addr(addr);
+	}
+	else
+	{
+	    s3c2440_write_addr(addr);
+	}	
+}
+
+static void write_addr_lp(unsigned int addr)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_write_addr(addr);
+	}
+	else
+	{
+	    s3c2440_write_addr_lp(addr);
+	}	
+}
+
+static unsigned char read_data(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    return s3c2410_read_data();
+	}
+	else
+	{
+	    return s3c2440_read_data();
+	}	
+}
+
+/* 初始化NAND Flash */
+void nand_init_ll(void)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+#define TACLS   0
+#define TWRPH0  3
+#define TWRPH1  0
+
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+    {
+		/* 使能NAND Flash控制器, 初始化ECC, 禁止片选, 设置时序 */
+        s3c2410nand->NFCONF = (1<<15)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0);
+    }
+    else
+    {
+		/* 设置时序 */
+        s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
+        /* 使能NAND Flash控制器, 初始化ECC, 禁止片选 */
+        s3c2440nand->NFCONT = (1<<4)|(1<<1)|(1<<0);
+    }
+
+	/* 复位NAND Flash */
+	nand_reset();
+}
+
+
+/* 读函数 */
+void nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
+{
+    int i, j;
+    
+    if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
+        return ;    /* 地址或长度不对齐 */
+    }
+
+    /* 选中芯片 */
+    nand_select_chip();
+
+    for(i=start_addr; i < (start_addr + size);) {
+      /* 发出READ0命令 */
+      write_cmd(0);
+
+      /* Write Address */
+      write_addr(i);
+      wait_idle();
+
+      for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
+          *buf = read_data();
+          buf++;
+      }
+    }
+
+    /* 取消片选信号 */
+    nand_deselect_chip();
+    
+    return ;
+}
+
+
+/* 读函数 
+  * Large Page
+  */
+void nand_read_ll_lp(unsigned char *buf, unsigned long start_addr, int size)
+{
+    int i, j;
+    
+    if ((start_addr & NAND_BLOCK_MASK_LP) || (size & NAND_BLOCK_MASK_LP)) {
+        return ;    /* 地址或长度不对齐 */
+    }
+
+    /* 选中芯片 */
+    nand_select_chip();
+
+    for(i=start_addr; i < (start_addr + size);) {
+      /* 发出READ0命令 */
+      write_cmd(0);
+
+      /* Write Address */
+      write_addr_lp(i);
+	  write_cmd(0x30);
+      wait_idle();
+
+      for(j=0; j < NAND_SECTOR_SIZE_LP; j++, i++) {
+          *buf = read_data();
+          buf++;
+      }
+    }
+
+    /* 取消片选信号 */
+    nand_deselect_chip();
+    
+    return ;
+}
+
+int bBootFrmNORFlash(void)
+{
+    //volatile unsigned int *pdw = (volatile unsigned int *)0;
+    volatile unsigned int *pdw = (volatile unsigned int *)4;  /* 新版的GCC发现访问0地址时会插入一个未定义的指令, 为避免这点我们把地址改为4 */
+    unsigned int dwVal;
+    
+    /*
+     * 无论是从NOR Flash还是从NAND Flash启动，
+     * 地址0处为指令"b	Reset", 机器码为0xEA00000B，
+     * 对于从NAND Flash启动的情况，其开始4KB的代码会复制到CPU内部4K内存中，
+     * 对于从NOR Flash启动的情况，NOR Flash的开始地址即为0。
+     * 对于NOR Flash，必须通过一定的命令序列才能写数据，
+     * 所以可以根据这点差别来分辨是从NAND Flash还是NOR Flash启动:
+     * 向地址0写入一个数据，然后读出来，如果没有改变的话就是NOR Flash
+     */
+
+    dwVal = *pdw;       
+    *pdw = 0x12345678;
+    if (*pdw != 0x12345678)
+    {
+        return 1;
+    }
+    else
+    {
+        *pdw = dwVal;
+        return 0;
+    }
+}
+
+int CopyCode2Ram(unsigned long start_addr, unsigned char *buf, int size)
+{
+    unsigned int *pdwDest;
+    unsigned int *pdwSrc;
+    int i;
+
+    if (bBootFrmNORFlash())
+    {
+        pdwDest = (unsigned int *)buf;
+        pdwSrc  = (unsigned int *)start_addr;
+        /* 从 NOR Flash启动 */
+        for (i = 0; i < size / 4; i++)
+        {
+            pdwDest[i] = pdwSrc[i];
+        }
+        return 0;
+    }
+    else
+    {
+        /* 初始化NAND Flash */
+		nand_init_ll();
+        /* 从 NAND Flash启动 */
+        nand_read_ll_lp(buf, start_addr, (size + NAND_BLOCK_MASK_LP)&~(NAND_BLOCK_MASK_LP));
+		return 0;
+    }
+}
+
+static inline void delay (unsigned long loops)
+{
+    __asm__ volatile ("1:\n"
+      "subs %0, %1, #1\n"
+      "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/* S3C2440: Mpll = (2*m * Fin) / (p * 2^s), UPLL = (m * Fin) / (p * 2^s)
+ * m = M (the value for divider M)+ 8, p = P (the value for divider P) + 2
+ */
+#define S3C2440_MPLL_400MHZ     ((0x5c<<12)|(0x01<<4)|(0x01))
+#define S3C2440_MPLL_200MHZ     ((0x5c<<12)|(0x01<<4)|(0x02))
+#define S3C2440_MPLL_100MHZ     ((0x5c<<12)|(0x01<<4)|(0x03))
+#define S3C2440_UPLL_96MHZ      ((0x38<<12)|(0x02<<4)|(0x01))
+#define S3C2440_UPLL_48MHZ      ((0x38<<12)|(0x02<<4)|(0x02))
+#define S3C2440_CLKDIV          (0x05) // | (1<<3))    /* FCLK:HCLK:PCLK = 1:4:8, UCLK = UPLL/2 */
+#define S3C2440_CLKDIV188       0x04    /* FCLK:HCLK:PCLK = 1:8:8 */
+#define S3C2440_CAMDIVN188      ((0<<8)|(1<<9)) /* FCLK:HCLK:PCLK = 1:8:8 */
+
+/* Fin = 16.9344MHz */
+#define S3C2440_MPLL_399MHz_Fin16MHz	((0x6e<<12)|(0x03<<4)|(0x01))
+#define S3C2440_UPLL_48MHZ_Fin16MHz     ((60<<12)|(4<<4)|(2))
+
+/* S3C2410: Mpll,Upll = (m * Fin) / (p * 2^s)
+ * m = M (the value for divider M)+ 8, p = P (the value for divider P) + 2
+ */
+#define S3C2410_MPLL_200MHZ     ((0x5c<<12)|(0x04<<4)|(0x00))
+#define S3C2410_UPLL_48MHZ      ((0x28<<12)|(0x01<<4)|(0x02))
+#define S3C2410_CLKDIV          0x03    /* FCLK:HCLK:PCLK = 1:2:4 */
+void clock_init(void)
+{
+	S3C24X0_CLOCK_POWER *clk_power = (S3C24X0_CLOCK_POWER *)0x4C000000;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+    {
+        /* FCLK:HCLK:PCLK = 1:2:4 */
+        clk_power->CLKDIVN = S3C2410_CLKDIV;
+
+        /* change to asynchronous bus mod */
+        __asm__(    "mrc    p15, 0, r1, c1, c0, 0\n"    /* read ctrl register   */  
+                    "orr    r1, r1, #0xc0000000\n"      /* Asynchronous         */  
+                    "mcr    p15, 0, r1, c1, c0, 0\n"    /* write ctrl register  */  
+                    :::"r1"
+                    );
+        
+        /* to reduce PLL lock time, adjust the LOCKTIME register */
+        clk_power->LOCKTIME = 0xFFFFFFFF;
+
+        /* configure UPLL */
+        clk_power->UPLLCON = S3C2410_UPLL_48MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (4000);
+
+        /* configure MPLL */
+        clk_power->MPLLCON = S3C2410_MPLL_200MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (8000);
+    }
+    else
+    {
+        /* FCLK:HCLK:PCLK = 1:4:8 */
+        clk_power->CLKDIVN = S3C2440_CLKDIV;
+
+        /* change to asynchronous bus mod */
+        __asm__(    "mrc    p15, 0, r1, c1, c0, 0\n"    /* read ctrl register   */  
+                    "orr    r1, r1, #0xc0000000\n"      /* Asynchronous         */  
+                    "mcr    p15, 0, r1, c1, c0, 0\n"    /* write ctrl register  */  
+                    :::"r1"
+                    );
+
+        /* to reduce PLL lock time, adjust the LOCKTIME register */
+        clk_power->LOCKTIME = 0xFFFFFFFF;
+
+        /* configure UPLL */
+        clk_power->UPLLCON = S3C2440_UPLL_48MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (4000);
+
+        /* configure MPLL */
+        clk_power->MPLLCON = S3C2440_MPLL_400MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (8000);
+    }
+}
+
diff -urN u-boot-1.1.6/board/100ask24x0/boot_init.dis u-boot-1.1.6_fdt/board/100ask24x0/boot_init.dis
--- u-boot-1.1.6/board/100ask24x0/boot_init.dis	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/board/100ask24x0/boot_init.dis	2018-10-22 15:53:21.537641225 +0800
@@ -0,0 +1,2352 @@
+
+boot_init.o:     file format elf32-littlearm
+
+
+Disassembly of section .text:
+
+00000000 <write_cmd>:
+   0:	e3a03456 	mov	r3, #1442840576	; 0x56000000
+   4:	e59f2020 	ldr	r2, [pc, #32]	; 2c <write_cmd+0x2c>
+   8:	e59330b0 	ldr	r3, [r3, #176]	; 0xb0
+   c:	e20000ff 	and	r0, r0, #255	; 0xff
+  10:	e1a03823 	lsr	r3, r3, #16
+  14:	e1a03803 	lsl	r3, r3, #16
+  18:	e1530002 	cmp	r3, r2
+  1c:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
+  20:	05c30004 	strbeq	r0, [r3, #4]
+  24:	15c30008 	strbne	r0, [r3, #8]
+  28:	e1a0f00e 	mov	pc, lr
+  2c:	32410000 	subcc	r0, r1, #0
+
+00000030 <nand_select_chip>:
+  30:	e3a03456 	mov	r3, #1442840576	; 0x56000000
+  34:	e59f202c 	ldr	r2, [pc, #44]	; 68 <nand_select_chip+0x38>
+  38:	e59330b0 	ldr	r3, [r3, #176]	; 0xb0
+  3c:	e1a03823 	lsr	r3, r3, #16
+  40:	e1a03803 	lsl	r3, r3, #16
+  44:	e1530002 	cmp	r3, r2
+  48:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
+  4c:	05932000 	ldreq	r2, [r3]
+  50:	15932004 	ldrne	r2, [r3, #4]
+  54:	03c22b02 	biceq	r2, r2, #2048	; 0x800
+  58:	13c22002 	bicne	r2, r2, #2
+  5c:	05832000 	streq	r2, [r3]
+  60:	15832004 	strne	r2, [r3, #4]
+  64:	e1a0f00e 	mov	pc, lr
+  68:	32410000 	subcc	r0, r1, #0
+
+0000006c <nand_deselect_chip>:
+  6c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
+  70:	e59f202c 	ldr	r2, [pc, #44]	; a4 <nand_deselect_chip+0x38>
+  74:	e59330b0 	ldr	r3, [r3, #176]	; 0xb0
+  78:	e1a03823 	lsr	r3, r3, #16
+  7c:	e1a03803 	lsl	r3, r3, #16
+  80:	e1530002 	cmp	r3, r2
+  84:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
+  88:	05932000 	ldreq	r2, [r3]
+  8c:	15932004 	ldrne	r2, [r3, #4]
+  90:	03822b02 	orreq	r2, r2, #2048	; 0x800
+  94:	13822002 	orrne	r2, r2, #2
+  98:	05832000 	streq	r2, [r3]
+  9c:	15832004 	strne	r2, [r3, #4]
+  a0:	e1a0f00e 	mov	pc, lr
+  a4:	32410000 	subcc	r0, r1, #0
+
+000000a8 <wait_idle>:
+  a8:	e3a03456 	mov	r3, #1442840576	; 0x56000000
+  ac:	e59f2034 	ldr	r2, [pc, #52]	; e8 <wait_idle+0x40>
+  b0:	e59330b0 	ldr	r3, [r3, #176]	; 0xb0
+  b4:	e1a03823 	lsr	r3, r3, #16
+  b8:	e1a03803 	lsl	r3, r3, #16
+  bc:	e1530002 	cmp	r3, r2
+  c0:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
+  c4:	1a000003 	bne	d8 <wait_idle+0x30>
+  c8:	e5d23010 	ldrb	r3, [r2, #16]
+  cc:	e3130001 	tst	r3, #1
+  d0:	0afffffc 	beq	c8 <wait_idle+0x20>
+  d4:	e1a0f00e 	mov	pc, lr
+  d8:	e5d23020 	ldrb	r3, [r2, #32]
+  dc:	e3130001 	tst	r3, #1
+  e0:	0afffffc 	beq	d8 <wait_idle+0x30>
+  e4:	e1a0f00e 	mov	pc, lr
+  e8:	32410000 	subcc	r0, r1, #0
+
+000000ec <nand_init_ll>:
+  ec:	e3a03456 	mov	r3, #1442840576	; 0x56000000
+  f0:	e59f20b0 	ldr	r2, [pc, #176]	; 1a8 <nand_init_ll+0xbc>
+  f4:	e59330b0 	ldr	r3, [r3, #176]	; 0xb0
+  f8:	e1a03823 	lsr	r3, r3, #16
+  fc:	e1a03803 	lsl	r3, r3, #16
+ 100:	e1530002 	cmp	r3, r2
+ 104:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
+ 108:	059f209c 	ldreq	r2, [pc, #156]	; 1ac <nand_init_ll+0xc0>
+ 10c:	13a02c03 	movne	r2, #768	; 0x300
+ 110:	15832000 	strne	r2, [r3]
+ 114:	13a02013 	movne	r2, #19
+ 118:	15832004 	strne	r2, [r3, #4]
+ 11c:	05832000 	streq	r2, [r3]
+ 120:	e3a03456 	mov	r3, #1442840576	; 0x56000000
+ 124:	e59330b0 	ldr	r3, [r3, #176]	; 0xb0
+ 128:	e59f2078 	ldr	r2, [pc, #120]	; 1a8 <nand_init_ll+0xbc>
+ 12c:	e1a03823 	lsr	r3, r3, #16
+ 130:	e1a03803 	lsl	r3, r3, #16
+ 134:	e1530002 	cmp	r3, r2
+ 138:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
+ 13c:	1a00000c 	bne	174 <nand_init_ll+0x88>
+ 140:	e5932000 	ldr	r2, [r3]
+ 144:	e3c22b02 	bic	r2, r2, #2048	; 0x800
+ 148:	e5832000 	str	r2, [r3]
+ 14c:	e3e02000 	mvn	r2, #0
+ 150:	e5c32004 	strb	r2, [r3, #4]
+ 154:	e5d31010 	ldrb	r1, [r3, #16]
+ 158:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
+ 15c:	e3110001 	tst	r1, #1
+ 160:	0afffffb 	beq	154 <nand_init_ll+0x68>
+ 164:	e5923000 	ldr	r3, [r2]
+ 168:	e3833b02 	orr	r3, r3, #2048	; 0x800
+ 16c:	e5823000 	str	r3, [r2]
+ 170:	e1a0f00e 	mov	pc, lr
+ 174:	e5932004 	ldr	r2, [r3, #4]
+ 178:	e3c22002 	bic	r2, r2, #2
+ 17c:	e5832004 	str	r2, [r3, #4]
+ 180:	e3e02000 	mvn	r2, #0
+ 184:	e5c32008 	strb	r2, [r3, #8]
+ 188:	e5d31020 	ldrb	r1, [r3, #32]
+ 18c:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
+ 190:	e3110001 	tst	r1, #1
+ 194:	0afffffb 	beq	188 <nand_init_ll+0x9c>
+ 198:	e5923004 	ldr	r3, [r2, #4]
+ 19c:	e3833002 	orr	r3, r3, #2
+ 1a0:	e5823004 	str	r3, [r2, #4]
+ 1a4:	e1a0f00e 	mov	pc, lr
+ 1a8:	32410000 	subcc	r0, r1, #0
+ 1ac:	00009830 	andeq	r9, r0, r0, lsr r8
+
+000001b0 <nand_read_ll>:
+ 1b0:	e1a03b81 	lsl	r3, r1, #23
+ 1b4:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
+ 1b8:	e1a06001 	mov	r6, r1
+ 1bc:	e1a03ba3 	lsr	r3, r3, #23
+ 1c0:	e3530000 	cmp	r3, #0
+ 1c4:	18bd82f0 	popne	{r4, r5, r6, r7, r9, pc}
+ 1c8:	e1a03b82 	lsl	r3, r2, #23
+ 1cc:	e1a07002 	mov	r7, r2
+ 1d0:	e1a03ba3 	lsr	r3, r3, #23
+ 1d4:	e3530000 	cmp	r3, #0
+ 1d8:	18bd82f0 	popne	{r4, r5, r6, r7, r9, pc}
+ 1dc:	e59f90cc 	ldr	r9, [pc, #204]	; 2b0 <nand_read_ll+0x100>
+ 1e0:	e1a04006 	mov	r4, r6
+ 1e4:	e1a05000 	mov	r5, r0
+ 1e8:	ebffff90 	bl	30 <nand_select_chip>
+ 1ec:	e0863007 	add	r3, r6, r7
+ 1f0:	e1540003 	cmp	r4, r3
+ 1f4:	2a00002b 	bcs	2a8 <nand_read_ll+0xf8>
+ 1f8:	e3a00000 	mov	r0, #0
+ 1fc:	ebffff7f 	bl	0 <write_cmd>
+ 200:	e3a03456 	mov	r3, #1442840576	; 0x56000000
+ 204:	e204c0ff 	and	ip, r4, #255	; 0xff
+ 208:	e59330b0 	ldr	r3, [r3, #176]	; 0xb0
+ 20c:	e1a004a4 	lsr	r0, r4, #9
+ 210:	e1a018a4 	lsr	r1, r4, #17
+ 214:	e1a02ca4 	lsr	r2, r4, #25
+ 218:	e1a03823 	lsr	r3, r3, #16
+ 21c:	e1a03803 	lsl	r3, r3, #16
+ 220:	e1530009 	cmp	r3, r9
+ 224:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
+ 228:	1a000007 	bne	24c <nand_read_ll+0x9c>
+ 22c:	e20000ff 	and	r0, r0, #255	; 0xff
+ 230:	e20110ff 	and	r1, r1, #255	; 0xff
+ 234:	e20220ff 	and	r2, r2, #255	; 0xff
+ 238:	e5c3c008 	strb	ip, [r3, #8]
+ 23c:	e5c30008 	strb	r0, [r3, #8]
+ 240:	e5c31008 	strb	r1, [r3, #8]
+ 244:	e5c32008 	strb	r2, [r3, #8]
+ 248:	ea000006 	b	268 <nand_read_ll+0xb8>
+ 24c:	e20000ff 	and	r0, r0, #255	; 0xff
+ 250:	e20110ff 	and	r1, r1, #255	; 0xff
+ 254:	e20220ff 	and	r2, r2, #255	; 0xff
+ 258:	e5c3c00c 	strb	ip, [r3, #12]
+ 25c:	e5c3000c 	strb	r0, [r3, #12]
+ 260:	e5c3100c 	strb	r1, [r3, #12]
+ 264:	e5c3200c 	strb	r2, [r3, #12]
+ 268:	ebffff8e 	bl	a8 <wait_idle>
+ 26c:	e2851c02 	add	r1, r5, #512	; 0x200
+ 270:	e3a00456 	mov	r0, #1442840576	; 0x56000000
+ 274:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
+ 278:	e59030b0 	ldr	r3, [r0, #176]	; 0xb0
+ 27c:	e1a03823 	lsr	r3, r3, #16
+ 280:	e1a03803 	lsl	r3, r3, #16
+ 284:	e1530009 	cmp	r3, r9
+ 288:	05d2300c 	ldrbeq	r3, [r2, #12]
+ 28c:	15d23010 	ldrbne	r3, [r2, #16]
+ 290:	e20330ff 	and	r3, r3, #255	; 0xff
+ 294:	e4c53001 	strb	r3, [r5], #1
+ 298:	e1550001 	cmp	r5, r1
+ 29c:	1afffff5 	bne	278 <nand_read_ll+0xc8>
+ 2a0:	e2844c02 	add	r4, r4, #512	; 0x200
+ 2a4:	eaffffd0 	b	1ec <nand_read_ll+0x3c>
+ 2a8:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
+ 2ac:	eaffff6e 	b	6c <nand_deselect_chip>
+ 2b0:	32410000 	subcc	r0, r1, #0
+
+000002b4 <nand_read_ll_lp>:
+ 2b4:	e1a03a81 	lsl	r3, r1, #21
+ 2b8:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
+ 2bc:	e1a06001 	mov	r6, r1
+ 2c0:	e1a03aa3 	lsr	r3, r3, #21
+ 2c4:	e3530000 	cmp	r3, #0
+ 2c8:	18bd82f0 	popne	{r4, r5, r6, r7, r9, pc}
+ 2cc:	e1a03a82 	lsl	r3, r2, #21
+ 2d0:	e1a07002 	mov	r7, r2
+ 2d4:	e1a03aa3 	lsr	r3, r3, #21
+ 2d8:	e3530000 	cmp	r3, #0
+ 2dc:	18bd82f0 	popne	{r4, r5, r6, r7, r9, pc}
+ 2e0:	e59f90f0 	ldr	r9, [pc, #240]	; 3d8 <nand_read_ll_lp+0x124>
+ 2e4:	e1a04006 	mov	r4, r6
+ 2e8:	e1a05000 	mov	r5, r0
+ 2ec:	ebffff4f 	bl	30 <nand_select_chip>
+ 2f0:	e0863007 	add	r3, r6, r7
+ 2f4:	e1540003 	cmp	r4, r3
+ 2f8:	2a000034 	bcs	3d0 <nand_read_ll_lp+0x11c>
+ 2fc:	e3a00000 	mov	r0, #0
+ 300:	ebffff3e 	bl	0 <write_cmd>
+ 304:	e3a03456 	mov	r3, #1442840576	; 0x56000000
+ 308:	e20400ff 	and	r0, r4, #255	; 0xff
+ 30c:	e59330b0 	ldr	r3, [r3, #176]	; 0xb0
+ 310:	e1a03823 	lsr	r3, r3, #16
+ 314:	e1a03803 	lsl	r3, r3, #16
+ 318:	e1530009 	cmp	r3, r9
+ 31c:	1a00000a 	bne	34c <nand_read_ll_lp+0x98>
+ 320:	e1a024a4 	lsr	r2, r4, #9
+ 324:	e3a0344e 	mov	r3, #1308622848	; 0x4e000000
+ 328:	e5c30008 	strb	r0, [r3, #8]
+ 32c:	e20220ff 	and	r2, r2, #255	; 0xff
+ 330:	e5c32008 	strb	r2, [r3, #8]
+ 334:	e1a028a4 	lsr	r2, r4, #17
+ 338:	e20220ff 	and	r2, r2, #255	; 0xff
+ 33c:	e5c32008 	strb	r2, [r3, #8]
+ 340:	e1a02ca4 	lsr	r2, r4, #25
+ 344:	e5c32008 	strb	r2, [r3, #8]
+ 348:	ea00000e 	b	388 <nand_read_ll_lp+0xd4>
+ 34c:	e1a01a84 	lsl	r1, r4, #21
+ 350:	e1a035a4 	lsr	r3, r4, #11
+ 354:	e1a01aa1 	lsr	r1, r1, #21
+ 358:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
+ 35c:	e5c2000c 	strb	r0, [r2, #12]
+ 360:	e1a01421 	lsr	r1, r1, #8
+ 364:	e5c2100c 	strb	r1, [r2, #12]
+ 368:	e20310ff 	and	r1, r3, #255	; 0xff
+ 36c:	e5c2100c 	strb	r1, [r2, #12]
+ 370:	e1a01443 	asr	r1, r3, #8
+ 374:	e1a03843 	asr	r3, r3, #16
+ 378:	e20110ff 	and	r1, r1, #255	; 0xff
+ 37c:	e2033003 	and	r3, r3, #3
+ 380:	e5c2100c 	strb	r1, [r2, #12]
+ 384:	e5c2300c 	strb	r3, [r2, #12]
+ 388:	e3a00030 	mov	r0, #48	; 0x30
+ 38c:	ebffff1b 	bl	0 <write_cmd>
+ 390:	ebffff44 	bl	a8 <wait_idle>
+ 394:	e2851b02 	add	r1, r5, #2048	; 0x800
+ 398:	e3a00456 	mov	r0, #1442840576	; 0x56000000
+ 39c:	e3a0244e 	mov	r2, #1308622848	; 0x4e000000
+ 3a0:	e59030b0 	ldr	r3, [r0, #176]	; 0xb0
+ 3a4:	e1a03823 	lsr	r3, r3, #16
+ 3a8:	e1a03803 	lsl	r3, r3, #16
+ 3ac:	e1530009 	cmp	r3, r9
+ 3b0:	05d2300c 	ldrbeq	r3, [r2, #12]
+ 3b4:	15d23010 	ldrbne	r3, [r2, #16]
+ 3b8:	e20330ff 	and	r3, r3, #255	; 0xff
+ 3bc:	e4c53001 	strb	r3, [r5], #1
+ 3c0:	e1550001 	cmp	r5, r1
+ 3c4:	1afffff5 	bne	3a0 <nand_read_ll_lp+0xec>
+ 3c8:	e2844b02 	add	r4, r4, #2048	; 0x800
+ 3cc:	eaffffc7 	b	2f0 <nand_read_ll_lp+0x3c>
+ 3d0:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
+ 3d4:	eaffff24 	b	6c <nand_deselect_chip>
+ 3d8:	32410000 	subcc	r0, r1, #0
+
+000003dc <bBootFrmNORFlash>:
+ 3dc:	e3a03000 	mov	r3, #0
+ 3e0:	e5933000 	ldr	r3, [r3]
+ 3e4:	e7f000f0 	udf	#0
+
+000003e8 <CopyCode2Ram>:
+ 3e8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
+ 3ec:	ebfffffe 	bl	3dc <bBootFrmNORFlash>
+
+000003f0 <clock_init>:
+ 3f0:	e3a03456 	mov	r3, #1442840576	; 0x56000000
+ 3f4:	e59f2094 	ldr	r2, [pc, #148]	; 490 <clock_init+0xa0>
+ 3f8:	e59330b0 	ldr	r3, [r3, #176]	; 0xb0
+ 3fc:	e1a03823 	lsr	r3, r3, #16
+ 400:	e1a03803 	lsl	r3, r3, #16
+ 404:	e1530002 	cmp	r3, r2
+ 408:	e3a03313 	mov	r3, #1275068416	; 0x4c000000
+ 40c:	1a00000d 	bne	448 <clock_init+0x58>
+ 410:	e3a02003 	mov	r2, #3
+ 414:	e5832014 	str	r2, [r3, #20]
+ 418:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
+ 41c:	e3811103 	orr	r1, r1, #-1073741824	; 0xc0000000
+ 420:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
+ 424:	e3e02000 	mvn	r2, #0
+ 428:	e5832000 	str	r2, [r3]
+ 42c:	e59f2060 	ldr	r2, [pc, #96]	; 494 <clock_init+0xa4>
+ 430:	e5832008 	str	r2, [r3, #8]
+ 434:	e3a02efa 	mov	r2, #4000	; 0xfa0
+ 438:	e2522001 	subs	r2, r2, #1
+ 43c:	1afffffd 	bne	438 <clock_init+0x48>
+ 440:	e59f2050 	ldr	r2, [pc, #80]	; 498 <clock_init+0xa8>
+ 444:	ea00000c 	b	47c <clock_init+0x8c>
+ 448:	e3a02005 	mov	r2, #5
+ 44c:	e5832014 	str	r2, [r3, #20]
+ 450:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
+ 454:	e3811103 	orr	r1, r1, #-1073741824	; 0xc0000000
+ 458:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
+ 45c:	e3e02000 	mvn	r2, #0
+ 460:	e5832000 	str	r2, [r3]
+ 464:	e59f2030 	ldr	r2, [pc, #48]	; 49c <clock_init+0xac>
+ 468:	e5832008 	str	r2, [r3, #8]
+ 46c:	e3a02efa 	mov	r2, #4000	; 0xfa0
+ 470:	e2522001 	subs	r2, r2, #1
+ 474:	1afffffd 	bne	470 <clock_init+0x80>
+ 478:	e59f2020 	ldr	r2, [pc, #32]	; 4a0 <clock_init+0xb0>
+ 47c:	e5832004 	str	r2, [r3, #4]
+ 480:	e3a03d7d 	mov	r3, #8000	; 0x1f40
+ 484:	e2533001 	subs	r3, r3, #1
+ 488:	1afffffd 	bne	484 <clock_init+0x94>
+ 48c:	e1a0f00e 	mov	pc, lr
+ 490:	32410000 	subcc	r0, r1, #0
+ 494:	00028012 	andeq	r8, r2, r2, lsl r0
+ 498:	0005c040 	andeq	ip, r5, r0, asr #32
+ 49c:	00038022 	andeq	r8, r3, r2, lsr #32
+ 4a0:	0005c011 	andeq	ip, r5, r1, lsl r0
+
+Disassembly of section .debug_info:
+
+00000000 <.debug_info>:
+   0:	00000d87 	andeq	r0, r0, r7, lsl #27
+   4:	00000004 	andeq	r0, r0, r4
+   8:	01040000 	mrseq	r0, (UNDEF: 4)
+   c:	000002e0 	andeq	r0, r0, r0, ror #5
+  10:	0001dd01 	andeq	sp, r1, r1, lsl #26
+  14:	0003e200 	andeq	lr, r3, r0, lsl #4
+  18:	00000000 	andeq	r0, r0, r0
+  1c:	0004a400 	andeq	sl, r4, r0, lsl #8
+  20:	00000000 	andeq	r0, r0, r0
+  24:	08010200 	stmdaeq	r1, {r9}
+  28:	000001bc 			; <UNDEFINED> instruction: 0x000001bc
+  2c:	d0070402 	andle	r0, r7, r2, lsl #8
+  30:	02000003 	andeq	r0, r0, #3
+  34:	03a30702 			; <UNDEFINED> instruction: 0x03a30702
+  38:	25030000 	strcs	r0, [r3, #-0]
+  3c:	02000000 	andeq	r0, r0, #0
+  40:	046a0704 	strbteq	r0, [sl], #-1796	; 0x704
+  44:	04040000 	streq	r0, [r4], #-0
+  48:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
+  4c:	05040200 	streq	r0, [r4, #-512]	; 0x200
+  50:	00000162 	andeq	r0, r0, r2, ror #2
+  54:	49070402 	stmdbmi	r7, {r1, sl}
+  58:	02000002 	andeq	r0, r0, #2
+  5c:	02ac0801 	adceq	r0, ip, #65536	; 0x10000
+  60:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
+  64:	00014f05 	andeq	r4, r1, r5, lsl #30
+  68:	06010200 	streq	r0, [r1], -r0, lsl #4
+  6c:	0000010b 	andeq	r0, r0, fp, lsl #2
+  70:	47050202 	strmi	r0, [r5, -r2, lsl #4]
+  74:	02000000 	andeq	r0, r0, #0
+  78:	020f0708 	andeq	r0, pc, #8, 14	; 0x200000
+  7c:	75050000 	strvc	r0, [r5, #-0]
+  80:	03003233 	tsteq	r0, #805306371	; 0x30000003
+  84:	00005425 	andeq	r5, r0, r5, lsr #8
+  88:	04800600 	streq	r0, [r0], #1536	; 0x600
+  8c:	24020000 	strcs	r0, [r2], #-0
+  90:	00000094 	muleq	r0, r4, r0
+  94:	00007e03 	andeq	r7, r0, r3, lsl #28
+  98:	021c0700 	andseq	r0, ip, #0, 14
+  9c:	0000f67a 	andeq	pc, r0, sl, ror r6	; <UNPREDICTABLE>
+  a0:	00810800 	addeq	r0, r1, r0, lsl #16
+  a4:	7b020000 	blvc	800ac <clock_init+0x7fcbc>
+  a8:	00000089 	andeq	r0, r0, r9, lsl #1
+  ac:	00ef0800 	rsceq	r0, pc, r0, lsl #16
+  b0:	7c020000 	stcvc	0, cr0, [r2], {-0}
+  b4:	00000089 	andeq	r0, r0, r9, lsl #1
+  b8:	027a0804 	rsbseq	r0, sl, #4, 16	; 0x40000
+  bc:	7d020000 	stcvc	0, cr0, [r2, #-0]
+  c0:	00000089 	andeq	r0, r0, r9, lsl #1
+  c4:	01e90808 	mvneq	r0, r8, lsl #16
+  c8:	7e020000 	cdpvc	0, 0, cr0, cr2, cr0, {0}
+  cc:	00000089 	andeq	r0, r0, r9, lsl #1
+  d0:	0117080c 	tsteq	r7, ip, lsl #16
+  d4:	7f020000 	svcvc	0x00020000
+  d8:	00000089 	andeq	r0, r0, r9, lsl #1
+  dc:	02970810 	addseq	r0, r7, #16, 16	; 0x100000
+  e0:	80020000 	andhi	r0, r2, r0
+  e4:	00000089 	andeq	r0, r0, r9, lsl #1
+  e8:	04620814 	strbteq	r0, [r2], #-2068	; 0x814
+  ec:	81020000 	mrshi	r0, (UNDEF: 2)
+  f0:	00000089 	andeq	r0, r0, r9, lsl #1
+  f4:	56060018 			; <UNDEFINED> instruction: 0x56060018
+  f8:	02000002 	andeq	r0, r0, #2
+  fc:	00009982 	andeq	r9, r0, r2, lsl #19
+ 100:	02180700 	andseq	r0, r8, #0, 14
+ 104:	0001529f 	muleq	r1, pc, r2	; <UNPREDICTABLE>
+ 108:	008a0800 	addeq	r0, sl, r0, lsl #16
+ 10c:	a0020000 	andge	r0, r2, r0
+ 110:	00000089 	andeq	r0, r0, r9, lsl #1
+ 114:	029f0800 	addseq	r0, pc, #0, 16
+ 118:	a1020000 	mrsge	r0, (UNDEF: 2)
+ 11c:	00000089 	andeq	r0, r0, r9, lsl #1
+ 120:	01040804 	tsteq	r4, r4, lsl #16
+ 124:	a2020000 	andge	r0, r2, #0
+ 128:	00000089 	andeq	r0, r0, r9, lsl #1
+ 12c:	02a50808 	adceq	r0, r5, #8, 16	; 0x80000
+ 130:	a3020000 	tstge	r2, #0
+ 134:	00000089 	andeq	r0, r0, r9, lsl #1
+ 138:	011f080c 	tsteq	pc, ip, lsl #16
+ 13c:	a4020000 	strge	r0, [r2], #-0
+ 140:	00000089 	andeq	r0, r0, r9, lsl #1
+ 144:	03bd0810 			; <UNDEFINED> instruction: 0x03bd0810
+ 148:	a5020000 	strge	r0, [r2, #-0]
+ 14c:	00000089 	andeq	r0, r0, r9, lsl #1
+ 150:	b1060014 	tstlt	r6, r4, lsl r0
+ 154:	02000002 	andeq	r0, r0, #2
+ 158:	000101a6 	andeq	r0, r1, r6, lsr #3
+ 15c:	02400700 	subeq	r0, r0, #0, 14
+ 160:	000226a9 	andeq	r2, r2, r9, lsr #13
+ 164:	008a0800 	addeq	r0, sl, r0, lsl #16
+ 168:	aa020000 	bge	80170 <clock_init+0x7fd80>
+ 16c:	00000089 	andeq	r0, r0, r9, lsl #1
+ 170:	00de0800 	sbcseq	r0, lr, r0, lsl #16
+ 174:	ab020000 	blge	8017c <clock_init+0x7fd8c>
+ 178:	00000089 	andeq	r0, r0, r9, lsl #1
+ 17c:	029f0804 	addseq	r0, pc, #4, 16	; 0x40000
+ 180:	ac020000 	stcge	0, cr0, [r2], {-0}
+ 184:	00000089 	andeq	r0, r0, r9, lsl #1
+ 188:	01040808 	tsteq	r4, r8, lsl #16
+ 18c:	ad020000 	stcge	0, cr0, [r2, #-0]
+ 190:	00000089 	andeq	r0, r0, r9, lsl #1
+ 194:	02a5080c 	adceq	r0, r5, #12, 16	; 0xc0000
+ 198:	ae020000 	cdpge	0, 0, cr0, cr2, cr0, {0}
+ 19c:	00000089 	andeq	r0, r0, r9, lsl #1
+ 1a0:	00350810 	eorseq	r0, r5, r0, lsl r8
+ 1a4:	af020000 	svcge	0x00020000
+ 1a8:	00000089 	andeq	r0, r0, r9, lsl #1
+ 1ac:	003e0814 	eorseq	r0, lr, r4, lsl r8
+ 1b0:	b0020000 	andlt	r0, r2, r0
+ 1b4:	00000089 	andeq	r0, r0, r9, lsl #1
+ 1b8:	03c80818 	biceq	r0, r8, #24, 16	; 0x180000
+ 1bc:	b1020000 	mrslt	r0, (UNDEF: 2)
+ 1c0:	00000089 	andeq	r0, r0, r9, lsl #1
+ 1c4:	011f081c 	tsteq	pc, ip, lsl r8	; <UNPREDICTABLE>
+ 1c8:	b2020000 	andlt	r0, r2, #0
+ 1cc:	00000089 	andeq	r0, r0, r9, lsl #1
+ 1d0:	04960820 	ldreq	r0, [r6], #2080	; 0x820
+ 1d4:	b3020000 	tstlt	r2, #0
+ 1d8:	00000089 	andeq	r0, r0, r9, lsl #1
+ 1dc:	049f0824 	ldreq	r0, [pc], #2084	; 8 <.debug_info+0x8>
+ 1e0:	b4020000 	strlt	r0, [r2], #-0
+ 1e4:	00000089 	andeq	r0, r0, r9, lsl #1
+ 1e8:	026a0828 	rsbeq	r0, sl, #40, 16	; 0x280000
+ 1ec:	b5020000 	strlt	r0, [r2, #-0]
+ 1f0:	00000089 	andeq	r0, r0, r9, lsl #1
+ 1f4:	0272082c 	rsbseq	r0, r2, #44, 16	; 0x2c0000
+ 1f8:	b6020000 	strlt	r0, [r2], -r0
+ 1fc:	00000089 	andeq	r0, r0, r9, lsl #1
+ 200:	01fc0830 	mvnseq	r0, r0, lsr r8
+ 204:	b7020000 	strlt	r0, [r2, -r0]
+ 208:	00000089 	andeq	r0, r0, r9, lsl #1
+ 20c:	044d0834 	strbeq	r0, [sp], #-2100	; 0x834
+ 210:	b8020000 	stmdalt	r2, {}	; <UNPREDICTABLE>
+ 214:	00000089 	andeq	r0, r0, r9, lsl #1
+ 218:	02d90838 	sbcseq	r0, r9, #56, 16	; 0x380000
+ 21c:	b9020000 	stmdblt	r2, {}	; <UNPREDICTABLE>
+ 220:	00000089 	andeq	r0, r0, r9, lsl #1
+ 224:	f706003c 			; <UNDEFINED> instruction: 0xf706003c
+ 228:	02000000 	andeq	r0, r0, #0
+ 22c:	00015dba 			; <UNDEFINED> instruction: 0x00015dba
+ 230:	02370900 	eorseq	r0, r7, #0, 18
+ 234:	54010000 	strpl	r0, [r1], #-0
+ 238:	00025d01 	andeq	r5, r2, r1, lsl #26
+ 23c:	6d630a00 	stclvs	10, cr0, [r3, #-0]
+ 240:	54010064 	strpl	r0, [r1], #-100	; 0x64
+ 244:	00000046 	andeq	r0, r0, r6, asr #32
+ 248:	0002030b 	andeq	r0, r2, fp, lsl #6
+ 24c:	5d560100 	ldfple	f0, [r6, #-0]
+ 250:	0c000002 	stceq	0, cr0, [r0], {2}
+ 254:	58010070 	stmdapl	r1, {r4, r5, r6}
+ 258:	00000263 	andeq	r0, r0, r3, ror #4
+ 25c:	52040d00 	andpl	r0, r4, #0, 26
+ 260:	0d000001 	stceq	0, cr0, [r0, #-4]
+ 264:	00003a04 	andeq	r3, r0, r4, lsl #20
+ 268:	006f0900 	rsbeq	r0, pc, r0, lsl #18
+ 26c:	9f010000 	svcls	0x00010000
+ 270:	00029501 	andeq	r9, r2, r1, lsl #10
+ 274:	6d630a00 	stclvs	10, cr0, [r3, #-0]
+ 278:	9f010064 	svcls	0x00010064
+ 27c:	00000046 	andeq	r0, r0, r6, asr #32
+ 280:	0001f00b 	andeq	pc, r1, fp
+ 284:	95a10100 	strls	r0, [r1, #256]!	; 0x100
+ 288:	0c000002 	stceq	0, cr0, [r0], {2}
+ 28c:	a3010070 	tstge	r1, #112	; 0x70
+ 290:	00000263 	andeq	r0, r0, r3, ror #4
+ 294:	26040d00 	strcs	r0, [r4], -r0, lsl #26
+ 298:	0e000002 	cdpeq	0, 0, cr0, cr0, cr2, {0}
+ 29c:	0000019d 	muleq	r0, sp, r1
+ 2a0:	00256e01 	eoreq	r6, r5, r1, lsl #28
+ 2a4:	c0010000 	andgt	r0, r1, r0
+ 2a8:	0b000002 	bleq	2b8 <.debug_info+0x2b8>
+ 2ac:	00000203 	andeq	r0, r0, r3, lsl #4
+ 2b0:	025d7001 	subseq	r7, sp, #1
+ 2b4:	700c0000 	andvc	r0, ip, r0
+ 2b8:	63720100 	cmnvs	r2, #0, 2
+ 2bc:	00000002 	andeq	r0, r0, r2
+ 2c0:	0000100e 	andeq	r1, r0, lr
+ 2c4:	25d10100 	ldrbcs	r0, [r1, #256]	; 0x100
+ 2c8:	01000000 	mrseq	r0, (UNDEF: 0)
+ 2cc:	000002e5 	andeq	r0, r0, r5, ror #5
+ 2d0:	0001f00b 	andeq	pc, r1, fp
+ 2d4:	95d30100 	ldrbls	r0, [r3, #256]	; 0x100
+ 2d8:	0c000002 	stceq	0, cr0, [r0], {2}
+ 2dc:	d4010070 	strle	r0, [r1], #-112	; 0x70
+ 2e0:	00000263 	andeq	r0, r0, r3, ror #4
+ 2e4:	04200f00 	strteq	r0, [r0], #-3840	; 0xf00
+ 2e8:	86010000 	strhi	r0, [r1], -r0
+ 2ec:	032b0101 	teqeq	fp, #1073741824	; 0x40000000
+ 2f0:	62100000 	andsvs	r0, r0, #0
+ 2f4:	01006675 	tsteq	r0, r5, ror r6
+ 2f8:	032b0186 	teqeq	fp, #-2147483615	; 0x80000021
+ 2fc:	00110000 	andseq	r0, r1, r0
+ 300:	01000000 	mrseq	r0, (UNDEF: 0)
+ 304:	002c0186 	eoreq	r0, ip, r6, lsl #3
+ 308:	c3110000 	tstgt	r1, #0
+ 30c:	01000003 	tsteq	r0, r3
+ 310:	00460186 	subeq	r0, r6, r6, lsl #3
+ 314:	69120000 	ldmdbvs	r2, {}	; <UNPREDICTABLE>
+ 318:	01880100 	orreq	r0, r8, r0, lsl #2
+ 31c:	00000046 	andeq	r0, r0, r6, asr #32
+ 320:	01006a12 	tsteq	r0, r2, lsl sl
+ 324:	00460188 	subeq	r0, r6, r8, lsl #3
+ 328:	0d000000 	stceq	0, cr0, [r0, #-0]
+ 32c:	00002504 	andeq	r2, r0, r4, lsl #10
+ 330:	012c1300 	teqeq	ip, r0, lsl #6
+ 334:	12010000 	andne	r0, r1, #0
+ 338:	00000001 	andeq	r0, r0, r1
+ 33c:	00003000 	andeq	r3, r0, r0
+ 340:	ca9c0100 	bgt	fe700748 <clock_init+0xfe700358>
+ 344:	14000003 	strne	r0, [r0], #-3
+ 348:	00646d63 	rsbeq	r6, r4, r3, ror #26
+ 34c:	46011201 	strmi	r1, [r1], -r1, lsl #4
+ 350:	00000000 	andeq	r0, r0, r0
+ 354:	15000000 	strne	r0, [r0, #-0]
+ 358:	00000231 	andeq	r0, r0, r1, lsr r2
+ 35c:	00000020 	andeq	r0, r0, r0, lsr #32
+ 360:	00000004 	andeq	r0, r0, r4
+ 364:	92011701 	andls	r1, r1, #262144	; 0x40000
+ 368:	16000003 	strne	r0, [r0], -r3
+ 36c:	0000023d 	andeq	r0, r0, sp, lsr r2
+ 370:	5001f304 	andpl	pc, r1, r4, lsl #6
+ 374:	0020179f 	mlaeq	r0, pc, r7, r1	; <UNPREDICTABLE>
+ 378:	00040000 	andeq	r0, r4, r0
+ 37c:	48180000 	ldmdami	r8, {}	; <UNPREDICTABLE>
+ 380:	00000002 	andeq	r0, r0, r2
+ 384:	184e0000 	stmdane	lr, {}^	; <UNPREDICTABLE>
+ 388:	00000253 	andeq	r0, r0, r3, asr r2
+ 38c:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
+ 390:	69190000 	ldmdbvs	r9, {}	; <UNPREDICTABLE>
+ 394:	24000002 	strcs	r0, [r0], #-2
+ 398:	0c000000 	stceq	0, cr0, [r0], {-0}
+ 39c:	01000000 	mrseq	r0, (UNDEF: 0)
+ 3a0:	7516011b 	ldrvc	r0, [r6, #-283]	; 0x11b
+ 3a4:	04000002 	streq	r0, [r0], #-2
+ 3a8:	9f5001f3 	svcls	0x005001f3
+ 3ac:	00002417 	andeq	r2, r0, r7, lsl r4
+ 3b0:	00000c00 	andeq	r0, r0, r0, lsl #24
+ 3b4:	02801800 	addeq	r1, r0, #0, 16
+ 3b8:	00000000 	andeq	r0, r0, r0
+ 3bc:	8b184e00 	blhi	613bc4 <clock_init+0x6137d4>
+ 3c0:	08000002 	stmdaeq	r0, {r1}
+ 3c4:	004e0000 	subeq	r0, lr, r0
+ 3c8:	b3090000 	tstlt	r9, #0
+ 3cc:	01000004 	tsteq	r0, r4
+ 3d0:	03eb0142 	mvneq	r0, #-2147483632	; 0x80000010
+ 3d4:	690c0000 	stmdbvs	ip, {}	; <UNPREDICTABLE>
+ 3d8:	46440100 	strbmi	r0, [r4], -r0, lsl #2
+ 3dc:	0b000000 	bleq	3e4 <.debug_info+0x3e4>
+ 3e0:	00000203 	andeq	r0, r0, r3, lsl #4
+ 3e4:	025d4501 	subseq	r4, sp, #4194304	; 0x400000
+ 3e8:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
+ 3ec:	00000136 	andeq	r0, r0, r6, lsr r1
+ 3f0:	0c018d01 	stceq	13, cr8, [r1], {1}
+ 3f4:	0c000004 	stceq	0, cr0, [r0], {4}
+ 3f8:	8f010069 	svchi	0x00010069
+ 3fc:	00000046 	andeq	r0, r0, r6, asr #32
+ 400:	0001f00b 	andeq	pc, r1, fp
+ 404:	95900100 	ldrls	r0, [r0, #256]	; 0x100
+ 408:	00000002 	andeq	r0, r0, r2
+ 40c:	0002261a 	andeq	r2, r2, sl, lsl r6
+ 410:	30f40100 	rscscc	r0, r4, r0, lsl #2
+ 414:	3c000000 	stccc	0, cr0, [r0], {-0}
+ 418:	01000000 	mrseq	r0, (UNDEF: 0)
+ 41c:	00047a9c 	muleq	r4, ip, sl
+ 420:	00691b00 	rsbeq	r1, r9, r0, lsl #22
+ 424:	0046f601 	subeq	pc, r6, r1, lsl #12
+ 428:	1c000000 	stcne	0, cr0, [r0], {-0}
+ 42c:	000003ca 	andeq	r0, r0, sl, asr #7
+ 430:	0000004c 	andeq	r0, r0, ip, asr #32
+ 434:	00000000 	andeq	r0, r0, r0
+ 438:	0454fb01 	ldrbeq	pc, [r4], #-2817	; 0xb01	; <UNPREDICTABLE>
+ 43c:	001d0000 	andseq	r0, sp, r0
+ 440:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
+ 444:	000003d6 			; <UNDEFINED> instruction: 0x000003d6
+ 448:	03df1800 	bicseq	r1, pc, #0, 16
+ 44c:	00000000 	andeq	r0, r0, r0
+ 450:	00004e00 	andeq	r4, r0, r0, lsl #28
+ 454:	0003eb1f 	andeq	lr, r3, pc, lsl fp
+ 458:	00005000 	andeq	r5, r0, r0
+ 45c:	00002000 	andeq	r2, r0, r0
+ 460:	1dff0100 	ldfnee	f0, [pc]	; 468 <.debug_info+0x468>
+ 464:	00000020 	andeq	r0, r0, r0, lsr #32
+ 468:	0003f71e 	andeq	pc, r3, lr, lsl r7	; <UNPREDICTABLE>
+ 46c:	00180000 	andseq	r0, r8, r0
+ 470:	00000004 	andeq	r0, r0, r4
+ 474:	004e0000 	subeq	r0, lr, r0
+ 478:	aa090000 	bge	240008 <clock_init+0x23fc18>
+ 47c:	01000000 	mrseq	r0, (UNDEF: 0)
+ 480:	0492014c 	ldreq	r0, [r2], #332	; 0x14c
+ 484:	030b0000 	tsteq	fp, #0
+ 488:	01000002 	tsteq	r0, r2
+ 48c:	00025d4e 	andeq	r5, r2, lr, asr #26
+ 490:	be090000 	cdplt	0, 0, cr0, cr9, cr0, {0}
+ 494:	01000002 	tsteq	r0, r2
+ 498:	04aa0197 	strteq	r0, [sl], #407	; 0x197
+ 49c:	f00b0000 			; <UNDEFINED> instruction: 0xf00b0000
+ 4a0:	01000001 	tsteq	r0, r1
+ 4a4:	00029599 	muleq	r2, r9, r5
+ 4a8:	cb130000 	blgt	4c0008 <clock_init+0x4bfc18>
+ 4ac:	01000000 	mrseq	r0, (UNDEF: 0)
+ 4b0:	006c0105 	rsbeq	r0, ip, r5, lsl #2
+ 4b4:	003c0000 	eorseq	r0, ip, r0
+ 4b8:	9c010000 	stcls	0, cr0, [r1], {-0}
+ 4bc:	00000505 	andeq	r0, r0, r5, lsl #10
+ 4c0:	00047a20 	andeq	r7, r4, r0, lsr #20
+ 4c4:	00008800 	andeq	r8, r0, r0, lsl #16
+ 4c8:	00004000 	andeq	r4, r0, r0
+ 4cc:	010a0100 	mrseq	r0, (UNDEF: 26)
+ 4d0:	000004e4 	andeq	r0, r0, r4, ror #9
+ 4d4:	0000401d 	andeq	r4, r0, sp, lsl r0
+ 4d8:	04861800 	streq	r1, [r6], #2048	; 0x800
+ 4dc:	00000000 	andeq	r0, r0, r0
+ 4e0:	00004e00 	andeq	r4, r0, r0, lsl #28
+ 4e4:	00049221 	andeq	r9, r4, r1, lsr #4
+ 4e8:	00008c00 	andeq	r8, r0, r0, lsl #24
+ 4ec:	00006000 	andeq	r6, r0, r0
+ 4f0:	010e0100 	mrseq	r0, (UNDEF: 30)
+ 4f4:	0000601d 	andeq	r6, r0, sp, lsl r0
+ 4f8:	049e1800 	ldreq	r1, [lr], #2048	; 0x800
+ 4fc:	00000000 	andeq	r0, r0, r0
+ 500:	00004e00 	andeq	r4, r0, r0, lsl #28
+ 504:	043b0900 	ldrteq	r0, [fp], #-2304	; 0x900
+ 508:	37010000 	strcc	r0, [r1, -r0]
+ 50c:	00052f01 	andeq	r2, r5, r1, lsl #30
+ 510:	00690c00 	rsbeq	r0, r9, r0, lsl #24
+ 514:	00463901 	subeq	r3, r6, r1, lsl #18
+ 518:	030b0000 	tsteq	fp, #0
+ 51c:	01000002 	tsteq	r0, r2
+ 520:	00025d3a 	andeq	r5, r2, sl, lsr sp
+ 524:	00700c00 	rsbseq	r0, r0, r0, lsl #24
+ 528:	02633c01 	rsbeq	r3, r3, #256	; 0x100
+ 52c:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
+ 530:	00000175 	andeq	r0, r0, r5, ror r1
+ 534:	59018201 	stmdbpl	r1, {r0, r9, pc}
+ 538:	0c000005 	stceq	0, cr0, [r0], {5}
+ 53c:	84010069 	strhi	r0, [r1], #-105	; 0x69
+ 540:	00000046 	andeq	r0, r0, r6, asr #32
+ 544:	0001f00b 	andeq	pc, r1, fp
+ 548:	95850100 	strls	r0, [r5, #256]	; 0x100
+ 54c:	0c000002 	stceq	0, cr0, [r0], {2}
+ 550:	86010070 			; <UNDEFINED> instruction: 0x86010070
+ 554:	00000263 	andeq	r0, r0, r3, ror #4
+ 558:	028d1a00 	addeq	r1, sp, #0, 20
+ 55c:	e7010000 	str	r0, [r1, -r0]
+ 560:	000000a8 	andeq	r0, r0, r8, lsr #1
+ 564:	00000044 	andeq	r0, r0, r4, asr #32
+ 568:	05c19c01 	strbeq	r9, [r1, #3073]	; 0xc01
+ 56c:	051c0000 	ldreq	r0, [ip, #-0]
+ 570:	c0000005 	andgt	r0, r0, r5
+ 574:	80000000 	andhi	r0, r0, r0
+ 578:	01000000 	mrseq	r0, (UNDEF: 0)
+ 57c:	000597ec 	andeq	r9, r5, ip, ror #15
+ 580:	00801d00 	addeq	r1, r0, r0, lsl #26
+ 584:	11220000 	teqne	r2, r0
+ 588:	22000005 	andcs	r0, r0, #5
+ 58c:	0000051a 	andeq	r0, r0, sl, lsl r5
+ 590:	00052522 	andeq	r2, r5, r2, lsr #10
+ 594:	23000000 	tstcs	r0, #0
+ 598:	0000052f 	andeq	r0, r0, pc, lsr #10
+ 59c:	000000d8 			; <UNDEFINED> instruction: 0x000000d8
+ 5a0:	00000014 	andeq	r0, r0, r4, lsl r0
+ 5a4:	d817f001 	ldmdale	r7, {r0, ip, sp, lr, pc}
+ 5a8:	14000000 	strne	r0, [r0], #-0
+ 5ac:	22000000 	andcs	r0, r0, #0
+ 5b0:	0000053b 	andeq	r0, r0, fp, lsr r5
+ 5b4:	00054422 	andeq	r4, r5, r2, lsr #8
+ 5b8:	054f2200 	strbeq	r2, [pc, #-512]	; 3c0 <.debug_info+0x3c0>
+ 5bc:	00000000 	andeq	r0, r0, r0
+ 5c0:	02822400 	addeq	r2, r2, #0, 8
+ 5c4:	da010000 	ble	405cc <clock_init+0x401dc>
+ 5c8:	040d2401 	streq	r2, [sp], #-1025	; 0x401
+ 5cc:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
+ 5d0:	00222401 	eoreq	r2, r2, r1, lsl #8
+ 5d4:	79010000 	stmdbvc	r1, {}	; <UNPREDICTABLE>
+ 5d8:	00512501 	subseq	r2, r1, r1, lsl #10
+ 5dc:	46010000 	strmi	r0, [r1], -r0
+ 5e0:	0000ec01 	andeq	lr, r0, r1, lsl #24
+ 5e4:	0000c400 	andeq	ip, r0, r0, lsl #8
+ 5e8:	c19c0100 	orrsgt	r0, ip, r0, lsl #2
+ 5ec:	26000007 	strcs	r0, [r0], -r7
+ 5f0:	00000203 	andeq	r0, r0, r3, lsl #4
+ 5f4:	5d014801 	stcpl	8, cr4, [r1, #-4]
+ 5f8:	00000002 	andeq	r0, r0, r2
+ 5fc:	264e0000 	strbcs	r0, [lr], -r0
+ 600:	000001f0 			; <UNDEFINED> instruction: 0x000001f0
+ 604:	95014901 	strls	r4, [r1, #-2305]	; 0x901
+ 608:	00000002 	andeq	r0, r0, r2
+ 60c:	194e0000 	stmdbne	lr, {}^	; <UNPREDICTABLE>
+ 610:	000005c1 	andeq	r0, r0, r1, asr #11
+ 614:	00000120 	andeq	r0, r0, r0, lsr #2
+ 618:	00000090 	muleq	r0, r0, r0
+ 61c:	27015e01 	strcs	r5, [r1, -r1, lsl #28]
+ 620:	000005c9 	andeq	r0, r0, r9, asr #11
+ 624:	00000140 	andeq	r0, r0, r0, asr #2
+ 628:	00000034 	andeq	r0, r0, r4, lsr r0
+ 62c:	06f4df01 	ldrbteq	sp, [r4], r1, lsl #30
+ 630:	ca270000 	bgt	9c0638 <clock_init+0x9c0248>
+ 634:	40000003 	andmi	r0, r0, r3
+ 638:	0c000001 	stceq	0, cr0, [r0], {1}
+ 63c:	01000000 	mrseq	r0, (UNDEF: 0)
+ 640:	00066230 	andeq	r6, r6, r0, lsr r2
+ 644:	01401700 	cmpeq	r0, r0, lsl #14
+ 648:	000c0000 	andeq	r0, ip, r0
+ 64c:	d6280000 	strtle	r0, [r8], -r0
+ 650:	21000003 	tstcs	r0, r3
+ 654:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
+ 658:	000003df 			; <UNDEFINED> instruction: 0x000003df
+ 65c:	00000035 	andeq	r0, r0, r5, lsr r0
+ 660:	31270000 	teqcc	r7, r0
+ 664:	4c000002 	stcmi	0, cr0, [r0], {2}
+ 668:	08000001 	stmdaeq	r0, {r0}
+ 66c:	01000000 	mrseq	r0, (UNDEF: 0)
+ 670:	00069b31 	andeq	r9, r6, r1, lsr fp
+ 674:	023d2900 	eorseq	r2, sp, #0, 18
+ 678:	004c0000 	subeq	r0, ip, r0
+ 67c:	4c170000 	ldcmi	0, cr0, [r7], {-0}
+ 680:	08000001 	stmdaeq	r0, {r0}
+ 684:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
+ 688:	00000248 	andeq	r0, r0, r8, asr #4
+ 68c:	00000061 	andeq	r0, r0, r1, rrx
+ 690:	00025328 	andeq	r5, r2, r8, lsr #6
+ 694:	00007800 	andeq	r7, r0, r0, lsl #16
+ 698:	27000000 	strcs	r0, [r0, -r0]
+ 69c:	00000505 	andeq	r0, r0, r5, lsl #10
+ 6a0:	00000154 	andeq	r0, r0, r4, asr r1
+ 6a4:	00000010 	andeq	r0, r0, r0, lsl r0
+ 6a8:	06d03201 	ldrbeq	r3, [r0], r1, lsl #4
+ 6ac:	54170000 	ldrpl	r0, [r7], #-0
+ 6b0:	10000001 	andne	r0, r0, r1
+ 6b4:	22000000 	andcs	r0, r0, #0
+ 6b8:	00000511 	andeq	r0, r0, r1, lsl r5
+ 6bc:	00051a28 	andeq	r1, r5, r8, lsr #20
+ 6c0:	00009000 	andeq	r9, r0, r0
+ 6c4:	05252800 	streq	r2, [r5, #-2048]!	; 0x800
+ 6c8:	00a70000 	adceq	r0, r7, r0
+ 6cc:	00000000 	andeq	r0, r0, r0
+ 6d0:	00047a23 	andeq	r7, r4, r3, lsr #20
+ 6d4:	00016400 	andeq	r6, r1, r0, lsl #8
+ 6d8:	00001000 	andeq	r1, r0, r0
+ 6dc:	17330100 	ldrne	r0, [r3, -r0, lsl #2]!
+ 6e0:	00000164 	andeq	r0, r0, r4, ror #2
+ 6e4:	00000010 	andeq	r0, r0, r0, lsl r0
+ 6e8:	00048628 	andeq	r8, r4, r8, lsr #12
+ 6ec:	0000bf00 	andeq	fp, r0, r0, lsl #30
+ 6f0:	00000000 	andeq	r0, r0, r0
+ 6f4:	0005d123 	andeq	sp, r5, r3, lsr #2
+ 6f8:	00017400 	andeq	r7, r1, r0, lsl #8
+ 6fc:	00003c00 	andeq	r3, r0, r0, lsl #24
+ 700:	27e30100 	strbcs	r0, [r3, r0, lsl #2]!
+ 704:	000003eb 	andeq	r0, r0, fp, ror #7
+ 708:	00000174 	andeq	r0, r0, r4, ror r1
+ 70c:	0000000c 	andeq	r0, r0, ip
+ 710:	07307b01 	ldreq	r7, [r0, -r1, lsl #22]!
+ 714:	74170000 	ldrvc	r0, [r7], #-0
+ 718:	0c000001 	stceq	0, cr0, [r0], {1}
+ 71c:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
+ 720:	000003f7 			; <UNDEFINED> instruction: 0x000003f7
+ 724:	04001800 	streq	r1, [r0], #-2048	; 0x800
+ 728:	00000000 	andeq	r0, r0, r0
+ 72c:	00004e00 	andeq	r4, r0, r0, lsl #28
+ 730:	00026927 	andeq	r6, r2, r7, lsr #18
+ 734:	00018000 	andeq	r8, r1, r0
+ 738:	00000800 	andeq	r0, r0, r0, lsl #16
+ 73c:	667c0100 	ldrbtvs	r0, [ip], -r0, lsl #2
+ 740:	2a000007 	bcs	764 <.debug_info+0x764>
+ 744:	00000275 	andeq	r0, r0, r5, ror r2
+ 748:	018017ff 			; <UNDEFINED> instruction: 0x018017ff
+ 74c:	00080000 	andeq	r0, r8, r0
+ 750:	80180000 	andshi	r0, r8, r0
+ 754:	00000002 	andeq	r0, r0, r2
+ 758:	184e0000 	stmdane	lr, {}^	; <UNPREDICTABLE>
+ 75c:	0000028b 	andeq	r0, r0, fp, lsl #5
+ 760:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
+ 764:	2f270000 	svccs	0x00270000
+ 768:	88000005 	stmdahi	r0, {r0, r2}
+ 76c:	10000001 	andne	r0, r0, r1
+ 770:	01000000 	mrseq	r0, (UNDEF: 0)
+ 774:	00079b7d 	andeq	r9, r7, sp, ror fp
+ 778:	01881700 	orreq	r1, r8, r0, lsl #14
+ 77c:	00100000 	andseq	r0, r0, r0
+ 780:	3b220000 	blcc	880788 <clock_init+0x880398>
+ 784:	18000005 	stmdane	r0, {r0, r2}
+ 788:	00000544 	andeq	r0, r0, r4, asr #10
+ 78c:	4e000000 	cdpmi	0, 0, cr0, cr0, cr0, {0}
+ 790:	00054f18 	andeq	r4, r5, r8, lsl pc
+ 794:	00002000 	andeq	r2, r0, r0
+ 798:	2300004e 	tstcs	r0, #78	; 0x4e
+ 79c:	00000492 	muleq	r0, r2, r4
+ 7a0:	00000198 	muleq	r0, r8, r1
+ 7a4:	00000018 	andeq	r0, r0, r8, lsl r0
+ 7a8:	98177e01 	ldmdals	r7, {r0, r9, sl, fp, ip, sp, lr}
+ 7ac:	18000001 	stmdane	r0, {r0}
+ 7b0:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
+ 7b4:	0000049e 	muleq	r0, lr, r4
+ 7b8:	4e000000 	cdpmi	0, 0, cr0, cr0, cr0, {0}
+ 7bc:	00000000 	andeq	r0, r0, r0
+ 7c0:	04a82b00 	strteq	r2, [r8], #2816	; 0xb00
+ 7c4:	1e010000 	cdpne	0, 0, cr0, cr1, cr0, {0}
+ 7c8:	07db0101 	ldrbeq	r0, [fp, r1, lsl #2]
+ 7cc:	0b110000 	bleq	440008 <clock_init+0x43fc18>
+ 7d0:	01000000 	mrseq	r0, (UNDEF: 0)
+ 7d4:	0054011e 	subseq	r0, r4, lr, lsl r1
+ 7d8:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
+ 7dc:	00000097 	muleq	r0, r7, r0
+ 7e0:	10015d01 	andne	r5, r1, r1, lsl #26
+ 7e4:	2c000008 	stccs	0, cr0, [r0], {8}
+ 7e8:	0000000b 	andeq	r0, r0, fp
+ 7ec:	00545d01 	subseq	r5, r4, r1, lsl #26
+ 7f0:	690c0000 	stmdbvs	ip, {}	; <UNPREDICTABLE>
+ 7f4:	465f0100 	ldrbmi	r0, [pc], -r0, lsl #2
+ 7f8:	0b000000 	bleq	800 <.debug_info+0x800>
+ 7fc:	00000203 	andeq	r0, r0, r3, lsl #4
+ 800:	025d6001 	subseq	r6, sp, #1
+ 804:	700c0000 	andvc	r0, ip, r0
+ 808:	63610100 	cmnvs	r1, #0, 2
+ 80c:	00000002 	andeq	r0, r0, r2
+ 810:	0001ca09 	andeq	ip, r1, r9, lsl #20
+ 814:	01a80100 			; <UNDEFINED> instruction: 0x01a80100
+ 818:	00000845 	andeq	r0, r0, r5, asr #16
+ 81c:	00000b2c 	andeq	r0, r0, ip, lsr #22
+ 820:	54a80100 	strtpl	r0, [r8], #256	; 0x100
+ 824:	0c000000 	stceq	0, cr0, [r0], {-0}
+ 828:	aa010069 	bge	409d4 <clock_init+0x405e4>
+ 82c:	00000046 	andeq	r0, r0, r6, asr #32
+ 830:	0001f00b 	andeq	pc, r1, fp
+ 834:	95ab0100 	strls	r0, [fp, #256]!	; 0x100
+ 838:	0c000002 	stceq	0, cr0, [r0], {2}
+ 83c:	ac010070 	stcge	0, cr0, [r1], {112}	; 0x70
+ 840:	00000263 	andeq	r0, r0, r3, ror #4
+ 844:	00e52d00 	rsceq	r2, r5, r0, lsl #26
+ 848:	38010000 	stmdacc	r1, {}	; <UNPREDICTABLE>
+ 84c:	00002501 	andeq	r2, r0, r1, lsl #10
+ 850:	af250100 	svcge	0x00250100
+ 854:	01000001 	tsteq	r0, r1
+ 858:	01b00163 	rorseq	r0, r3, #2
+ 85c:	01040000 	mrseq	r0, (UNDEF: 4)
+ 860:	9c010000 	stcls	0, cr0, [r1], {-0}
+ 864:	000009f6 			; <UNDEFINED> instruction: 0x000009f6
+ 868:	66756214 			; <UNDEFINED> instruction: 0x66756214
+ 86c:	01630100 	cmneq	r3, r0, lsl #2
+ 870:	0000032b 	andeq	r0, r0, fp, lsr #6
+ 874:	000000d6 			; <UNDEFINED> instruction: 0x000000d6
+ 878:	0000002e 	andeq	r0, r0, lr, lsr #32
+ 87c:	01630100 	cmneq	r3, r0, lsl #2
+ 880:	0000002c 	andeq	r0, r0, ip, lsr #32
+ 884:	000000f4 			; <UNDEFINED> instruction: 0x000000f4
+ 888:	0003c32e 	andeq	ip, r3, lr, lsr #6
+ 88c:	01630100 	cmneq	r3, r0, lsl #2
+ 890:	00000046 	andeq	r0, r0, r6, asr #32
+ 894:	0000012b 	andeq	r0, r0, fp, lsr #2
+ 898:	0100692f 	tsteq	r0, pc, lsr #18
+ 89c:	00460165 	subeq	r0, r6, r5, ror #2
+ 8a0:	01570000 	cmpeq	r7, r0
+ 8a4:	6a2f0000 	bvs	bc08ac <clock_init+0xbc04bc>
+ 8a8:	01650100 	cmneq	r5, r0, lsl #2
+ 8ac:	00000046 	andeq	r0, r0, r6, asr #32
+ 8b0:	00000175 	andeq	r0, r0, r5, ror r1
+ 8b4:	0007c120 	andeq	ip, r7, r0, lsr #2
+ 8b8:	0001dc00 	andeq	sp, r1, r0, lsl #24
+ 8bc:	00009800 	andeq	r9, r0, r0, lsl #16
+ 8c0:	01730100 	cmneq	r3, r0, lsl #2
+ 8c4:	00000954 	andeq	r0, r0, r4, asr r9
+ 8c8:	0007ce29 	andeq	ip, r7, r9, lsr #28
+ 8cc:	00018900 	andeq	r8, r1, r0, lsl #18
+ 8d0:	07db1500 	ldrbeq	r1, [fp, r0, lsl #10]
+ 8d4:	022c0000 	eoreq	r0, ip, #0
+ 8d8:	00200000 	eoreq	r0, r0, r0
+ 8dc:	23010000 	tstcs	r1, #0
+ 8e0:	00091401 	andeq	r1, r9, r1, lsl #8
+ 8e4:	07e72900 	strbeq	r2, [r7, r0, lsl #18]!
+ 8e8:	01aa0000 			; <UNDEFINED> instruction: 0x01aa0000
+ 8ec:	2c170000 	ldccs	0, cr0, [r7], {-0}
+ 8f0:	20000002 	andcs	r0, r0, r2
+ 8f4:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
+ 8f8:	000007f2 			; <UNDEFINED> instruction: 0x000007f2
+ 8fc:	000001bd 			; <UNDEFINED> instruction: 0x000001bd
+ 900:	0007fb28 	andeq	pc, r7, r8, lsr #22
+ 904:	0001d100 	andeq	sp, r1, r0, lsl #2
+ 908:	08062800 	stmdaeq	r6, {fp, sp}
+ 90c:	01e80000 	mvneq	r0, r0
+ 910:	00000000 	andeq	r0, r0, r0
+ 914:	00081019 	andeq	r1, r8, r9, lsl r0
+ 918:	00024c00 	andeq	r4, r2, r0, lsl #24
+ 91c:	00001c00 	andeq	r1, r0, r0, lsl #24
+ 920:	01270100 	teqeq	r7, r0, lsl #2
+ 924:	00081c29 	andeq	r1, r8, r9, lsr #24
+ 928:	00020000 	andeq	r0, r2, r0
+ 92c:	024c1700 	subeq	r1, ip, #0, 14
+ 930:	001c0000 	andseq	r0, ip, r0
+ 934:	27280000 	strcs	r0, [r8, -r0]!
+ 938:	13000008 	tstne	r0, #8
+ 93c:	28000002 	stmdacs	r0, {r1}
+ 940:	00000830 	andeq	r0, r0, r0, lsr r8
+ 944:	00000227 	andeq	r0, r0, r7, lsr #4
+ 948:	00083b28 	andeq	r3, r8, r8, lsr #22
+ 94c:	00023e00 	andeq	r3, r2, r0, lsl #28
+ 950:	00000000 	andeq	r0, r0, r0
+ 954:	00084515 	andeq	r4, r8, r5, lsl r5
+ 958:	00027000 	andeq	r7, r2, r0
+ 95c:	00002400 	andeq	r2, r0, r0, lsl #8
+ 960:	01770100 	cmneq	r7, r0, lsl #2
+ 964:	000009c7 	andeq	r0, r0, r7, asr #19
+ 968:	00029b15 	andeq	r9, r2, r5, lsl fp
+ 96c:	00028800 	andeq	r8, r2, r0, lsl #16
+ 970:	00000400 	andeq	r0, r0, r0, lsl #8
+ 974:	013d0100 	teqeq	sp, r0, lsl #2
+ 978:	00000999 	muleq	r0, r9, r9
+ 97c:	00028817 	andeq	r8, r2, r7, lsl r8
+ 980:	00000400 	andeq	r0, r0, r0, lsl #8
+ 984:	02ab2800 	adceq	r2, fp, #0, 16
+ 988:	02560000 	subseq	r0, r6, #0
+ 98c:	b6280000 	strtlt	r0, [r8], -r0
+ 990:	6d000002 	stcvs	0, cr0, [r0, #-8]
+ 994:	00000002 	andeq	r0, r0, r2
+ 998:	02c01900 	sbceq	r1, r0, #0, 18
+ 99c:	028c0000 	addeq	r0, ip, #0
+ 9a0:	00080000 	andeq	r0, r8, r0
+ 9a4:	41010000 	mrsmi	r0, (UNDEF: 1)
+ 9a8:	028c1701 	addeq	r1, ip, #262144	; 0x40000
+ 9ac:	00080000 	andeq	r0, r8, r0
+ 9b0:	d0280000 	eorle	r0, r8, r0
+ 9b4:	85000002 	strhi	r0, [r0, #-2]
+ 9b8:	28000002 	stmdacs	r0, {r1}
+ 9bc:	000002db 			; <UNDEFINED> instruction: 0x000002db
+ 9c0:	0000029c 	muleq	r0, ip, r2
+ 9c4:	30000000 	andcc	r0, r0, r0
+ 9c8:	000001ec 	andeq	r0, r0, ip, ror #3
+ 9cc:	0000040c 	andeq	r0, r0, ip, lsl #8
+ 9d0:	00020031 	andeq	r0, r2, r1, lsr r0
+ 9d4:	00033100 	andeq	r3, r3, r0, lsl #2
+ 9d8:	0009e300 	andeq	lr, r9, r0, lsl #6
+ 9dc:	50013200 	andpl	r3, r1, r0, lsl #4
+ 9e0:	30003001 	andcc	r3, r0, r1
+ 9e4:	0000026c 	andeq	r0, r0, ip, ror #4
+ 9e8:	00000559 	andeq	r0, r0, r9, asr r5
+ 9ec:	0002b033 	andeq	fp, r2, r3, lsr r0
+ 9f0:	0004aa00 	andeq	sl, r4, r0, lsl #20
+ 9f4:	542b0000 	strtpl	r0, [fp], #-0
+ 9f8:	01000004 	tsteq	r0, r4
+ 9fc:	1001012b 	andne	r0, r1, fp, lsr #2
+ a00:	1100000a 	tstne	r0, sl
+ a04:	0000000b 	andeq	r0, r0, fp
+ a08:	54012b01 	strpl	r2, [r1], #-2817	; 0xb01
+ a0c:	00000000 	andeq	r0, r0, r0
+ a10:	00018709 	andeq	r8, r1, r9, lsl #14
+ a14:	01ba0100 			; <UNDEFINED> instruction: 0x01ba0100
+ a18:	00000a5b 	andeq	r0, r0, fp, asr sl
+ a1c:	00000b2c 	andeq	r0, r0, ip, lsr #22
+ a20:	54ba0100 	ldrtpl	r0, [sl], #256	; 0x100
+ a24:	0c000000 	stceq	0, cr0, [r0], {-0}
+ a28:	bc010069 	stclt	0, cr0, [r1], {105}	; 0x69
+ a2c:	00000046 	andeq	r0, r0, r6, asr #32
+ a30:	0001f00b 	andeq	pc, r1, fp
+ a34:	95bd0100 	ldrls	r0, [sp, #256]!	; 0x100
+ a38:	0c000002 	stceq	0, cr0, [r0], {2}
+ a3c:	be010070 	mcrlt	0, 0, r0, cr1, cr0, {3}
+ a40:	00000263 	andeq	r0, r0, r3, ror #4
+ a44:	6c6f630c 	stclvs	3, cr6, [pc], #-48	; a1c <.debug_info+0xa1c>
+ a48:	46bf0100 	ldrtmi	r0, [pc], r0, lsl #2
+ a4c:	0b000000 	bleq	a54 <.debug_info+0xa54>
+ a50:	0000015d 	andeq	r0, r0, sp, asr r1
+ a54:	0046bf01 	subeq	fp, r6, r1, lsl #30
+ a58:	34000000 	strcc	r0, [r0], #-0
+ a5c:	000002e5 	andeq	r0, r0, r5, ror #5
+ a60:	000002b4 			; <UNDEFINED> instruction: 0x000002b4
+ a64:	00000128 	andeq	r0, r0, r8, lsr #2
+ a68:	0c309c01 	ldceq	12, cr9, [r0], #-4
+ a6c:	f2290000 	vhadd.s32	d0, d9, d0
+ a70:	b4000002 	strlt	r0, [r0], #-2
+ a74:	29000002 	stmdbcs	r0, {r1}
+ a78:	000002fe 			; <UNDEFINED> instruction: 0x000002fe
+ a7c:	000002e0 	andeq	r0, r0, r0, ror #5
+ a80:	00030a29 	andeq	r0, r3, r9, lsr #20
+ a84:	00031700 	andeq	r1, r3, r0, lsl #14
+ a88:	03162200 	tsteq	r6, #0, 4
+ a8c:	20220000 	eorcs	r0, r2, r0
+ a90:	1d000003 	stcne	0, cr0, [r0, #-12]
+ a94:	000000b0 	strheq	r0, [r0], -r0	; <UNPREDICTABLE>
+ a98:	00030a29 	andeq	r0, r3, r9, lsr #20
+ a9c:	00034300 	andeq	r4, r3, r0, lsl #6
+ aa0:	02fe2900 	rscseq	r2, lr, #0, 18
+ aa4:	036f0000 	cmneq	pc, #0
+ aa8:	f2290000 	vhadd.s32	d0, d9, d0
+ aac:	a6000002 	strge	r0, [r0], -r2
+ ab0:	1d000003 	stcne	0, cr0, [r0, #-12]
+ ab4:	000000b0 	strheq	r0, [r0], -r0	; <UNPREDICTABLE>
+ ab8:	00031628 	andeq	r1, r3, r8, lsr #12
+ abc:	0003c400 	andeq	ip, r3, r0, lsl #8
+ ac0:	03202800 	teqeq	r0, #0, 16
+ ac4:	03e20000 	mvneq	r0, #0
+ ac8:	f6200000 			; <UNDEFINED> instruction: 0xf6200000
+ acc:	e0000009 	and	r0, r0, r9
+ ad0:	c8000002 	stmdagt	r0, {r1}
+ ad4:	01000000 	mrseq	r0, (UNDEF: 0)
+ ad8:	0b780196 	bleq	1e01138 <clock_init+0x1e00d48>
+ adc:	03290000 	teqeq	r9, #0
+ ae0:	f600000a 			; <UNDEFINED> instruction: 0xf600000a
+ ae4:	15000003 	strne	r0, [r0, #-3]
+ ae8:	000007db 			; <UNDEFINED> instruction: 0x000007db
+ aec:	00000320 	andeq	r0, r0, r0, lsr #6
+ af0:	0000002c 	andeq	r0, r0, ip, lsr #32
+ af4:	2a013001 	bcs	4cb00 <clock_init+0x4c710>
+ af8:	2900000b 	stmdbcs	r0, {r0, r1, r3}
+ afc:	000007e7 	andeq	r0, r0, r7, ror #15
+ b00:	00000417 	andeq	r0, r0, r7, lsl r4
+ b04:	00032017 	andeq	r2, r3, r7, lsl r0
+ b08:	00002c00 	andeq	r2, r0, r0, lsl #24
+ b0c:	07f22800 	ldrbeq	r2, [r2, r0, lsl #16]!
+ b10:	042a0000 	strteq	r0, [sl], #-0
+ b14:	fb280000 			; <UNDEFINED> instruction: 0xfb280000
+ b18:	3e000007 	cdpcc	0, 0, cr0, cr0, cr7, {0}
+ b1c:	28000004 	stmdacs	r0, {r2}
+ b20:	00000806 	andeq	r0, r0, r6, lsl #16
+ b24:	00000455 	andeq	r0, r0, r5, asr r4
+ b28:	10190000 	andsne	r0, r9, r0
+ b2c:	4c00000a 	stcmi	0, cr0, [r0], {10}
+ b30:	3c000003 	stccc	0, cr0, [r0], {3}
+ b34:	01000000 	mrseq	r0, (UNDEF: 0)
+ b38:	1c290134 	stfnes	f0, [r9], #-208	; 0xffffff30
+ b3c:	6d00000a 	stcvs	0, cr0, [r0, #-40]	; 0xffffffd8
+ b40:	17000004 	strne	r0, [r0, -r4]
+ b44:	0000034c 	andeq	r0, r0, ip, asr #6
+ b48:	0000003c 	andeq	r0, r0, ip, lsr r0
+ b4c:	000a2728 	andeq	r2, sl, r8, lsr #14
+ b50:	00048000 	andeq	r8, r4, r0
+ b54:	0a302800 	beq	c0ab5c <clock_init+0xc0a76c>
+ b58:	04940000 	ldreq	r0, [r4], #0
+ b5c:	3b280000 	blcc	a00b64 <clock_init+0xa00774>
+ b60:	ab00000a 	blge	30 <.debug_info+0x30>
+ b64:	28000004 	stmdacs	r0, {r2}
+ b68:	00000a44 	andeq	r0, r0, r4, asr #20
+ b6c:	000004c3 	andeq	r0, r0, r3, asr #9
+ b70:	000a4f22 	andeq	r4, sl, r2, lsr #30
+ b74:	00000000 	andeq	r0, r0, r0
+ b78:	00084515 	andeq	r4, r8, r5, lsl r5
+ b7c:	00039800 	andeq	r9, r3, r0, lsl #16
+ b80:	00002400 	andeq	r2, r0, r0, lsl #8
+ b84:	019b0100 	orrseq	r0, fp, r0, lsl #2
+ b88:	00000beb 	andeq	r0, r0, fp, ror #23
+ b8c:	00029b15 	andeq	r9, r2, r5, lsl fp
+ b90:	0003b000 	andeq	fp, r3, r0
+ b94:	00000400 	andeq	r0, r0, r0, lsl #8
+ b98:	013d0100 	teqeq	sp, r0, lsl #2
+ b9c:	00000bbd 			; <UNDEFINED> instruction: 0x00000bbd
+ ba0:	0003b017 	andeq	fp, r3, r7, lsl r0
+ ba4:	00000400 	andeq	r0, r0, r0, lsl #8
+ ba8:	02ab2800 	adceq	r2, fp, #0, 16
+ bac:	04e70000 	strbteq	r0, [r7], #0
+ bb0:	b6280000 	strtlt	r0, [r8], -r0
+ bb4:	fe000002 			; <UNDEFINED> instruction: 0xfe000002
+ bb8:	00000004 	andeq	r0, r0, r4
+ bbc:	02c01900 	sbceq	r1, r0, #0, 18
+ bc0:	03b40000 			; <UNDEFINED> instruction: 0x03b40000
+ bc4:	00080000 	andeq	r0, r8, r0
+ bc8:	41010000 	mrsmi	r0, (UNDEF: 1)
+ bcc:	03b41701 			; <UNDEFINED> instruction: 0x03b41701
+ bd0:	00080000 	andeq	r0, r8, r0
+ bd4:	d0280000 	eorle	r0, r8, r0
+ bd8:	16000002 	strne	r0, [r0], -r2
+ bdc:	28000005 	stmdacs	r0, {r0, r2}
+ be0:	000002db 			; <UNDEFINED> instruction: 0x000002db
+ be4:	0000052d 	andeq	r0, r0, sp, lsr #10
+ be8:	30000000 	andcc	r0, r0, r0
+ bec:	000002f0 			; <UNDEFINED> instruction: 0x000002f0
+ bf0:	0000040c 	andeq	r0, r0, ip, lsl #8
+ bf4:	00030431 	andeq	r0, r3, r1, lsr r4
+ bf8:	00033100 	andeq	r3, r3, r0, lsl #2
+ bfc:	000c0700 	andeq	r0, ip, r0, lsl #14
+ c00:	50013200 	andpl	r3, r1, r0, lsl #4
+ c04:	31003001 	tstcc	r0, r1
+ c08:	00000390 	muleq	r0, r0, r3
+ c0c:	00000331 	andeq	r0, r0, r1, lsr r3
+ c10:	00000c1b 	andeq	r0, r0, fp, lsl ip
+ c14:	02500132 	subseq	r0, r0, #-2147483636	; 0x8000000c
+ c18:	30003008 	andcc	r3, r0, r8
+ c1c:	00000394 	muleq	r0, r4, r3
+ c20:	00000559 	andeq	r0, r0, r9, asr r5
+ c24:	0003d833 	andeq	sp, r3, r3, lsr r8
+ c28:	0004aa00 	andeq	sl, r4, r0, lsl #20
+ c2c:	00000000 	andeq	r0, r0, r0
+ c30:	00005e35 	andeq	r5, r0, r5, lsr lr
+ c34:	01a60100 			; <UNDEFINED> instruction: 0x01a60100
+ c38:	00000046 	andeq	r0, r0, r6, asr #32
+ c3c:	000003dc 			; <UNDEFINED> instruction: 0x000003dc
+ c40:	0000000c 	andeq	r0, r0, ip
+ c44:	0c669c01 	stcleq	12, cr9, [r6], #-4
+ c48:	70360000 	eorsvc	r0, r6, r0
+ c4c:	01007764 	tsteq	r0, r4, ror #14
+ c50:	0c6601a8 	stfeqe	f0, [r6], #-672	; 0xfffffd60
+ c54:	37000000 	strcc	r0, [r0, -r0]
+ c58:	00000126 	andeq	r0, r0, r6, lsr #2
+ c5c:	5401a901 	strpl	sl, [r1], #-2305	; 0x901
+ c60:	01000000 	mrseq	r0, (UNDEF: 0)
+ c64:	040d0053 	streq	r0, [sp], #-83	; 0x53
+ c68:	00000c6c 	andeq	r0, r0, ip, ror #24
+ c6c:	00005403 	andeq	r5, r0, r3, lsl #8
+ c70:	04733500 	ldrbteq	r3, [r3], #-1280	; 0x500
+ c74:	c2010000 	andgt	r0, r1, #0
+ c78:	00004601 	andeq	r4, r0, r1, lsl #12
+ c7c:	0003e800 	andeq	lr, r3, r0, lsl #16
+ c80:	00000800 	andeq	r0, r0, r0, lsl #16
+ c84:	e79c0100 	ldr	r0, [ip, r0, lsl #2]
+ c88:	2e00000c 	cdpcs	0, 0, cr0, cr0, cr12, {0}
+ c8c:	00000000 	andeq	r0, r0, r0
+ c90:	2c01c201 	sfmcs	f4, 1, [r1], {1}
+ c94:	45000000 	strmi	r0, [r0, #-0]
+ c98:	14000005 	strne	r0, [r0], #-5
+ c9c:	00667562 	rsbeq	r7, r6, r2, ror #10
+ ca0:	2b01c201 	blcs	714ac <clock_init+0x710bc>
+ ca4:	66000003 	strvs	r0, [r0], -r3
+ ca8:	2e000005 	cdpcs	0, 0, cr0, cr0, cr5, {0}
+ cac:	000003c3 	andeq	r0, r0, r3, asr #7
+ cb0:	4601c201 	strmi	ip, [r1], -r1, lsl #4
+ cb4:	87000000 	strhi	r0, [r0, -r0]
+ cb8:	38000005 	stmdacc	r0, {r0, r2}
+ cbc:	0000048e 	andeq	r0, r0, lr, lsl #9
+ cc0:	e701c401 	str	ip, [r1, -r1, lsl #8]
+ cc4:	3800000c 	stmdacc	r0, {r2, r3}
+ cc8:	000003b6 			; <UNDEFINED> instruction: 0x000003b6
+ ccc:	e701c501 	str	ip, [r1, -r1, lsl #10]
+ cd0:	1200000c 	andne	r0, r0, #12
+ cd4:	c6010069 	strgt	r0, [r1], -r9, rrx
+ cd8:	00004601 	andeq	r4, r0, r1, lsl #12
+ cdc:	03f03000 	mvnseq	r3, #0
+ ce0:	0c300000 	ldceq	0, cr0, [r0], #-0
+ ce4:	0d000000 	stceq	0, cr0, [r0, #-0]
+ ce8:	00005404 	andeq	r5, r0, r4, lsl #8
+ cec:	00912b00 	addseq	r2, r1, r0, lsl #22
+ cf0:	dd010000 	stcle	0, cr0, [r1, #-0]
+ cf4:	0d070301 	stceq	3, cr0, [r7, #-4]
+ cf8:	c5110000 	ldrgt	r0, [r1, #-0]
+ cfc:	01000000 	mrseq	r0, (UNDEF: 0)
+ d00:	002c01dd 			; <UNDEFINED> instruction: 0x002c01dd
+ d04:	25000000 	strcs	r0, [r0, #-0]
+ d08:	00000430 	andeq	r0, r0, r0, lsr r4
+ d0c:	f001fa01 			; <UNDEFINED> instruction: 0xf001fa01
+ d10:	b4000003 	strlt	r0, [r0], #-3
+ d14:	01000000 	mrseq	r0, (UNDEF: 0)
+ d18:	000d849c 	muleq	sp, ip, r4
+ d1c:	016b2600 	cmneq	fp, r0, lsl #12
+ d20:	fc010000 			; <UNDEFINED> instruction: 0xfc010000
+ d24:	000d8401 	andeq	r8, sp, r1, lsl #8
+ d28:	00000000 	andeq	r0, r0, r0
+ d2c:	0ced154c 	stcleq	5, cr1, [sp], #304	; 0x130
+ d30:	04340000 	ldrteq	r0, [r4], #-0
+ d34:	000c0000 	andeq	r0, ip, r0
+ d38:	12010000 	andne	r0, r1, #0
+ d3c:	000d4b02 	andeq	r4, sp, r2, lsl #22
+ d40:	0cfa2900 	ldcleq	9, cr2, [sl]
+ d44:	05a80000 	streq	r0, [r8, #0]!
+ d48:	15000000 	strne	r0, [r0, #-0]
+ d4c:	00000ced 	andeq	r0, r0, sp, ror #25
+ d50:	0000046c 	andeq	r0, r0, ip, ror #8
+ d54:	0000000c 	andeq	r0, r0, ip
+ d58:	69022d01 	stmdbvs	r2, {r0, r8, sl, fp, sp}
+ d5c:	2900000d 	stmdbcs	r0, {r0, r2, r3}
+ d60:	00000cfa 			; <UNDEFINED> instruction: 0x00000cfa
+ d64:	000005be 			; <UNDEFINED> instruction: 0x000005be
+ d68:	0ced1900 	stcleq	9, cr1, [sp]
+ d6c:	04800000 	streq	r0, [r0], #0
+ d70:	00240000 	eoreq	r0, r4, r0
+ d74:	33010000 	tstcc	r1, #0
+ d78:	0cfa2902 	ldcleq	9, cr2, [sl], #8
+ d7c:	05d40000 	ldrbeq	r0, [r4]
+ d80:	00000000 	andeq	r0, r0, r0
+ d84:	00f6040d 	rscseq	r0, r6, sp, lsl #8
+ d88:	Address 0x0000000000000d88 is out of bounds.
+
+
+Disassembly of section .debug_abbrev:
+
+00000000 <.debug_abbrev>:
+   0:	25011101 	strcs	r1, [r1, #-257]	; 0x101
+   4:	030b130e 	tsteq	fp, #939524096	; 0x38000000
+   8:	110e1b0e 	tstne	lr, lr, lsl #22
+   c:	10061201 	andne	r1, r6, r1, lsl #4
+  10:	02000017 	andeq	r0, r0, #23
+  14:	0b0b0024 	bleq	2c00ac <clock_init+0x2bfcbc>
+  18:	0e030b3e 	mcreq	11, 0, r0, cr3, cr14, {1}
+  1c:	35030000 	strcc	r0, [r3, #-0]
+  20:	00134900 	andseq	r4, r3, r0, lsl #18
+  24:	00240400 	eoreq	r0, r4, r0, lsl #8
+  28:	0b3e0b0b 	bleq	f82c5c <clock_init+0xf8286c>
+  2c:	00000803 	andeq	r0, r0, r3, lsl #16
+  30:	03001605 	tsteq	r0, #5242880	; 0x500000
+  34:	3b0b3a08 	blcc	2ce85c <clock_init+0x2ce46c>
+  38:	0013490b 	andseq	r4, r3, fp, lsl #18
+  3c:	00160600 	andseq	r0, r6, r0, lsl #12
+  40:	0b3a0e03 	bleq	e83854 <clock_init+0xe83464>
+  44:	13490b3b 	cmpne	r9, #60416	; 0xec00
+  48:	13070000 	tstne	r7, #0
+  4c:	3a0b0b01 	bcc	2c2c58 <clock_init+0x2c2868>
+  50:	010b3b0b 	tsteq	fp, fp, lsl #22
+  54:	08000013 	stmdaeq	r0, {r0, r1, r4}
+  58:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
+  5c:	0b3b0b3a 	bleq	ec2d4c <clock_init+0xec295c>
+  60:	0b381349 	bleq	e04d8c <clock_init+0xe0499c>
+  64:	2e090000 	cdpcs	0, 0, cr0, cr9, cr0, {0}
+  68:	3a0e0301 	bcc	380c74 <clock_init+0x380884>
+  6c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
+  70:	010b2019 	tsteq	fp, r9, lsl r0
+  74:	0a000013 	beq	c8 <.debug_abbrev+0xc8>
+  78:	08030005 	stmdaeq	r3, {r0, r2}
+  7c:	0b3b0b3a 	bleq	ec2d6c <clock_init+0xec297c>
+  80:	00001349 	andeq	r1, r0, r9, asr #6
+  84:	0300340b 	tsteq	r0, #184549376	; 0xb000000
+  88:	3b0b3a0e 	blcc	2ce8c8 <clock_init+0x2ce4d8>
+  8c:	0013490b 	andseq	r4, r3, fp, lsl #18
+  90:	00340c00 	eorseq	r0, r4, r0, lsl #24
+  94:	0b3a0803 	bleq	e820a8 <clock_init+0xe81cb8>
+  98:	13490b3b 	cmpne	r9, #60416	; 0xec00
+  9c:	0f0d0000 	svceq	0x000d0000
+  a0:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
+  a4:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
+  a8:	0e03012e 	adfeqsp	f0, f3, #0.5
+  ac:	0b3b0b3a 	bleq	ec2d9c <clock_init+0xec29ac>
+  b0:	13491927 	cmpne	r9, #638976	; 0x9c000
+  b4:	13010b20 	tstne	r1, #32, 22	; 0x8000
+  b8:	2e0f0000 	cdpcs	0, 0, cr0, cr15, cr0, {0}
+  bc:	03193f01 	tsteq	r9, #1, 30
+  c0:	3b0b3a0e 	blcc	2ce900 <clock_init+0x2ce510>
+  c4:	20192705 	andscs	r2, r9, r5, lsl #14
+  c8:	0013010b 	andseq	r0, r3, fp, lsl #2
+  cc:	00051000 	andeq	r1, r5, r0
+  d0:	0b3a0803 	bleq	e820e4 <clock_init+0xe81cf4>
+  d4:	1349053b 	cmpne	r9, #247463936	; 0xec00000
+  d8:	05110000 	ldreq	r0, [r1, #-0]
+  dc:	3a0e0300 	bcc	380ce4 <clock_init+0x3808f4>
+  e0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
+  e4:	12000013 	andne	r0, r0, #19
+  e8:	08030034 	stmdaeq	r3, {r2, r4, r5}
+  ec:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
+  f0:	00001349 	andeq	r1, r0, r9, asr #6
+  f4:	03012e13 	tsteq	r1, #304	; 0x130
+  f8:	3b0b3a0e 	blcc	2ce938 <clock_init+0x2ce548>
+  fc:	11192705 	tstne	r9, r5, lsl #14
+ 100:	40061201 	andmi	r1, r6, r1, lsl #4
+ 104:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
+ 108:	00001301 	andeq	r1, r0, r1, lsl #6
+ 10c:	03000514 	tsteq	r0, #20, 10	; 0x5000000
+ 110:	3b0b3a08 	blcc	2ce938 <clock_init+0x2ce548>
+ 114:	02134905 	andseq	r4, r3, #81920	; 0x14000
+ 118:	15000017 	strne	r0, [r0, #-23]
+ 11c:	1331011d 	teqne	r1, #1073741831	; 0x40000007
+ 120:	06120111 			; <UNDEFINED> instruction: 0x06120111
+ 124:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58
+ 128:	00001301 	andeq	r1, r0, r1, lsl #6
+ 12c:	31000516 	tstcc	r0, r6, lsl r5
+ 130:	00180213 	andseq	r0, r8, r3, lsl r2
+ 134:	010b1700 	tsteq	fp, r0, lsl #14
+ 138:	06120111 			; <UNDEFINED> instruction: 0x06120111
+ 13c:	34180000 	ldrcc	r0, [r8], #-0
+ 140:	1c133100 	ldfnes	f3, [r3], {-0}
+ 144:	19000006 	stmdbne	r0, {r1, r2}
+ 148:	1331011d 	teqne	r1, #1073741831	; 0x40000007
+ 14c:	06120111 			; <UNDEFINED> instruction: 0x06120111
+ 150:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58
+ 154:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}
+ 158:	3a0e0301 	bcc	380d64 <clock_init+0x380974>
+ 15c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
+ 160:	12011119 	andne	r1, r1, #1073741830	; 0x40000006
+ 164:	97184006 	ldrls	r4, [r8, -r6]
+ 168:	13011942 	tstne	r1, #1081344	; 0x108000
+ 16c:	341b0000 	ldrcc	r0, [fp], #-0
+ 170:	3a080300 	bcc	200d78 <clock_init+0x200988>
+ 174:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
+ 178:	000b1c13 	andeq	r1, fp, r3, lsl ip
+ 17c:	011d1c00 	tsteq	sp, r0, lsl #24
+ 180:	01521331 	cmpeq	r2, r1, lsr r3
+ 184:	0b581755 	bleq	1605ee0 <clock_init+0x1605af0>
+ 188:	13010b59 	tstne	r1, #91136	; 0x16400
+ 18c:	0b1d0000 	bleq	740194 <clock_init+0x73fda4>
+ 190:	00175501 	andseq	r5, r7, r1, lsl #10
+ 194:	00341e00 	eorseq	r1, r4, r0, lsl #28
+ 198:	0b1c1331 	bleq	704e64 <clock_init+0x704a74>
+ 19c:	1d1f0000 	ldcne	0, cr0, [pc, #-0]	; 1a4 <.debug_abbrev+0x1a4>
+ 1a0:	52133101 	andspl	r3, r3, #1073741824	; 0x40000000
+ 1a4:	58175501 	ldmdapl	r7, {r0, r8, sl, ip, lr}
+ 1a8:	000b590b 	andeq	r5, fp, fp, lsl #18
+ 1ac:	011d2000 	tsteq	sp, r0
+ 1b0:	01521331 	cmpeq	r2, r1, lsr r3
+ 1b4:	0b581755 	bleq	1605f10 <clock_init+0x1605b20>
+ 1b8:	13010559 	tstne	r1, #373293056	; 0x16400000
+ 1bc:	1d210000 	stcne	0, cr0, [r1, #-0]
+ 1c0:	52133101 	andspl	r3, r3, #1073741824	; 0x40000000
+ 1c4:	58175501 	ldmdapl	r7, {r0, r8, sl, ip, lr}
+ 1c8:	0005590b 	andeq	r5, r5, fp, lsl #18
+ 1cc:	00342200 	eorseq	r2, r4, r0, lsl #4
+ 1d0:	00001331 	andeq	r1, r0, r1, lsr r3
+ 1d4:	31011d23 	tstcc	r1, r3, lsr #26
+ 1d8:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
+ 1dc:	590b5806 	stmdbpl	fp, {r1, r2, fp, ip, lr}
+ 1e0:	2400000b 	strcs	r0, [r0], #-11
+ 1e4:	0e03002e 	cdpeq	0, 0, cr0, cr3, cr14, {1}
+ 1e8:	0b3b0b3a 	bleq	ec2ed8 <clock_init+0xec2ae8>
+ 1ec:	0b201927 	bleq	806690 <clock_init+0x8062a0>
+ 1f0:	2e250000 	cdpcs	0, 2, cr0, cr5, cr0, {0}
+ 1f4:	03193f01 	tsteq	r9, #1, 30
+ 1f8:	3b0b3a0e 	blcc	2cea38 <clock_init+0x2ce648>
+ 1fc:	11192705 	tstne	r9, r5, lsl #14
+ 200:	40061201 	andmi	r1, r6, r1, lsl #4
+ 204:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
+ 208:	00001301 	andeq	r1, r0, r1, lsl #6
+ 20c:	03003426 	tsteq	r0, #637534208	; 0x26000000
+ 210:	3b0b3a0e 	blcc	2cea50 <clock_init+0x2ce660>
+ 214:	1c134905 	ldcne	9, cr4, [r3], {5}
+ 218:	27000006 	strcs	r0, [r0, -r6]
+ 21c:	1331011d 	teqne	r1, #1073741831	; 0x40000007
+ 220:	06120111 			; <UNDEFINED> instruction: 0x06120111
+ 224:	0b590b58 	bleq	1642f8c <clock_init+0x1642b9c>
+ 228:	00001301 	andeq	r1, r0, r1, lsl #6
+ 22c:	31003428 	tstcc	r0, r8, lsr #8
+ 230:	00170213 	andseq	r0, r7, r3, lsl r2
+ 234:	00052900 	andeq	r2, r5, r0, lsl #18
+ 238:	17021331 			; <UNDEFINED> instruction: 0x17021331
+ 23c:	052a0000 	streq	r0, [sl, #-0]!
+ 240:	1c133100 	ldfnes	f3, [r3], {-0}
+ 244:	2b00000b 	blcs	278 <.debug_abbrev+0x278>
+ 248:	0e03012e 	adfeqsp	f0, f3, #0.5
+ 24c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
+ 250:	0b201927 	bleq	8066f4 <clock_init+0x806304>
+ 254:	00001301 	andeq	r1, r0, r1, lsl #6
+ 258:	0300052c 	tsteq	r0, #44, 10	; 0xb000000
+ 25c:	3b0b3a0e 	blcc	2cea9c <clock_init+0x2ce6ac>
+ 260:	0013490b 	andseq	r4, r3, fp, lsl #18
+ 264:	002e2d00 	eoreq	r2, lr, r0, lsl #26
+ 268:	0b3a0e03 	bleq	e83a7c <clock_init+0xe8368c>
+ 26c:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
+ 270:	0b201349 	bleq	804f9c <clock_init+0x804bac>
+ 274:	052e0000 	streq	r0, [lr, #-0]!
+ 278:	3a0e0300 	bcc	380e80 <clock_init+0x380a90>
+ 27c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
+ 280:	00170213 	andseq	r0, r7, r3, lsl r2
+ 284:	00342f00 	eorseq	r2, r4, r0, lsl #30
+ 288:	0b3a0803 	bleq	e8229c <clock_init+0xe81eac>
+ 28c:	1349053b 	cmpne	r9, #247463936	; 0xec00000
+ 290:	00001702 	andeq	r1, r0, r2, lsl #14
+ 294:	01828930 	orreq	r8, r2, r0, lsr r9
+ 298:	31011100 	mrscc	r1, (UNDEF: 17)
+ 29c:	31000013 	tstcc	r0, r3, lsl r0
+ 2a0:	01018289 	tsteq	r1, r9, lsl #5
+ 2a4:	13310111 	teqne	r1, #1073741828	; 0x40000004
+ 2a8:	00001301 	andeq	r1, r0, r1, lsl #6
+ 2ac:	01828a32 	orreq	r8, r2, r2, lsr sl
+ 2b0:	91180200 	tstls	r8, r0, lsl #4
+ 2b4:	00001842 	andeq	r1, r0, r2, asr #16
+ 2b8:	01828933 	orreq	r8, r2, r3, lsr r9
+ 2bc:	95011100 	strls	r1, [r1, #-256]	; 0x100
+ 2c0:	13311942 	teqne	r1, #1081344	; 0x108000
+ 2c4:	2e340000 	cdpcs	0, 3, cr0, cr4, cr0, {0}
+ 2c8:	11133101 	tstne	r3, r1, lsl #2
+ 2cc:	40061201 	andmi	r1, r6, r1, lsl #4
+ 2d0:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
+ 2d4:	00001301 	andeq	r1, r0, r1, lsl #6
+ 2d8:	3f012e35 	svccc	0x00012e35
+ 2dc:	3a0e0319 	bcc	380f48 <clock_init+0x380b58>
+ 2e0:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
+ 2e4:	11134919 	tstne	r3, r9, lsl r9
+ 2e8:	40061201 	andmi	r1, r6, r1, lsl #4
+ 2ec:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
+ 2f0:	00001301 	andeq	r1, r0, r1, lsl #6
+ 2f4:	03003436 	tsteq	r0, #905969664	; 0x36000000
+ 2f8:	3b0b3a08 	blcc	2ceb20 <clock_init+0x2ce730>
+ 2fc:	1c134905 	ldcne	9, cr4, [r3], {5}
+ 300:	3700000b 	strcc	r0, [r0, -fp]
+ 304:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
+ 308:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
+ 30c:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
+ 310:	34380000 	ldrtcc	r0, [r8], #-0
+ 314:	3a0e0300 	bcc	380f1c <clock_init+0x380b2c>
+ 318:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
+ 31c:	00000013 	andeq	r0, r0, r3, lsl r0
+
+Disassembly of section .debug_loc:
+
+00000000 <.debug_loc>:
+   0:	00000000 	andeq	r0, r0, r0
+   4:	00000010 	andeq	r0, r0, r0, lsl r0
+   8:	10500001 	subsne	r0, r0, r1
+   c:	30000000 	andcc	r0, r0, r0
+  10:	04000000 	streq	r0, [r0], #-0
+  14:	5001f300 	andpl	pc, r1, r0, lsl #6
+  18:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
+  1c:	00000000 	andeq	r0, r0, r0
+  20:	00014c00 	andeq	r4, r1, r0, lsl #24
+  24:	00017400 	andeq	r7, r1, r0, lsl #8
+  28:	30000200 	andcc	r0, r0, r0, lsl #4
+  2c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
+  30:	00000000 	andeq	r0, r0, r0
+  34:	00014000 	andeq	r4, r1, r0
+  38:	00017400 	andeq	r7, r1, r0, lsl #8
+  3c:	08000500 	stmdaeq	r0, {r8, sl}
+  40:	9f24479c 	svcls	0x0024479c
+	...
+  4c:	0000014c 	andeq	r0, r0, ip, asr #2
+  50:	00000174 	andeq	r0, r0, r4, ror r1
+  54:	ff080003 			; <UNDEFINED> instruction: 0xff080003
+  58:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
+  5c:	00000000 	andeq	r0, r0, r0
+  60:	00014c00 	andeq	r4, r1, r0, lsl #24
+  64:	00017400 	andeq	r7, r1, r0, lsl #8
+  68:	08000500 	stmdaeq	r0, {r8, sl}
+  6c:	9f24479c 	svcls	0x0024479c
+	...
+  78:	0000014c 	andeq	r0, r0, ip, asr #2
+  7c:	00000174 	andeq	r0, r0, r4, ror r1
+  80:	040c0006 	streq	r0, [ip], #-6
+  84:	9f4e0000 	svcls	0x004e0000
+	...
+  90:	00000154 	andeq	r0, r0, r4, asr r1
+  94:	00000174 	andeq	r0, r0, r4, ror r1
+  98:	9c080005 	stcls	0, cr0, [r8], {5}
+  9c:	009f2447 	addseq	r2, pc, r7, asr #8
+  a0:	00000000 	andeq	r0, r0, r0
+  a4:	54000000 	strpl	r0, [r0], #-0
+  a8:	74000001 	strvc	r0, [r0], #-1
+  ac:	06000001 	streq	r0, [r0], -r1
+  b0:	00100c00 	andseq	r0, r0, r0, lsl #24
+  b4:	009f4e00 	addseq	r4, pc, r0, lsl #28
+  b8:	00000000 	andeq	r0, r0, r0
+  bc:	64000000 	strvs	r0, [r0], #-0
+  c0:	74000001 	strvc	r0, [r0], #-1
+  c4:	05000001 	streq	r0, [r0, #-1]
+  c8:	479c0800 	ldrmi	r0, [ip, r0, lsl #16]
+  cc:	00009f24 	andeq	r9, r0, r4, lsr #30
+  d0:	00000000 	andeq	r0, r0, r0
+  d4:	01b00000 	movseq	r0, r0
+  d8:	01eb0000 	mvneq	r0, r0
+  dc:	00010000 	andeq	r0, r1, r0
+  e0:	0001eb50 	andeq	lr, r1, r0, asr fp
+  e4:	0002ac00 	andeq	sl, r2, r0, lsl #24
+  e8:	55000100 	strpl	r0, [r0, #-256]	; 0x100
+	...
+  f4:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
+  f8:	000001eb 	andeq	r0, r0, fp, ror #3
+  fc:	eb510001 	bl	1440108 <clock_init+0x143fd18>
+ 100:	ec000001 	stc	0, cr0, [r0], {1}
+ 104:	01000001 	tsteq	r0, r1
+ 108:	01ec5400 	mvneq	r5, r0, lsl #8
+ 10c:	02ac0000 	adceq	r0, ip, #0
+ 110:	00010000 	andeq	r0, r1, r0
+ 114:	0002ac56 	andeq	sl, r2, r6, asr ip
+ 118:	0002b400 	andeq	fp, r2, r0, lsl #8
+ 11c:	f3000400 	vshl.u8	d0, d0, d0
+ 120:	009f5101 	addseq	r5, pc, r1, lsl #2
+ 124:	00000000 	andeq	r0, r0, r0
+ 128:	b0000000 	andlt	r0, r0, r0
+ 12c:	eb000001 	bl	138 <.debug_loc+0x138>
+ 130:	01000001 	tsteq	r0, r1
+ 134:	01eb5200 	mvneq	r5, r0, lsl #4
+ 138:	02ac0000 	adceq	r0, ip, #0
+ 13c:	00010000 	andeq	r0, r1, r0
+ 140:	0002ac57 	andeq	sl, r2, r7, asr ip
+ 144:	0002b400 	andeq	fp, r2, r0, lsl #8
+ 148:	f3000400 	vshl.u8	d0, d0, d0
+ 14c:	009f5201 	addseq	r5, pc, r1, lsl #4
+ 150:	00000000 	andeq	r0, r0, r0
+ 154:	ec000000 	stc	0, cr0, [r0], {-0}
+ 158:	78000001 	stmdavc	r0, {r0}
+ 15c:	01000002 	tsteq	r0, r2
+ 160:	02a85400 	adceq	r5, r8, #0, 8
+ 164:	02ac0000 	adceq	r0, ip, #0
+ 168:	00010000 	andeq	r0, r1, r0
+ 16c:	00000054 	andeq	r0, r0, r4, asr r0
+ 170:	00000000 	andeq	r0, r0, r0
+ 174:	00026c00 	andeq	r6, r2, r0, lsl #24
+ 178:	0002a800 	andeq	sl, r2, r0, lsl #16
+ 17c:	30000200 	andcc	r0, r0, r0, lsl #4
+ 180:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
+ 184:	00000000 	andeq	r0, r0, r0
+ 188:	00020000 	andeq	r0, r2, r0
+ 18c:	0002a400 	andeq	sl, r2, r0, lsl #8
+ 190:	54000100 	strpl	r0, [r0], #-256	; 0x100
+ 194:	000002a4 	andeq	r0, r0, r4, lsr #5
+ 198:	000002a8 	andeq	r0, r0, r8, lsr #5
+ 19c:	80740004 	rsbshi	r0, r4, r4
+ 1a0:	00009f7c 	andeq	r9, r0, ip, ror pc
+ 1a4:	00000000 	andeq	r0, r0, r0
+ 1a8:	022c0000 	eoreq	r0, ip, #0
+ 1ac:	024c0000 	subeq	r0, ip, #0
+ 1b0:	00010000 	andeq	r0, r1, r0
+ 1b4:	00000054 	andeq	r0, r0, r4, asr r0
+ 1b8:	00000000 	andeq	r0, r0, r0
+ 1bc:	00023c00 	andeq	r3, r2, r0, lsl #24
+ 1c0:	00024c00 	andeq	r4, r2, r0, lsl #24
+ 1c4:	30000200 	andcc	r0, r0, r0, lsl #4
+ 1c8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
+ 1cc:	00000000 	andeq	r0, r0, r0
+ 1d0:	00022c00 	andeq	r2, r2, r0, lsl #24
+ 1d4:	00024c00 	andeq	r4, r2, r0, lsl #24
+ 1d8:	08000500 	stmdaeq	r0, {r8, sl}
+ 1dc:	9f24479c 	svcls	0x0024479c
+	...
+ 1e8:	0000022c 	andeq	r0, r0, ip, lsr #4
+ 1ec:	0000024c 	andeq	r0, r0, ip, asr #4
+ 1f0:	080c0006 	stmdaeq	ip, {r1, r2}
+ 1f4:	9f4e0000 	svcls	0x004e0000
+	...
+ 200:	0000024c 	andeq	r0, r0, ip, asr #4
+ 204:	00000268 	andeq	r0, r0, r8, ror #4
+ 208:	00540001 	subseq	r0, r4, r1
+ 20c:	00000000 	andeq	r0, r0, r0
+ 210:	5c000000 	stcpl	0, cr0, [r0], {-0}
+ 214:	68000002 	stmdavs	r0, {r1}
+ 218:	02000002 	andeq	r0, r0, #2
+ 21c:	009f3000 	addseq	r3, pc, r0
+ 220:	00000000 	andeq	r0, r0, r0
+ 224:	4c000000 	stcmi	0, cr0, [r0], {-0}
+ 228:	68000002 	stmdavs	r0, {r1}
+ 22c:	05000002 	streq	r0, [r0, #-2]
+ 230:	479c0800 	ldrmi	r0, [ip, r0, lsl #16]
+ 234:	00009f24 	andeq	r9, r0, r4, lsr #30
+ 238:	00000000 	andeq	r0, r0, r0
+ 23c:	024c0000 	subeq	r0, ip, #0
+ 240:	02680000 	rsbeq	r0, r8, #0
+ 244:	00060000 	andeq	r0, r6, r0
+ 248:	00000c0c 	andeq	r0, r0, ip, lsl #24
+ 24c:	00009f4e 	andeq	r9, r0, lr, asr #30
+ 250:	00000000 	andeq	r0, r0, r0
+ 254:	02880000 	addeq	r0, r8, #0
+ 258:	02a80000 	adceq	r0, r8, #0
+ 25c:	00050000 	andeq	r0, r5, r0
+ 260:	24479c08 	strbcs	r9, [r7], #-3080	; 0xc08
+ 264:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
+ 268:	00000000 	andeq	r0, r0, r0
+ 26c:	00028800 	andeq	r8, r2, r0, lsl #16
+ 270:	0002a800 	andeq	sl, r2, r0, lsl #16
+ 274:	0c000600 	stceq	6, cr0, [r0], {-0}
+ 278:	4e00000c 	cdpmi	0, 0, cr0, cr0, cr12, {0}
+ 27c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
+ 280:	00000000 	andeq	r0, r0, r0
+ 284:	00028c00 	andeq	r8, r2, r0, lsl #24
+ 288:	0002a800 	andeq	sl, r2, r0, lsl #16
+ 28c:	08000500 	stmdaeq	r0, {r8, sl}
+ 290:	9f24479c 	svcls	0x0024479c
+	...
+ 29c:	0000028c 	andeq	r0, r0, ip, lsl #5
+ 2a0:	000002a8 	andeq	r0, r0, r8, lsr #5
+ 2a4:	100c0006 	andne	r0, ip, r6
+ 2a8:	9f4e0000 	svcls	0x004e0000
+	...
+ 2b4:	000002b4 			; <UNDEFINED> instruction: 0x000002b4
+ 2b8:	000002ef 	andeq	r0, r0, pc, ror #5
+ 2bc:	ef500001 	svc	0x00500001
+ 2c0:	f0000002 			; <UNDEFINED> instruction: 0xf0000002
+ 2c4:	01000002 	tsteq	r0, r2
+ 2c8:	02f05500 	rscseq	r5, r0, #0, 10
+ 2cc:	03dc0000 	bicseq	r0, ip, #0
+ 2d0:	00040000 	andeq	r0, r4, r0
+ 2d4:	9f5001f3 	svcls	0x005001f3
+	...
+ 2e0:	000002b4 			; <UNDEFINED> instruction: 0x000002b4
+ 2e4:	000002ef 	andeq	r0, r0, pc, ror #5
+ 2e8:	ef510001 	svc	0x00510001
+ 2ec:	f0000002 			; <UNDEFINED> instruction: 0xf0000002
+ 2f0:	01000002 	tsteq	r0, r2
+ 2f4:	02f05400 	rscseq	r5, r0, #0, 8
+ 2f8:	03d40000 	bicseq	r0, r4, #0
+ 2fc:	00010000 	andeq	r0, r1, r0
+ 300:	0003d456 	andeq	sp, r3, r6, asr r4
+ 304:	0003dc00 	andeq	sp, r3, r0, lsl #24
+ 308:	f3000400 	vshl.u8	d0, d0, d0
+ 30c:	009f5101 	addseq	r5, pc, r1, lsl #2
+ 310:	00000000 	andeq	r0, r0, r0
+ 314:	b4000000 	strlt	r0, [r0], #-0
+ 318:	ef000002 	svc	0x00000002
+ 31c:	01000002 	tsteq	r0, r2
+ 320:	02ef5200 	rsceq	r5, pc, #0, 4
+ 324:	03d40000 	bicseq	r0, r4, #0
+ 328:	00010000 	andeq	r0, r1, r0
+ 32c:	0003d457 	andeq	sp, r3, r7, asr r4
+ 330:	0003dc00 	andeq	sp, r3, r0, lsl #24
+ 334:	f3000400 	vshl.u8	d0, d0, d0
+ 338:	009f5201 	addseq	r5, pc, r1, lsl #4
+ 33c:	00000000 	andeq	r0, r0, r0
+ 340:	ec000000 	stc	0, cr0, [r0], {-0}
+ 344:	ef000002 	svc	0x00000002
+ 348:	01000002 	tsteq	r0, r2
+ 34c:	02ef5200 	rsceq	r5, pc, #0, 4
+ 350:	03d40000 	bicseq	r0, r4, #0
+ 354:	00010000 	andeq	r0, r1, r0
+ 358:	0003d457 	andeq	sp, r3, r7, asr r4
+ 35c:	0003dc00 	andeq	sp, r3, r0, lsl #24
+ 360:	f3000400 	vshl.u8	d0, d0, d0
+ 364:	009f5201 	addseq	r5, pc, r1, lsl #4
+ 368:	00000000 	andeq	r0, r0, r0
+ 36c:	ec000000 	stc	0, cr0, [r0], {-0}
+ 370:	ef000002 	svc	0x00000002
+ 374:	01000002 	tsteq	r0, r2
+ 378:	02ef5100 	rsceq	r5, pc, #0, 2
+ 37c:	02f00000 	rscseq	r0, r0, #0
+ 380:	00010000 	andeq	r0, r1, r0
+ 384:	0002f054 	andeq	pc, r2, r4, asr r0	; <UNPREDICTABLE>
+ 388:	0003d400 	andeq	sp, r3, r0, lsl #8
+ 38c:	56000100 	strpl	r0, [r0], -r0, lsl #2
+ 390:	000003d4 			; <UNDEFINED> instruction: 0x000003d4
+ 394:	000003dc 			; <UNDEFINED> instruction: 0x000003dc
+ 398:	01f30004 	mvnseq	r0, r4
+ 39c:	00009f51 	andeq	r9, r0, r1, asr pc
+ 3a0:	00000000 	andeq	r0, r0, r0
+ 3a4:	02ec0000 	rsceq	r0, ip, #0
+ 3a8:	02ef0000 	rsceq	r0, pc, #0
+ 3ac:	00010000 	andeq	r0, r1, r0
+ 3b0:	0002ef50 	andeq	lr, r2, r0, asr pc
+ 3b4:	0003d400 	andeq	sp, r3, r0, lsl #8
+ 3b8:	55000100 	strpl	r0, [r0, #-256]	; 0x100
+	...
+ 3c4:	000002f0 			; <UNDEFINED> instruction: 0x000002f0
+ 3c8:	000003a0 	andeq	r0, r0, r0, lsr #7
+ 3cc:	d0540001 	subsle	r0, r4, r1
+ 3d0:	d4000003 	strle	r0, [r0], #-3
+ 3d4:	01000003 	tsteq	r0, r3
+ 3d8:	00005400 	andeq	r5, r0, r0, lsl #8
+ 3dc:	00000000 	andeq	r0, r0, r0
+ 3e0:	03940000 	orrseq	r0, r4, #0
+ 3e4:	03d00000 	bicseq	r0, r0, #0
+ 3e8:	00020000 	andeq	r0, r2, r0
+ 3ec:	00009f30 	andeq	r9, r0, r0, lsr pc
+ 3f0:	00000000 	andeq	r0, r0, r0
+ 3f4:	03040000 	tsteq	r4, #0
+ 3f8:	03cc0000 	biceq	r0, ip, #0
+ 3fc:	00010000 	andeq	r0, r1, r0
+ 400:	0003cc54 	andeq	ip, r3, r4, asr ip
+ 404:	0003d000 	andeq	sp, r3, r0
+ 408:	74000400 	strvc	r0, [r0], #-1024	; 0x400
+ 40c:	009f7080 	addseq	r7, pc, r0, lsl #1
+ 410:	00000000 	andeq	r0, r0, r0
+ 414:	20000000 	andcs	r0, r0, r0
+ 418:	4c000003 	stcmi	0, cr0, [r0], {3}
+ 41c:	01000003 	tsteq	r0, r3
+ 420:	00005400 	andeq	r5, r0, r0, lsl #8
+ 424:	00000000 	andeq	r0, r0, r0
+ 428:	032c0000 	teqeq	ip, #0
+ 42c:	034c0000 	cmpeq	ip, #0
+ 430:	00020000 	andeq	r0, r2, r0
+ 434:	00009f30 	andeq	r9, r0, r0, lsr pc
+ 438:	00000000 	andeq	r0, r0, r0
+ 43c:	03200000 	teqeq	r0, #0
+ 440:	034c0000 	cmpeq	ip, #0
+ 444:	00050000 	andeq	r0, r5, r0
+ 448:	24479c08 	strbcs	r9, [r7], #-3080	; 0xc08
+ 44c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
+ 450:	00000000 	andeq	r0, r0, r0
+ 454:	00032000 	andeq	r2, r3, r0
+ 458:	00034c00 	andeq	r4, r3, r0, lsl #24
+ 45c:	0c000600 	stceq	6, cr0, [r0], {-0}
+ 460:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
+ 464:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
+ 468:	00000000 	andeq	r0, r0, r0
+ 46c:	00034c00 	andeq	r4, r3, r0, lsl #24
+ 470:	00038800 	andeq	r8, r3, r0, lsl #16
+ 474:	54000100 	strpl	r0, [r0], #-256	; 0x100
+	...
+ 480:	00000360 	andeq	r0, r0, r0, ror #6
+ 484:	00000388 	andeq	r0, r0, r8, lsl #7
+ 488:	9f300002 	svcls	0x00300002
+	...
+ 494:	0000034c 	andeq	r0, r0, ip, asr #6
+ 498:	00000388 	andeq	r0, r0, r8, lsl #7
+ 49c:	9c080005 	stcls	0, cr0, [r8], {5}
+ 4a0:	009f2447 	addseq	r2, pc, r7, asr #8
+ 4a4:	00000000 	andeq	r0, r0, r0
+ 4a8:	4c000000 	stcmi	0, cr0, [r0], {-0}
+ 4ac:	88000003 	stmdahi	r0, {r0, r1}
+ 4b0:	06000003 	streq	r0, [r0], -r3
+ 4b4:	000c0c00 	andeq	r0, ip, r0, lsl #24
+ 4b8:	009f4e00 	addseq	r4, pc, r0, lsl #28
+ 4bc:	00000000 	andeq	r0, r0, r0
+ 4c0:	58000000 	stmdapl	r0, {}	; <UNPREDICTABLE>
+ 4c4:	64000003 	strvs	r0, [r0], #-3
+ 4c8:	01000003 	tsteq	r0, r3
+ 4cc:	03645100 	cmneq	r4, #0, 2
+ 4d0:	03880000 	orreq	r0, r8, #0
+ 4d4:	00070000 	andeq	r0, r7, r0
+ 4d8:	24450074 	strbcs	r0, [r5], #-116	; 0x74
+ 4dc:	009f2545 	addseq	r2, pc, r5, asr #10
+ 4e0:	00000000 	andeq	r0, r0, r0
+ 4e4:	b0000000 	andlt	r0, r0, r0
+ 4e8:	d0000003 	andle	r0, r0, r3
+ 4ec:	05000003 	streq	r0, [r0, #-3]
+ 4f0:	479c0800 	ldrmi	r0, [ip, r0, lsl #16]
+ 4f4:	00009f24 	andeq	r9, r0, r4, lsr #30
+ 4f8:	00000000 	andeq	r0, r0, r0
+ 4fc:	03b00000 	movseq	r0, #0
+ 500:	03d00000 	bicseq	r0, r0, #0
+ 504:	00060000 	andeq	r0, r6, r0
+ 508:	00000c0c 	andeq	r0, r0, ip, lsl #24
+ 50c:	00009f4e 	andeq	r9, r0, lr, asr #30
+ 510:	00000000 	andeq	r0, r0, r0
+ 514:	03b40000 			; <UNDEFINED> instruction: 0x03b40000
+ 518:	03d00000 	bicseq	r0, r0, #0
+ 51c:	00050000 	andeq	r0, r5, r0
+ 520:	24479c08 	strbcs	r9, [r7], #-3080	; 0xc08
+ 524:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
+ 528:	00000000 	andeq	r0, r0, r0
+ 52c:	0003b400 	andeq	fp, r3, r0, lsl #8
+ 530:	0003d000 	andeq	sp, r3, r0
+ 534:	0c000600 	stceq	6, cr0, [r0], {-0}
+ 538:	4e000010 	mcrmi	0, 0, r0, cr0, cr0, {0}
+ 53c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
+ 540:	00000000 	andeq	r0, r0, r0
+ 544:	0003e800 	andeq	lr, r3, r0, lsl #16
+ 548:	0003ef00 	andeq	lr, r3, r0, lsl #30
+ 54c:	50000100 	andpl	r0, r0, r0, lsl #2
+ 550:	000003ef 	andeq	r0, r0, pc, ror #7
+ 554:	000003f0 			; <UNDEFINED> instruction: 0x000003f0
+ 558:	01f30004 	mvnseq	r0, r4
+ 55c:	00009f50 	andeq	r9, r0, r0, asr pc
+ 560:	00000000 	andeq	r0, r0, r0
+ 564:	03e80000 	mvneq	r0, #0
+ 568:	03ef0000 	mvneq	r0, #0
+ 56c:	00010000 	andeq	r0, r1, r0
+ 570:	0003ef51 	andeq	lr, r3, r1, asr pc
+ 574:	0003f000 	andeq	pc, r3, r0
+ 578:	f3000400 	vshl.u8	d0, d0, d0
+ 57c:	009f5101 	addseq	r5, pc, r1, lsl #2
+ 580:	00000000 	andeq	r0, r0, r0
+ 584:	e8000000 	stmda	r0, {}	; <UNPREDICTABLE>
+ 588:	ef000003 	svc	0x00000003
+ 58c:	01000003 	tsteq	r0, r3
+ 590:	03ef5200 	mvneq	r5, #0, 4
+ 594:	03f00000 	mvnseq	r0, #0
+ 598:	00040000 	andeq	r0, r4, r0
+ 59c:	9f5201f3 	svcls	0x005201f3
+	...
+ 5a8:	00000434 	andeq	r0, r0, r4, lsr r4
+ 5ac:	00000440 	andeq	r0, r0, r0, asr #8
+ 5b0:	a00a0004 	andge	r0, sl, r4
+ 5b4:	00009f0f 	andeq	r9, r0, pc, lsl #30
+ 5b8:	00000000 	andeq	r0, r0, r0
+ 5bc:	046c0000 	strbteq	r0, [ip], #-0
+ 5c0:	04780000 	ldrbteq	r0, [r8], #-0
+ 5c4:	00040000 	andeq	r0, r4, r0
+ 5c8:	9f0fa00a 	svcls	0x000fa00a
+	...
+ 5d4:	00000480 	andeq	r0, r0, r0, lsl #9
+ 5d8:	0000048c 	andeq	r0, r0, ip, lsl #9
+ 5dc:	400a0004 	andmi	r0, sl, r4
+ 5e0:	00009f1f 	andeq	r9, r0, pc, lsl pc
+ 5e4:	00000000 	andeq	r0, r0, r0
+	...
+
+Disassembly of section .debug_aranges:
+
+00000000 <.debug_aranges>:
+   0:	0000001c 	andeq	r0, r0, ip, lsl r0
+   4:	00000002 	andeq	r0, r0, r2
+   8:	00040000 	andeq	r0, r4, r0
+	...
+  14:	000004a4 	andeq	r0, r0, r4, lsr #9
+	...
+
+Disassembly of section .debug_ranges:
+
+00000000 <.debug_ranges>:
+   0:	0000004c 	andeq	r0, r0, ip, asr #32
+   4:	00000050 	andeq	r0, r0, r0, asr r0
+   8:	00000054 	andeq	r0, r0, r4, asr r0
+   c:	00000058 	andeq	r0, r0, r8, asr r0
+  10:	0000005c 	andeq	r0, r0, ip, asr r0
+  14:	00000060 	andeq	r0, r0, r0, rrx
+	...
+  20:	00000050 	andeq	r0, r0, r0, asr r0
+  24:	00000054 	andeq	r0, r0, r4, asr r0
+  28:	00000058 	andeq	r0, r0, r8, asr r0
+  2c:	0000005c 	andeq	r0, r0, ip, asr r0
+  30:	00000060 	andeq	r0, r0, r0, rrx
+  34:	0000006c 	andeq	r0, r0, ip, rrx
+	...
+  40:	00000088 	andeq	r0, r0, r8, lsl #1
+  44:	0000008c 	andeq	r0, r0, ip, lsl #1
+  48:	00000090 	muleq	r0, r0, r0
+  4c:	00000094 	muleq	r0, r4, r0
+  50:	00000098 	muleq	r0, r8, r0
+  54:	0000009c 	muleq	r0, ip, r0
+	...
+  60:	0000008c 	andeq	r0, r0, ip, lsl #1
+  64:	00000090 	muleq	r0, r0, r0
+  68:	00000094 	muleq	r0, r4, r0
+  6c:	00000098 	muleq	r0, r8, r0
+  70:	0000009c 	muleq	r0, ip, r0
+  74:	000000a8 	andeq	r0, r0, r8, lsr #1
+	...
+  80:	000000c0 	andeq	r0, r0, r0, asr #1
+  84:	000000c4 	andeq	r0, r0, r4, asr #1
+  88:	000000c8 	andeq	r0, r0, r8, asr #1
+  8c:	000000d8 			; <UNDEFINED> instruction: 0x000000d8
+	...
+  98:	000001dc 			; <UNDEFINED> instruction: 0x000001dc
+  9c:	000001e0 	andeq	r0, r0, r0, ror #3
+  a0:	00000200 	andeq	r0, r0, r0, lsl #4
+  a4:	00000268 	andeq	r0, r0, r8, ror #4
+	...
+  b0:	000002e0 	andeq	r0, r0, r0, ror #5
+  b4:	000003d0 			; <UNDEFINED> instruction: 0x000003d0
+  b8:	000003d4 			; <UNDEFINED> instruction: 0x000003d4
+  bc:	000003dc 			; <UNDEFINED> instruction: 0x000003dc
+	...
+  c8:	000002e0 	andeq	r0, r0, r0, ror #5
+  cc:	000002e4 	andeq	r0, r0, r4, ror #5
+  d0:	00000304 	andeq	r0, r0, r4, lsl #6
+  d4:	00000388 	andeq	r0, r0, r8, lsl #7
+	...
+
+Disassembly of section .debug_line:
+
+00000000 <.debug_line>:
+   0:	000001e2 	andeq	r0, r0, r2, ror #3
+   4:	00820002 	addeq	r0, r2, r2
+   8:	01020000 	mrseq	r0, (UNDEF: 2)
+   c:	000d0efb 			; <UNDEFINED> instruction: 0x000d0efb
+  10:	01010101 	tsteq	r1, r1, lsl #2
+  14:	01000000 	mrseq	r0, (UNDEF: 0)
+  18:	2f010000 	svccs	0x00010000
+  1c:	6b726f77 	blvs	1c9be00 <clock_init+0x1c9ba10>
+  20:	7379732f 	cmnvc	r9, #-1140850688	; 0xbc000000
+  24:	2f6d6574 	svccs	0x006d6574
+  28:	6f622d75 	svcvs	0x00622d75
+  2c:	312d746f 	teqcc	sp, pc, ror #8
+  30:	362e312e 	strtcc	r3, [lr], -lr, lsr #2
+  34:	636e692f 	cmnvs	lr, #770048	; 0xbc000
+  38:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
+  3c:	6f772f00 	svcvs	0x00772f00
+  40:	732f6b72 	teqvc	pc, #116736	; 0x1c800
+  44:	65747379 	ldrbvs	r7, [r4, #-889]!	; 0x379
+  48:	2d752f6d 	ldclcs	15, cr2, [r5, #-436]!	; 0xfffffe4c
+  4c:	746f6f62 	strbtvc	r6, [pc], #-3938	; 54 <.debug_line+0x54>
+  50:	312e312d 	teqcc	lr, sp, lsr #2
+  54:	692f362e 	stmdbvs	pc!, {r1, r2, r3, r5, r9, sl, ip, sp}	; <UNPREDICTABLE>
+  58:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
+  5c:	612f6564 	teqvs	pc, r4, ror #10
+  60:	00006d73 	andeq	r6, r0, r3, ror sp
+  64:	746f6f62 	strbtvc	r6, [pc], #-3938	; 6c <.debug_line+0x6c>
+  68:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
+  6c:	00632e74 	rsbeq	r2, r3, r4, ror lr
+  70:	73000000 	tstvc	r0, #0
+  74:	34326333 	ldrtcc	r6, [r2], #-819	; 0x333
+  78:	682e3078 	stmdavs	lr!, {r3, r4, r5, r6, ip, sp}
+  7c:	00000100 	andeq	r0, r0, r0, lsl #2
+  80:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0x974
+  84:	00682e73 	rsbeq	r2, r8, r3, ror lr
+  88:	00000002 	andeq	r0, r0, r2
+  8c:	00020500 	andeq	r0, r2, r0, lsl #10
+  90:	03000000 	tsteq	r0, #0
+  94:	14010292 	strne	r0, [r1], #-658	; 0x292
+  98:	f27ec403 	vshl.s64	d28, d3, d14
+  9c:	2e00cb03 	cdpcs	11, 0, cr12, cr0, cr3, {0}
+  a0:	6600d103 	strvs	sp, [r0], -r3, lsl #2
+  a4:	7ece0316 	mcrvc	3, 6, r0, cr14, cr6, {0}
+  a8:	00cb03d6 			; <UNDEFINED> instruction: 0x00cb03d6
+  ac:	7fb5032e 	svcvc	0x00b5032e
+  b0:	00cb032e 	sbceq	r0, fp, lr, lsr #6
+  b4:	7fb5032e 	svcvc	0x00b5032e
+  b8:	00cb032e 	sbceq	r0, fp, lr, lsr #6
+  bc:	00f4032e 	rscseq	r0, r4, lr, lsr #6
+  c0:	c8031466 	stmdagt	r3, {r1, r2, r5, r6, sl, ip}
+  c4:	cb03d67e 	blgt	f5ac4 <clock_init+0xf56d4>
+  c8:	b5032e00 	strlt	r2, [r3, #-3584]	; 0xe00
+  cc:	cb032e7f 	blgt	cbad0 <clock_init+0xcb6e0>
+  d0:	b5032e00 	strlt	r2, [r3, #-3584]	; 0xe00
+  d4:	cb032e7f 	blgt	cbad8 <clock_init+0xcb6e8>
+  d8:	cd032e00 	stcgt	14, cr2, [r3, #-0]
+  dc:	03146600 	tsteq	r4, #0, 12
+  e0:	03ba7ed3 			; <UNDEFINED> instruction: 0x03ba7ed3
+  e4:	032e01ad 	teqeq	lr, #1073741867	; 0x4000002b
+  e8:	032e7ed3 	teqeq	lr, #3376	; 0xd30
+  ec:	038200cb 	orreq	r0, r2, #203	; 0xcb
+  f0:	039e01bf 	orrseq	r0, lr, #-1073741777	; 0xc000002f
+  f4:	33d90109 	bicscc	r0, r9, #1073741826	; 0x40000002
+  f8:	4a79034c 	bmi	1e40e30 <clock_init+0x1e40a40>
+  fc:	2e7f8a03 	cdpcs	10, 7, cr8, cr15, cr3, {0}
+ 100:	f27eea03 	vpmax.s<illegal width 64>	d30, d14, d3
+ 104:	03661203 	cmneq	r6, #805306368	; 0x30000000
+ 108:	13034a64 	tstne	r3, #100, 20	; 0x64000
+ 10c:	00c20382 	sbceq	r0, r2, r2, lsl #7
+ 110:	66120382 	ldrvs	r0, [r2], -r2, lsl #7
+ 114:	034a6403 	cmpeq	sl, #50331648	; 0x3000000
+ 118:	c9038213 	stmdbgt	r3, {r0, r1, r4, r9, pc}
+ 11c:	2b15ba01 	blcs	56e928 <clock_init+0x56e538>
+ 120:	0200312e 	andeq	r3, r0, #-2147483637	; 0x8000000b
+ 124:	66060104 	strvs	r0, [r6], -r4, lsl #2
+ 128:	7fba0306 	svcvc	0x00ba0306
+ 12c:	00cd039e 	smulleq	r0, sp, lr, r3
+ 130:	0200482e 	andeq	r4, r0, #3014656	; 0x2e0000
+ 134:	68300104 	ldmdavs	r0!, {r2, r8}
+ 138:	4a7fb103 	bmi	1fec54c <clock_init+0x1fec15c>
+ 13c:	087ec403 	ldmdaeq	lr!, {r0, r1, sl, lr, pc}^
+ 140:	03303058 	teqeq	r0, #88	; 0x58
+ 144:	30302e7a 	eorscc	r2, r0, sl, ror lr
+ 148:	00c70330 	sbceq	r0, r7, r0, lsr r3
+ 14c:	0330304a 	teqeq	r0, #74	; 0x4a
+ 150:	30302e7a 	eorscc	r2, r0, sl, ror lr
+ 154:	01c00330 	biceq	r0, r0, r0, lsr r3
+ 158:	4a47032e 	bmi	11c0e18 <clock_init+0x11c0a28>
+ 15c:	ba7eb803 	blt	1fae170 <clock_init+0x1fadd80>
+ 160:	2e00e203 	cdpcs	2, 0, cr14, cr0, cr3, {0}
+ 164:	4a01a203 	bmi	68978 <clock_init+0x68588>
+ 168:	820a032d 	andhi	r0, sl, #-1275068416	; 0xb4000000
+ 16c:	4a0a032b 	bmi	280e20 <clock_init+0x280a30>
+ 170:	312e2b15 	teqcc	lr, r5, lsl fp
+ 174:	01040200 	mrseq	r0, R12_usr
+ 178:	03066606 	tsteq	r6, #6291456	; 0x600000
+ 17c:	039e7fa4 	orrseq	r7, lr, #164, 30	; 0x290
+ 180:	482e00e3 	stmdami	lr!, {r0, r1, r5, r6, r7}
+ 184:	9b036830 	blls	da24c <clock_init+0xd9e5c>
+ 188:	b7034a7f 			; <UNDEFINED> instruction: 0xb7034a7f
+ 18c:	4c2cd67e 	stcmi	6, cr13, [ip], #-504	; 0xfffffe08
+ 190:	d803684c 	stmdale	r3, {r2, r3, r6, fp, sp, lr}
+ 194:	2d2f6600 	stccs	6, cr6, [pc, #-0]	; 19c <.debug_line+0x19c>
+ 198:	4c4c4c31 	stclmi	12, cr4, [ip], {49}	; 0x31
+ 19c:	2c302c30 	ldccs	12, cr2, [r0], #-192	; 0xffffff40
+ 1a0:	01cb0330 	biceq	r0, fp, r0, lsr r3
+ 1a4:	a3034b2e 	tstge	r3, #47104	; 0xb800
+ 1a8:	b8034a7f 	stmdalt	r3, {r0, r1, r2, r3, r4, r5, r6, r9, fp, lr}
+ 1ac:	e203ba7e 	and	fp, r3, #516096	; 0x7e000
+ 1b0:	c6032e00 	strgt	r2, [r3], -r0, lsl #28
+ 1b4:	032d4a01 	teqeq	sp, #4096	; 0x1000
+ 1b8:	502b820a 	eorpl	r8, fp, sl, lsl #4
+ 1bc:	03010e03 	tsteq	r1, #3, 28	; 0x30
+ 1c0:	0333660e 	teqeq	r3, #14680064	; 0xe00000
+ 1c4:	f5162e33 			; <UNDEFINED> instruction: 0xf5162e33
+ 1c8:	034d6d4d 	cmpeq	sp, #4928	; 0x1340
+ 1cc:	36034a50 			; <UNDEFINED> instruction: 0x36034a50
+ 1d0:	6d4d5266 	sfmvs	f5, 2, [sp, #-408]	; 0xfffffe68
+ 1d4:	7fb5034d 	svcvc	0x00b5034d
+ 1d8:	00d1034a 	sbcseq	r0, r1, sl, asr #6
+ 1dc:	7faf0366 	svcvc	0x00af0366
+ 1e0:	0012024a 	andseq	r0, r2, sl, asr #4
+ 1e4:	Address 0x00000000000001e4 is out of bounds.
+
+
+Disassembly of section .debug_str:
+
+00000000 <.debug_str>:
+   0:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
+   4:	64615f74 	strbtvs	r5, [r1], #-3956	; 0xf74
+   8:	61007264 	tstvs	r0, r4, ror #4
+   c:	00726464 	rsbseq	r6, r2, r4, ror #8
+  10:	32633373 	rsbcc	r3, r3, #-872415231	; 0xcc000001
+  14:	5f303434 	svcpl	0x00303434
+  18:	64616572 	strbtvs	r6, [r1], #-1394	; 0x572
+  1c:	7461645f 	strbtvc	r6, [r1], #-1119	; 0x45f
+  20:	33730061 	cmncc	r3, #97	; 0x61
+  24:	34343263 	ldrtcc	r3, [r4], #-611	; 0x263
+  28:	616e5f30 	cmnvs	lr, r0, lsr pc
+  2c:	725f646e 	subsvc	r6, pc, #1845493760	; 0x6e000000
+  30:	74657365 	strbtvc	r7, [r5], #-869	; 0x365
+  34:	4d464e00 	stclmi	14, cr4, [r6, #-0]
+  38:	44434345 	strbmi	r4, [r3], #-837	; 0x345
+  3c:	464e0030 			; <UNDEFINED> instruction: 0x464e0030
+  40:	4343454d 	cmpmi	r3, #322961408	; 0x13400000
+  44:	73003144 	tstvc	r0, #68, 2
+  48:	74726f68 	ldrbtvc	r6, [r2], #-3944	; 0xf68
+  4c:	746e6920 	strbtvc	r6, [lr], #-2336	; 0x920
+  50:	6e616e00 	cdpvs	14, 6, cr6, cr1, cr0, {0}
+  54:	6e695f64 	cdpvs	15, 6, cr5, cr9, cr4, {3}
+  58:	6c5f7469 	ldclvs	4, cr7, [pc], {105}	; 0x69
+  5c:	4262006c 	rsbmi	r0, r2, #108	; 0x6c
+  60:	46746f6f 	ldrbtmi	r6, [r4], -pc, ror #30
+  64:	4f4e6d72 	svcmi	0x004e6d72
+  68:	616c4652 	cmnvs	ip, r2, asr r6
+  6c:	73006873 	tstvc	r0, #7536640	; 0x730000
+  70:	34326333 	ldrtcc	r6, [r2], #-819	; 0x333
+  74:	775f3034 			; <UNDEFINED> instruction: 0x775f3034
+  78:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0x972
+  7c:	646d635f 	strbtvs	r6, [sp], #-863	; 0x35f
+  80:	434f4c00 	cmpmi	pc, #0, 24
+  84:	4d49544b 	stclmi	4, cr5, [r9, #-300]	; 0xfffffed4
+  88:	464e0045 	strbmi	r0, [lr], -r5, asr #32
+  8c:	464e4f43 	strbmi	r4, [lr], -r3, asr #30
+  90:	6c656400 	stclvs	4, cr6, [r5], #-0
+  94:	73007961 	tstvc	r0, #1589248	; 0x184000
+  98:	34326333 	ldrtcc	r6, [r2], #-819	; 0x333
+  9c:	775f3031 			; <UNDEFINED> instruction: 0x775f3031
+  a0:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0x972
+  a4:	6464615f 	strbtvs	r6, [r4], #-351	; 0x15f
+  a8:	33730072 	cmncc	r3, #114	; 0x72
+  ac:	31343263 	teqcc	r4, r3, ror #4
+  b0:	616e5f30 	cmnvs	lr, r0, lsr pc
+  b4:	645f646e 	ldrbvs	r6, [pc], #-1134	; bc <.debug_str+0xbc>
+  b8:	6c657365 	stclvs	3, cr7, [r5], #-404	; 0xfffffe6c
+  bc:	5f746365 	svcpl	0x00746365
+  c0:	70696863 	rsbvc	r6, r9, r3, ror #16
+  c4:	6f6f6c00 	svcvs	0x006f6c00
+  c8:	6e007370 	mcrvs	3, 0, r7, cr0, cr0, {3}
+  cc:	5f646e61 	svcpl	0x00646e61
+  d0:	65736564 	ldrbvs	r6, [r3, #-1380]!	; 0x564
+  d4:	7463656c 	strbtvc	r6, [r3], #-1388	; 0x56c
+  d8:	6968635f 	stmdbvs	r8!, {r0, r1, r2, r3, r4, r6, r8, r9, sp, lr}^
+  dc:	464e0070 			; <UNDEFINED> instruction: 0x464e0070
+  e0:	544e4f43 	strbpl	r4, [lr], #-3907	; 0xf43
+  e4:	61657200 	cmnvs	r5, r0, lsl #4
+  e8:	61645f64 	cmnvs	r4, r4, ror #30
+  ec:	4d006174 	stfmis	f6, [r0, #-464]	; 0xfffffe30
+  f0:	434c4c50 	cmpmi	ip, #80, 24	; 0x5000
+  f4:	53004e4f 	tstpl	r0, #1264	; 0x4f0
+  f8:	34324333 	ldrtcc	r4, [r2], #-819	; 0x333
+  fc:	4e5f3034 	mrcmi	0, 2, r3, cr15, cr4, {1}
+ 100:	00444e41 	subeq	r4, r4, r1, asr #28
+ 104:	4441464e 	strbmi	r4, [r1], #-1614	; 0x64e
+ 108:	73005244 	tstvc	r0, #68, 4	; 0x40000004
+ 10c:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0x769
+ 110:	68632064 	stmdavs	r3!, {r2, r5, r6, sp}^
+ 114:	43007261 	tstmi	r0, #268435462	; 0x10000006
+ 118:	4c534b4c 	ldclmi	11, cr4, [r3], {76}	; 0x4c
+ 11c:	4e00574f 	cdpmi	7, 0, cr5, cr0, cr15, {2}
+ 120:	41545346 	cmpmi	r4, r6, asr #6
+ 124:	77640054 			; <UNDEFINED> instruction: 0x77640054
+ 128:	006c6156 	rsbeq	r6, ip, r6, asr r1
+ 12c:	74697277 	strbtvc	r7, [r9], #-631	; 0x277
+ 130:	6d635f65 	stclvs	15, cr5, [r3, #-404]!	; 0xfffffe6c
+ 134:	33730064 	cmncc	r3, #100	; 0x64
+ 138:	34343263 	ldrtcc	r3, [r4], #-611	; 0x263
+ 13c:	616e5f30 	cmnvs	lr, r0, lsr pc
+ 140:	735f646e 	cmpvc	pc, #1845493760	; 0x6e000000
+ 144:	63656c65 	cmnvs	r5, #25856	; 0x6500
+ 148:	68635f74 	stmdavs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
+ 14c:	6c007069 	stcvs	0, cr7, [r0], {105}	; 0x69
+ 150:	20676e6f 	rsbcs	r6, r7, pc, ror #28
+ 154:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
+ 158:	746e6920 	strbtvc	r6, [lr], #-2336	; 0x920
+ 15c:	67617000 	strbvs	r7, [r1, -r0]!
+ 160:	6f6c0065 	svcvs	0x006c0065
+ 164:	6920676e 	stmdbvs	r0!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
+ 168:	6300746e 	tstvs	r0, #1845493760	; 0x6e000000
+ 16c:	705f6b6c 	subsvc	r6, pc, ip, ror #22
+ 170:	7265776f 	rsbvc	r7, r5, #29097984	; 0x1bc0000
+ 174:	63337300 	teqvs	r3, #0, 6
+ 178:	30343432 	eorscc	r3, r4, r2, lsr r4
+ 17c:	6961775f 	stmdbvs	r1!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
+ 180:	64695f74 	strbtvs	r5, [r9], #-3956	; 0xf74
+ 184:	7300656c 	tstvc	r0, #108, 10	; 0x1b000000
+ 188:	34326333 	ldrtcc	r6, [r2], #-819	; 0x333
+ 18c:	775f3034 			; <UNDEFINED> instruction: 0x775f3034
+ 190:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0x972
+ 194:	6464615f 	strbtvs	r6, [r4], #-351	; 0x15f
+ 198:	706c5f72 	rsbvc	r5, ip, r2, ror pc
+ 19c:	63337300 	teqvs	r3, #0, 6
+ 1a0:	30313432 	eorscc	r3, r1, r2, lsr r4
+ 1a4:	6165725f 	cmnvs	r5, pc, asr r2
+ 1a8:	61645f64 	cmnvs	r4, r4, ror #30
+ 1ac:	6e006174 	mcrvs	1, 0, r6, cr0, cr4, {3}
+ 1b0:	5f646e61 	svcpl	0x00646e61
+ 1b4:	64616572 	strbtvs	r6, [r1], #-1394	; 0x572
+ 1b8:	006c6c5f 	rsbeq	r6, ip, pc, asr ip
+ 1bc:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
+ 1c0:	64656e67 	strbtvs	r6, [r5], #-3687	; 0xe67
+ 1c4:	61686320 	cmnvs	r8, r0, lsr #6
+ 1c8:	33730072 	cmncc	r3, #114	; 0x72
+ 1cc:	34343263 	ldrtcc	r3, [r4], #-611	; 0x263
+ 1d0:	72775f30 	rsbsvc	r5, r7, #48, 30	; 0xc0
+ 1d4:	5f657469 	svcpl	0x00657469
+ 1d8:	72646461 	rsbvc	r6, r4, #1627389952	; 0x61000000
+ 1dc:	6f6f6200 	svcvs	0x006f6200
+ 1e0:	6e695f74 	mcrvs	15, 3, r5, cr9, cr4, {3}
+ 1e4:	632e7469 	teqvs	lr, #1761607680	; 0x69000000
+ 1e8:	4b4c4300 	blmi	1310df0 <clock_init+0x1310a00>
+ 1ec:	004e4f43 	subeq	r4, lr, r3, asr #30
+ 1f0:	32633373 	rsbcc	r3, r3, #-872415231	; 0xcc000001
+ 1f4:	6e303434 	mrcvs	4, 1, r3, cr0, cr4, {1}
+ 1f8:	00646e61 	rsbeq	r6, r4, r1, ror #28
+ 1fc:	4553464e 	ldrbmi	r4, [r3, #-1614]	; 0x64e
+ 200:	73004343 	tstvc	r0, #201326593	; 0xc000001
+ 204:	34326333 	ldrtcc	r6, [r2], #-819	; 0x333
+ 208:	616e3031 	cmnvs	lr, r1, lsr r0
+ 20c:	6c00646e 	stcvs	4, cr6, [r0], {110}	; 0x6e
+ 210:	20676e6f 	rsbcs	r6, r7, pc, ror #28
+ 214:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
+ 218:	736e7520 	cmnvc	lr, #32, 10	; 0x8000000
+ 21c:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0x769
+ 220:	6e692064 	cdpvs	0, 6, cr2, cr9, cr4, {3}
+ 224:	616e0074 	cmnvs	lr, r4, ror r0
+ 228:	735f646e 	cmpvc	pc, #1845493760	; 0x6e000000
+ 22c:	63656c65 	cmnvs	r5, #25856	; 0x6500
+ 230:	68635f74 	stmdavs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
+ 234:	73007069 	tstvc	r0, #105	; 0x69
+ 238:	34326333 	ldrtcc	r6, [r2], #-819	; 0x333
+ 23c:	775f3031 			; <UNDEFINED> instruction: 0x775f3031
+ 240:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0x972
+ 244:	646d635f 	strbtvs	r6, [sp], #-863	; 0x35f
+ 248:	736e7500 	cmnvc	lr, #0, 10
+ 24c:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0x769
+ 250:	6e692064 	cdpvs	0, 6, cr2, cr9, cr4, {3}
+ 254:	33530074 	cmpcc	r3, #116	; 0x74
+ 258:	58343243 	ldmdapl	r4!, {r0, r1, r6, r9, ip, sp}
+ 25c:	4c435f30 	stclmi	15, cr5, [r3], {48}	; 0x30
+ 260:	5f4b434f 	svcpl	0x004b434f
+ 264:	45574f50 	ldrbmi	r4, [r7, #-3920]	; 0xf50
+ 268:	464e0052 			; <UNDEFINED> instruction: 0x464e0052
+ 26c:	4343454d 	cmpmi	r3, #322961408	; 0x13400000
+ 270:	464e0030 			; <UNDEFINED> instruction: 0x464e0030
+ 274:	4343454d 	cmpmi	r3, #322961408	; 0x13400000
+ 278:	50550031 	subspl	r0, r5, r1, lsr r0
+ 27c:	4f434c4c 	svcmi	0x00434c4c
+ 280:	616e004e 	cmnvs	lr, lr, asr #32
+ 284:	725f646e 	subsvc	r6, pc, #1845493760	; 0x6e000000
+ 288:	74657365 	strbtvc	r7, [r5], #-869	; 0x365
+ 28c:	69617700 	stmdbvs	r1!, {r8, r9, sl, ip, sp, lr}^
+ 290:	64695f74 	strbtvs	r5, [r9], #-3956	; 0xf74
+ 294:	4300656c 	tstmi	r0, #108, 10	; 0x1b000000
+ 298:	49444b4c 	stmdbmi	r4, {r2, r3, r6, r8, r9, fp, lr}^
+ 29c:	4e004e56 	mcrmi	14, 0, r4, cr0, cr6, {2}
+ 2a0:	444d4346 	strbmi	r4, [sp], #-838	; 0x346
+ 2a4:	44464e00 	strbmi	r4, [r6], #-3584	; 0xe00
+ 2a8:	00415441 	subeq	r5, r1, r1, asr #8
+ 2ac:	72616863 	rsbvc	r6, r1, #6488064	; 0x630000
+ 2b0:	43335300 	teqmi	r3, #0, 6
+ 2b4:	30313432 	eorscc	r3, r1, r2, lsr r4
+ 2b8:	4e414e5f 	mcrmi	14, 2, r4, cr1, cr15, {2}
+ 2bc:	33730044 	cmncc	r3, #68	; 0x44
+ 2c0:	34343263 	ldrtcc	r3, [r4], #-611	; 0x263
+ 2c4:	616e5f30 	cmnvs	lr, r0, lsr pc
+ 2c8:	645f646e 	ldrbvs	r6, [pc], #-1134	; 2d0 <.debug_str+0x2d0>
+ 2cc:	6c657365 	stclvs	3, cr7, [r5], #-404	; 0xfffffe6c
+ 2d0:	5f746365 	svcpl	0x00746365
+ 2d4:	70696863 	rsbvc	r6, r9, r3, ror #16
+ 2d8:	45464e00 	strbmi	r4, [r6, #-3584]	; 0xe00
+ 2dc:	004b4c42 	subeq	r4, fp, r2, asr #24
+ 2e0:	20554e47 	subscs	r4, r5, r7, asr #28
+ 2e4:	2e342043 	cdpcs	0, 3, cr2, cr4, cr3, {2}
+ 2e8:	20342e39 	eorscs	r2, r4, r9, lsr lr
+ 2ec:	6c666d2d 	stclvs	13, cr6, [r6], #-180	; 0xffffff4c
+ 2f0:	2d74616f 	ldfcse	f6, [r4, #-444]!	; 0xfffffe44
+ 2f4:	3d696261 	sfmcc	f6, 2, [r9, #-388]!	; 0xfffffe7c
+ 2f8:	74666f73 	strbtvc	r6, [r6], #-3955	; 0xf73
+ 2fc:	616d2d20 	cmnvs	sp, r0, lsr #26
+ 300:	3d686372 	stclcc	3, cr6, [r8, #-456]!	; 0xfffffe38
+ 304:	766d7261 	strbtvc	r7, [sp], -r1, ror #4
+ 308:	6d2d2034 	stcvs	0, cr2, [sp, #-208]!	; 0xffffff30
+ 30c:	3d696261 	sfmcc	f6, 2, [r9, #-388]!	; 0xfffffe7c
+ 310:	73637061 	cmnvc	r3, #97	; 0x61
+ 314:	756e672d 	strbvc	r6, [lr, #-1837]!	; 0x72d
+ 318:	746d2d20 	strbtvc	r2, [sp], #-3360	; 0xd20
+ 31c:	3d656e75 	stclcc	14, cr6, [r5, #-468]!	; 0xfffffe2c
+ 320:	74726f63 	ldrbtvc	r6, [r2], #-3939	; 0xf63
+ 324:	612d7865 	teqvs	sp, r5, ror #16
+ 328:	6d2d2039 	stcvs	0, cr2, [sp, #-228]!	; 0xffffff1c
+ 32c:	3d757066 	ldclcc	0, cr7, [r5, #-408]!	; 0xfffffe68
+ 330:	76706676 			; <UNDEFINED> instruction: 0x76706676
+ 334:	31642d33 	cmncc	r4, r3, lsr sp
+ 338:	6d2d2036 	stcvs	0, cr2, [sp, #-216]!	; 0xffffff28
+ 33c:	6d756874 	ldclvs	8, cr6, [r5, #-464]!	; 0xfffffe30
+ 340:	6d2d2062 	stcvs	0, cr2, [sp, #-392]!	; 0xfffffe78
+ 344:	2d736c74 	ldclcs	12, cr6, [r3, #-464]!	; 0xfffffe30
+ 348:	6c616964 	stclvs	9, cr6, [r1], #-400	; 0xfffffe70
+ 34c:	3d746365 	ldclcc	3, cr6, [r4, #-404]!	; 0xfffffe6c
+ 350:	20756e67 	rsbscs	r6, r5, r7, ror #28
+ 354:	2d20672d 	stccs	7, cr6, [r0, #-180]!	; 0xffffff4c
+ 358:	2d20734f 	stccs	3, cr7, [r0, #-316]!	; 0xfffffec4
+ 35c:	2d6f6e66 	stclcs	14, cr6, [pc, #-408]!	; 1cc <.debug_str+0x1cc>
+ 360:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
+ 364:	612d7463 	teqvs	sp, r3, ror #8
+ 368:	7361696c 	cmnvc	r1, #108, 18	; 0x1b0000
+ 36c:	20676e69 	rsbcs	r6, r7, r9, ror #28
+ 370:	6f6e662d 	svcvs	0x006e662d
+ 374:	6d6f632d 	stclvs	3, cr6, [pc, #-180]!	; 2c8 <.debug_str+0x2c8>
+ 378:	206e6f6d 	rsbcs	r6, lr, sp, ror #30
+ 37c:	6966662d 	stmdbvs	r6!, {r0, r2, r3, r5, r9, sl, sp, lr}^
+ 380:	2d646578 	stclcs	5, cr6, [r4, #-480]!	; 0xfffffe20
+ 384:	2d203872 	stccs	8, cr3, [r0, #-456]!	; 0xfffffe38
+ 388:	2d6f6e66 	stclcs	14, cr6, [pc, #-408]!	; 1f8 <.debug_str+0x1f8>
+ 38c:	6c697562 	stclvs	5, cr7, [r9], #-392	; 0xfffffe78
+ 390:	206e6974 	rsbcs	r6, lr, r4, ror r9
+ 394:	7266662d 	rsbvc	r6, r6, #47185920	; 0x2d00000
+ 398:	74736565 	ldrbtvc	r6, [r3], #-1381	; 0x565
+ 39c:	69646e61 	stmdbvs	r4!, {r0, r5, r6, r9, sl, fp, sp, lr}^
+ 3a0:	7300676e 	tstvc	r0, #28835840	; 0x1b80000
+ 3a4:	74726f68 	ldrbtvc	r6, [r2], #-3944	; 0xf68
+ 3a8:	736e7520 	cmnvc	lr, #32, 10	; 0x8000000
+ 3ac:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0x769
+ 3b0:	6e692064 	cdpvs	0, 6, cr2, cr9, cr4, {3}
+ 3b4:	64700074 	ldrbtvs	r0, [r0], #-116	; 0x74
+ 3b8:	63725377 	cmnvs	r2, #-603979775	; 0xdc000001
+ 3bc:	45464e00 	strbmi	r4, [r6, #-3584]	; 0xe00
+ 3c0:	73004343 	tstvc	r0, #201326593	; 0xc000001
+ 3c4:	00657a69 	rsbeq	r7, r5, r9, ror #20
+ 3c8:	4553464e 	ldrbmi	r4, [r3, #-1614]	; 0x64e
+ 3cc:	00444343 	subeq	r4, r4, r3, asr #6
+ 3d0:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
+ 3d4:	736e7520 	cmnvc	lr, #32, 10	; 0x8000000
+ 3d8:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0x769
+ 3dc:	6e692064 	cdpvs	0, 6, cr2, cr9, cr4, {3}
+ 3e0:	772f0074 			; <UNDEFINED> instruction: 0x772f0074
+ 3e4:	2f6b726f 	svccs	0x006b726f
+ 3e8:	74737973 	ldrbtvc	r7, [r3], #-2419	; 0x973
+ 3ec:	752f6d65 	strvc	r6, [pc, #-3429]!	; fffff68f <clock_init+0xfffff29f>
+ 3f0:	6f6f622d 	svcvs	0x006f622d
+ 3f4:	2e312d74 	mrccs	13, 1, r2, cr1, cr4, {3}
+ 3f8:	2f362e31 	svccs	0x00362e31
+ 3fc:	72616f62 	rsbvc	r6, r1, #392	; 0x188
+ 400:	30312f64 	eorscc	r2, r1, r4, ror #30
+ 404:	6b736130 	blvs	1cd88cc <clock_init+0x1cd84dc>
+ 408:	30783432 	rsbscc	r3, r8, r2, lsr r4
+ 40c:	63337300 	teqvs	r3, #0, 6
+ 410:	30313432 	eorscc	r3, r1, r2, lsr r4
+ 414:	6e616e5f 	mcrvs	14, 3, r6, cr1, cr15, {2}
+ 418:	65725f64 	ldrbvs	r5, [r2, #-3940]!	; 0xf64
+ 41c:	00746573 	rsbseq	r6, r4, r3, ror r5
+ 420:	646e616e 	strbtvs	r6, [lr], #-366	; 0x16e
+ 424:	6165725f 	cmnvs	r5, pc, asr r2
+ 428:	6c6c5f64 	stclvs	15, cr5, [ip], #-400	; 0xfffffe70
+ 42c:	00706c5f 	rsbseq	r6, r0, pc, asr ip
+ 430:	636f6c63 	cmnvs	pc, #25344	; 0x6300
+ 434:	6e695f6b 	cdpvs	15, 6, cr5, cr9, cr11, {3}
+ 438:	73007469 	tstvc	r0, #1761607680	; 0x69000000
+ 43c:	34326333 	ldrtcc	r6, [r2], #-819	; 0x333
+ 440:	775f3031 			; <UNDEFINED> instruction: 0x775f3031
+ 444:	5f746961 	svcpl	0x00746961
+ 448:	656c6469 	strbvs	r6, [ip, #-1129]!	; 0x469
+ 44c:	53464e00 	cmppl	r6, #0, 28
+ 450:	004b4c42 	subeq	r4, fp, r2, asr #24
+ 454:	74697277 	strbtvc	r7, [r9], #-631	; 0x277
+ 458:	64615f65 	strbtvs	r5, [r1], #-3941	; 0xf65
+ 45c:	6c5f7264 	lfmvs	f7, 2, [pc], {100}	; 0x64
+ 460:	41430070 	cmpmi	r3, r0, ror r0
+ 464:	5649444d 	strbpl	r4, [r9], -sp, asr #8
+ 468:	6973004e 	ldmdbvs	r3!, {r1, r2, r3, r6}^
+ 46c:	7974657a 	ldmdbvc	r4!, {r1, r3, r4, r5, r6, r8, sl, sp, lr}^
+ 470:	43006570 	tstmi	r0, #112, 10	; 0x1c000000
+ 474:	4379706f 	cmnmi	r9, #111	; 0x6f
+ 478:	3265646f 	rsbcc	r6, r5, #1862270976	; 0x6f000000
+ 47c:	006d6152 	rsbeq	r6, sp, r2, asr r1
+ 480:	32433353 	subcc	r3, r3, #1275068417	; 0x4c000001
+ 484:	5f305834 	svcpl	0x00305834
+ 488:	33474552 	cmpcc	r7, #343932928	; 0x14800000
+ 48c:	64700032 	ldrbtvs	r0, [r0], #-50	; 0x32
+ 490:	73654477 	cmnvc	r5, #1996488704	; 0x77000000
+ 494:	464e0074 			; <UNDEFINED> instruction: 0x464e0074
+ 498:	41545345 	cmpmi	r4, r5, asr #6
+ 49c:	4e003054 	mcrmi	0, 0, r3, cr0, cr4, {2}
+ 4a0:	54534546 	ldrbpl	r4, [r3], #-1350	; 0x546
+ 4a4:	00315441 	eorseq	r5, r1, r1, asr #8
+ 4a8:	74697277 	strbtvc	r7, [r9], #-631	; 0x277
+ 4ac:	64615f65 	strbtvs	r5, [r1], #-3941	; 0xf65
+ 4b0:	73007264 	tstvc	r0, #100, 4	; 0x40000006
+ 4b4:	34326333 	ldrtcc	r6, [r2], #-819	; 0x333
+ 4b8:	6e5f3031 	mrcvs	0, 2, r3, cr15, cr1, {1}
+ 4bc:	5f646e61 	svcpl	0x00646e61
+ 4c0:	656c6573 	strbvs	r6, [ip, #-1395]!	; 0x573
+ 4c4:	635f7463 	cmpvs	pc, #1660944384	; 0x63000000
+ 4c8:	00706968 	rsbseq	r6, r0, r8, ror #18
+
+Disassembly of section .comment:
+
+00000000 <.comment>:
+   0:	43434700 	cmpmi	r3, #0, 14
+   4:	4c28203a 	stcmi	0, cr2, [r8], #-232	; 0xffffff18
+   8:	72616e69 	rsbvc	r6, r1, #1680	; 0x690
+   c:	4347206f 	cmpmi	r7, #111	; 0x6f
+  10:	2e342043 	cdpcs	0, 3, cr2, cr4, cr3, {2}
+  14:	30322d39 	eorscc	r2, r2, r9, lsr sp
+  18:	302e3731 	eorcc	r3, lr, r1, lsr r7
+  1c:	34202931 	strtcc	r2, [r0], #-2353	; 0x931
+  20:	342e392e 	strtcc	r3, [lr], #-2350	; 0x92e
+	...
+
+Disassembly of section .ARM.attributes:
+
+00000000 <.ARM.attributes>:
+   0:	00000f41 	andeq	r0, r0, r1, asr #30
+   4:	61656100 	cmnvs	r5, r0, lsl #2
+   8:	01006962 	tsteq	r0, r2, ror #18
+   c:	00000005 	andeq	r0, r0, r5
+
+Disassembly of section .debug_frame:
+
+00000000 <.debug_frame>:
+   0:	0000000c 	andeq	r0, r0, ip
+   4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
+   8:	7c020001 	stcvc	0, cr0, [r2], {1}
+   c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
+  10:	0000000c 	andeq	r0, r0, ip
+	...
+  1c:	00000030 	andeq	r0, r0, r0, lsr r0
+  20:	0000000c 	andeq	r0, r0, ip
+  24:	00000000 	andeq	r0, r0, r0
+  28:	00000030 	andeq	r0, r0, r0, lsr r0
+  2c:	0000003c 	andeq	r0, r0, ip, lsr r0
+  30:	0000000c 	andeq	r0, r0, ip
+  34:	00000000 	andeq	r0, r0, r0
+  38:	0000006c 	andeq	r0, r0, ip, rrx
+  3c:	0000003c 	andeq	r0, r0, ip, lsr r0
+  40:	0000000c 	andeq	r0, r0, ip
+  44:	00000000 	andeq	r0, r0, r0
+  48:	000000a8 	andeq	r0, r0, r8, lsr #1
+  4c:	00000044 	andeq	r0, r0, r4, asr #32
+  50:	0000000c 	andeq	r0, r0, ip
+  54:	00000000 	andeq	r0, r0, r0
+  58:	000000ec 	andeq	r0, r0, ip, ror #1
+  5c:	000000c4 	andeq	r0, r0, r4, asr #1
+  60:	00000028 	andeq	r0, r0, r8, lsr #32
+  64:	00000000 	andeq	r0, r0, r0
+  68:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
+  6c:	00000104 	andeq	r0, r0, r4, lsl #2
+  70:	84180e44 	ldrhi	r0, [r8], #-3652	; 0xe44
+  74:	86058506 	strhi	r8, [r5], -r6, lsl #10
+  78:	89038704 	stmdbhi	r3, {r2, r8, r9, sl, pc}
+  7c:	02018e02 	andeq	r8, r1, #2, 28
+  80:	c7c9ce7a 			; <UNDEFINED> instruction: 0xc7c9ce7a
+  84:	0ec4c5c6 	cdpeq	5, 12, cr12, cr4, cr6, {6}
+  88:	00000000 	andeq	r0, r0, r0
+  8c:	00000028 	andeq	r0, r0, r8, lsr #32
+  90:	00000000 	andeq	r0, r0, r0
+  94:	000002b4 			; <UNDEFINED> instruction: 0x000002b4
+  98:	00000128 	andeq	r0, r0, r8, lsr #2
+  9c:	84180e44 	ldrhi	r0, [r8], #-3652	; 0xe44
+  a0:	86058506 	strhi	r8, [r5], -r6, lsl #10
+  a4:	89038704 	stmdbhi	r3, {r2, r8, r9, sl, pc}
+  a8:	02018e02 	andeq	r8, r1, #2, 28
+  ac:	c7c9ce8c 	strbgt	ip, [r9, ip, lsl #29]
+  b0:	0ec4c5c6 	cdpeq	5, 12, cr12, cr4, cr6, {6}
+  b4:	00000000 	andeq	r0, r0, r0
+  b8:	0000000c 	andeq	r0, r0, ip
+  bc:	00000000 	andeq	r0, r0, r0
+  c0:	000003dc 			; <UNDEFINED> instruction: 0x000003dc
+  c4:	0000000c 	andeq	r0, r0, ip
+  c8:	00000014 	andeq	r0, r0, r4, lsl r0
+  cc:	00000000 	andeq	r0, r0, r0
+  d0:	000003e8 	andeq	r0, r0, r8, ror #7
+  d4:	00000008 	andeq	r0, r0, r8
+  d8:	8e040e42 	cdphi	14, 0, cr0, cr4, cr2, {2}
+  dc:	00000001 	andeq	r0, r0, r1
+  e0:	0000000c 	andeq	r0, r0, ip
+  e4:	00000000 	andeq	r0, r0, r0
+  e8:	000003f0 			; <UNDEFINED> instruction: 0x000003f0
+  ec:	000000b4 	strheq	r0, [r0], -r4
diff -urN u-boot-1.1.6/board/100ask24x0/config.mk u-boot-1.1.6_fdt/board/100ask24x0/config.mk
--- u-boot-1.1.6/board/100ask24x0/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/board/100ask24x0/config.mk	2018-10-22 15:53:21.537641225 +0800
@@ -0,0 +1,25 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# SAMSUNG SMDK2410 board with S3C2410X (ARM920T) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+#
+# SMDK2410 has 1 bank of 64 MB DRAM
+#
+# 3000'0000 to 3400'0000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# we load ourself to 33F8'0000
+#
+# download area is 3300'0000
+#
+
+
+TEXT_BASE = 0x33F80000
diff -urN u-boot-1.1.6/board/100ask24x0/flash.c u-boot-1.1.6_fdt/board/100ask24x0/flash.c
--- u-boot-1.1.6/board/100ask24x0/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/board/100ask24x0/flash.c	2018-10-22 15:53:21.537641225 +0800
@@ -0,0 +1,433 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+ulong myflush (void);
+
+
+#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
+#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+
+#define CMD_READ_ARRAY		0x000000F0
+#define CMD_UNLOCK1		0x000000AA
+#define CMD_UNLOCK2		0x00000055
+#define CMD_ERASE_SETUP		0x00000080
+#define CMD_ERASE_CONFIRM	0x00000030
+#define CMD_PROGRAM		0x000000A0
+#define CMD_UNLOCK_BYPASS	0x00000020
+
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CFG_FLASH_BASE + (0x00000555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CFG_FLASH_BASE + (0x000002AA << 1)))
+
+#define BIT_ERASE_DONE		0x00000080
+#define BIT_RDY_MASK		0x00000080
+#define BIT_PROGRAM_ERROR	0x00000020
+#define BIT_TIMEOUT		0x80000000	/* our flag */
+
+#define READY 1
+#define ERR   2
+#define TMO   4
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_info[i].flash_id =
+#if defined(CONFIG_AMD_LV400)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV400B & FLASH_TYPEMASK);
+#elif defined(CONFIG_AMD_LV800)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV800B & FLASH_TYPEMASK);
+#else
+#error "Unknown flash configured"
+#endif
+			flash_info[i].size = FLASH_BANK_SIZE;
+		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
+		if (i == 0)
+			flashbase = PHYS_FLASH_1;
+		else
+			panic ("configured too many flash banks!\n");
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			if (j <= 3) {
+				/* 1st one is 16 KB */
+				if (j == 0) {
+					flash_info[i].start[j] =
+						flashbase + 0;
+				}
+
+				/* 2nd and 3rd are both 8 KB */
+				if ((j == 1) || (j == 2)) {
+					flash_info[i].start[j] =
+						flashbase + 0x4000 + (j -
+								      1) *
+						0x2000;
+				}
+
+				/* 4th 32 KB */
+				if (j == 3) {
+					flash_info[i].start[j] =
+						flashbase + 0x8000;
+				}
+			} else {
+				flash_info[i].start[j] =
+					flashbase + (j - 3) * MAIN_SECT_SIZE;
+			}
+		}
+		size += flash_info[i].size;
+	}
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_FLASH_BASE,
+		       CFG_FLASH_BASE + monitor_flash_len - 1,
+		       &flash_info[0]);
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_ENV_ADDR,
+		       CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_LV400B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV400BB (4Mbit)\n");
+		break;
+	case (AMD_ID_LV800B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV800BB (8Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		goto Done;
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+
+      Done:;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	ushort result;
+	int iflag, cflag, prot, sect;
+	int rc = ERR_OK;
+	int chip;
+
+	/* first look for protection bits */
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+		printf ("Erasing sector %2d ... ", sect);
+
+		/* arm simple, non interrupt dependent timer */
+		reset_timer_masked ();
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			vu_short *addr = (vu_short *) (info->start[sect]);
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			*addr = CMD_ERASE_CONFIRM;
+
+			/* wait until flash is ready */
+			chip = 0;
+
+			do {
+				result = *addr;
+
+				/* check timeout */
+				if (get_timer_masked () >
+				    CFG_FLASH_ERASE_TOUT) {
+					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+					chip = TMO;
+					break;
+				}
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_ERASE_DONE)
+					chip = READY;
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
+					chip = ERR;
+
+			} while (!chip);
+
+			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+
+			if (chip == ERR) {
+				rc = ERR_PROG_ERROR;
+				goto outahere;
+			}
+			if (chip == TMO) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+
+			printf ("ok.\n");
+		} else {	/* it was protected */
+
+			printf ("protected!\n");
+		}
+	}
+
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+      outahere:
+	/* allow flash to settle - wait 10 ms */
+	udelay_masked (10000);
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+volatile static int write_hword (flash_info_t * info, ulong dest, ushort data)
+{
+	vu_short *addr = (vu_short *) dest;
+	ushort result;
+	int rc = ERR_OK;
+	int cflag, iflag;
+	int chip;
+
+	/*
+	 * Check if Flash is (sufficiently) erased
+	 */
+	result = *addr;
+	if ((result & data) != data)
+		return ERR_NOT_ERASED;
+
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
+	*addr = CMD_PROGRAM;
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait until flash is ready */
+	chip = 0;
+	do {
+		result = *addr;
+
+		/* check timeout */
+		if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
+			chip = ERR | TMO;
+			break;
+		}
+		if (!chip && ((result & 0x80) == (data & 0x80)))
+			chip = READY;
+
+		if (!chip && ((result & 0xFFFF) & BIT_PROGRAM_ERROR)) {
+			result = *addr;
+
+			if ((result & 0x80) == (data & 0x80))
+				chip = READY;
+			else
+				chip = ERR;
+		}
+
+	} while (!chip);
+
+	*addr = CMD_READ_ARRAY;
+
+	if (chip == ERR || *addr != data)
+		rc = ERR_PROG_ERROR;
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	int l;
+	int i, rc;
+	ushort data;
+
+	wp = (addr & ~1);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_hword (info, wp, data);
+}
diff -urN u-boot-1.1.6/board/100ask24x0/lowlevel_init.S u-boot-1.1.6_fdt/board/100ask24x0/lowlevel_init.S
--- u-boot-1.1.6/board/100ask24x0/lowlevel_init.S	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/board/100ask24x0/lowlevel_init.S	2018-10-22 15:53:21.537641225 +0800
@@ -0,0 +1,168 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ *
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8		 	(0x0)
+#define DW16		 	(0x1)
+#define DW32		 	(0x2)
+#define WAIT		 	(0x1<<2)
+#define UBLB		 	(0x1<<3)
+
+#define B1_BWSCON	  	(DW16)
+#define B2_BWSCON	  	(DW16)
+//#define B3_BWSCON	  	(DW16 + WAIT + UBLB)
+#define B3_BWSCON	  	(DW16 + UBLB)
+#define B4_BWSCON	  	(DW16 + WAIT + UBLB)
+#define B5_BWSCON	  	(DW8)
+#define B6_BWSCON	  	(DW32)
+#define B7_BWSCON	  	(DW32)
+
+/* BANK0CON */
+#define B0_Tacs		 	0x0	/*  0clk */
+#define B0_Tcos		 	0x0	/*  0clk */
+#define B0_Tacc		 	0x7	/* 14clk */
+#define B0_Tcoh		 	0x0	/*  0clk */
+#define B0_Tah		 	0x0	/*  0clk */
+#define B0_Tacp		 	0x0
+#define B0_PMC		 	0x0	/* normal */
+
+/* BANK1CON */
+#define B1_Tacs		 	0x0	/*  0clk */
+#define B1_Tcos		 	0x0	/*  0clk */
+#define B1_Tacc		 	0x7	/* 14clk */
+#define B1_Tcoh		 	0x0	/*  0clk */
+#define B1_Tah		 	0x0	/*  0clk */
+#define B1_Tacp		 	0x0
+#define B1_PMC		 	0x0
+
+#define B2_Tacs		 	0x0
+#define B2_Tcos		 	0x0
+#define B2_Tacc		 	0x7
+#define B2_Tcoh		 	0x0
+#define B2_Tah		 	0x0
+#define B2_Tacp		 	0x0
+#define B2_PMC		 	0x0
+
+#define B3_Tacs		 	0x0	/*  0clk */
+#define B3_Tcos		 	0x3	/*  4clk */
+#define B3_Tacc		 	0x7	/* 14clk */
+#define B3_Tcoh		 	0x1	/*  1clk */
+#define B3_Tah		 	0x0	/*  0clk */
+#define B3_Tacp		 	0x3     /*  6clk */
+#define B3_PMC		 	0x0	/* normal */
+
+#define B4_Tacs		 	0x0	/*  0clk */
+#define B4_Tcos		 	0x3	/*  4clk */
+#define B4_Tacc		 	0x7	/* 14clk */
+#define B4_Tcoh		 	0x1	/*  1clk */
+#define B4_Tah		 	0x3	/*  4clk */
+#define B4_Tacp		 	0x6 /*  6clk */
+#define B4_PMC		 	0x0	/* normal */
+
+#define B5_Tacs		 	0x0	/*  0clk */
+#define B5_Tcos		 	0x0	/*  0clk */
+#define B5_Tacc		 	0x7	/* 14clk */
+#define B5_Tcoh		 	0x0	/*  0clk */
+#define B5_Tah		 	0x0	/*  0clk */
+#define B5_Tacp		 	0x0
+#define B5_PMC		 	0x0	/* normal */
+
+#define B6_MT		 	0x3	/* SDRAM */
+#define B6_Trcd	 	 	0x1
+#define B6_SCAN		 	0x1	/* 9bit */
+
+#define B7_MT		 	0x3	/* SDRAM */
+#define B7_Trcd		 	0x1	/* 3clk */
+#define B7_SCAN		 	0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN		 	0x1	/* Refresh enable */
+#define TREFMD		 	0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trp		 	    0x0	/* 2clk */
+#define Trc		    	0x3	/* 7clk */
+#define Tchr		 	0x2	/* 3clk */
+#define REFCNT		 	0x4f4	/* period=7.8125us, HCLK=100Mhz, (2048+1-7.8125*100) */
+/**************************************/
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28)) 
+    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
+    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
+    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
+    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
+    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
+    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
+    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
+    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
+    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+    .word 0xb1
+    .word 0x30
+    .word 0x30
diff -urN u-boot-1.1.6/board/100ask24x0/Makefile u-boot-1.1.6_fdt/board/100ask24x0/Makefile
--- u-boot-1.1.6/board/100ask24x0/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/board/100ask24x0/Makefile	2018-10-22 15:53:21.537641225 +0800
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= 100ask24x0.o boot_init.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-1.1.6/board/100ask24x0/u-boot.lds u-boot-1.1.6_fdt/board/100ask24x0/u-boot.lds
--- u-boot-1.1.6/board/100ask24x0/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/board/100ask24x0/u-boot.lds	2018-10-22 15:53:21.537641225 +0800
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm920t/start.o	(.text)
+          board/100ask24x0/boot_init.o (.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -urN u-boot-1.1.6/board/MAI/bios_emulator/scitech/src/v86bios/lex.l u-boot-1.1.6_fdt/board/MAI/bios_emulator/scitech/src/v86bios/lex.l
--- u-boot-1.1.6/board/MAI/bios_emulator/scitech/src/v86bios/lex.l	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/board/MAI/bios_emulator/scitech/src/v86bios/lex.l	1970-01-01 08:00:00.000000000 +0800
@@ -1,79 +0,0 @@
-%{
-#include "parser.h"
-
-#include <string.h>
-#include <stdio.h>
-
- void getline(char *buf,int *num,int max_num);
-    
-#define YY_INPUT(buf,result,max_size) {\
-      getline(buf,&result,max_size);\
-      }
-
- void
- yyerror (char *s)  
- {
-     printf ("%s\n", s);
- }
-
-%}
-
-DIGIT [0-9a-fA-F]
-
-%%
-
-"0x"?{DIGIT}+ { yylval = strtol(yytext,NULL,0); return TOK_NUM; }
-"ax"          { return TOK_REG_AX; }
-"bx"          { return TOK_REG_BX; }
-"cx"          { return TOK_REG_CX; }
-"dx"          { return TOK_REG_DX; }
-"di"          { return TOK_REG_SI; }
-"si"          { return TOK_REG_DI; }
-"ds"          { return TOK_SEG_DS; }
-"es"          { return TOK_SEG_ES; }
-":"           { return TOK_SEP;}
-"$"{DIGIT}{1,2} { yylval = strtol(yytext+1,NULL,0); return TOK_VAR; }
-"$mem"        { return TOK_VAR_MEM; }
-[ \t]+
-"#".*[\n]   { return TOK_END; }
-"boot"        { return TOK_COMMAND_BOOT; }
-"do"          { return TOK_COMMAND_EXEC; }
-"\"".*"\""    { yylval = (unsigned long) yytext; return TOK_STRING; }
-"byte"        { return TOK_BYTE; }
-"word"        { return TOK_WORD; }
-"long"        { return TOK_LONG; }
-"setmem"      { return TOK_COMMAND_MEMSET; }
-"dumpmem"     { return TOK_COMMAND_MEMDUMP; }
-"quit"        { return TOK_COMMAND_QUIT; }
-"\n"          { return TOK_END; }
-"select"      { return TOK_SELECT; }
-"isa"         { return TOK_ISA; }
-"pci"         { return TOK_PCI; }
-"pport"       { return TOK_PRINT_PORT; }
-"iostat"      { return TOK_IOSTAT; }
-"pirq"        { return TOK_PRINT_IRQ; }
-"ppci"        { return TOK_PPCI; }
-"pip"         { return TOK_PIP; }
-"trace"       { return TOK_TRACE; }
-"on"          { return TOK_ON; }
-"off"         { return TOK_OFF; }
-"verbose"     { return TOK_VERBOSE; }
-"log"         { return TOK_LOG; }
-"print"       { return TOK_STDOUT; }
-"clstat"      { return TOK_CLSTAT; }
-"hlt"         { return TOK_HLT; }
-"del"         { return TOK_DEL; }
-"ioperm"      { return TOK_IOPERM; }
-"lpci"        { return TOK_DUMP_PCI; }
-"bootbios"    { return TOK_BOOT_BIOS; }
-"?"           { return '?'; }
-.             { return TOK_ERROR; }
-    
-%%
-
-
-
-
-
-
-
diff -urN u-boot-1.1.6/common/cmd_bootm.c u-boot-1.1.6_fdt/common/cmd_bootm.c
--- u-boot-1.1.6/common/cmd_bootm.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/common/cmd_bootm.c	2018-10-22 15:53:21.537641225 +0800
@@ -305,12 +305,12 @@
 
 	iflag = disable_interrupts();
 
-#ifdef CONFIG_AMIGAONEG3SE
+#ifdef CONFIG_AMIGAONEG3SE 
 	/*
 	 * We've possible left the caches enabled during
 	 * bios emulation, so turn them off again
 	 */
-	icache_disable();
+	icache_disable();  
 	invalidate_l1_instruction_cache();
 	flush_data_cache();
 	dcache_disable();
@@ -318,7 +318,7 @@
 
 	switch (hdr->ih_comp) {
 	case IH_COMP_NONE:
-		if(ntohl(hdr->ih_load) == addr) {
+		if(ntohl(hdr->ih_load) == data) {
 			printf ("   XIP %s ... ", name);
 		} else {
 #if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
diff -urN u-boot-1.1.6/common/cmd_load.c u-boot-1.1.6_fdt/common/cmd_load.c
--- u-boot-1.1.6/common/cmd_load.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/common/cmd_load.c	2018-10-22 15:53:21.537641225 +0800
@@ -34,6 +34,8 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 #if (CONFIG_COMMANDS & CFG_CMD_LOADB)
+/* support xmodem, www.100ask.net */
+static ulong load_serial_xmodem (ulong offset);
 static ulong load_serial_ymodem (ulong offset);
 #endif
 
@@ -53,355 +55,355 @@
 #if (CONFIG_COMMANDS & CFG_CMD_LOADS)
 int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	ulong offset = 0;
-	ulong addr;
-	int i;
-	char *env_echo;
-	int rcode = 0;
-#ifdef	CFG_LOADS_BAUD_CHANGE
-	int load_baudrate, current_baudrate;
+    ulong offset = 0;
+    ulong addr;
+    int i;
+    char *env_echo;
+    int rcode = 0;
+#ifdef  CFG_LOADS_BAUD_CHANGE
+    int load_baudrate, current_baudrate;
 
-	load_baudrate = current_baudrate = gd->baudrate;
+    load_baudrate = current_baudrate = gd->baudrate;
 #endif
 
-	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
-		do_echo = 1;
-	} else {
-		do_echo = 0;
-	}
-
-#ifdef	CFG_LOADS_BAUD_CHANGE
-	if (argc >= 2) {
-		offset = simple_strtoul(argv[1], NULL, 16);
-	}
-	if (argc == 3) {
-		load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
-
-		/* default to current baudrate */
-		if (load_baudrate == 0)
-			load_baudrate = current_baudrate;
-	}
-	if (load_baudrate != current_baudrate) {
-		printf ("## Switch baudrate to %d bps and press ENTER ...\n",
-			load_baudrate);
-		udelay(50000);
-		gd->baudrate = load_baudrate;
-		serial_setbrg ();
-		udelay(50000);
-		for (;;) {
-			if (getc() == '\r')
-				break;
-		}
-	}
-#else	/* ! CFG_LOADS_BAUD_CHANGE */
-	if (argc == 2) {
-		offset = simple_strtoul(argv[1], NULL, 16);
-	}
-#endif	/* CFG_LOADS_BAUD_CHANGE */
-
-	printf ("## Ready for S-Record download ...\n");
-
-	addr = load_serial (offset);
-
-	/*
-	 * Gather any trailing characters (for instance, the ^D which
-	 * is sent by 'cu' after sending a file), and give the
-	 * box some time (100 * 1 ms)
-	 */
-	for (i=0; i<100; ++i) {
-		if (tstc()) {
-			(void) getc();
-		}
-		udelay(1000);
-	}
-
-	if (addr == ~0) {
-		printf ("## S-Record download aborted\n");
-		rcode = 1;
-	} else {
-		printf ("## Start Addr      = 0x%08lX\n", addr);
-		load_addr = addr;
-	}
-
-#ifdef	CFG_LOADS_BAUD_CHANGE
-	if (load_baudrate != current_baudrate) {
-		printf ("## Switch baudrate to %d bps and press ESC ...\n",
-			current_baudrate);
-		udelay (50000);
-		gd->baudrate = current_baudrate;
-		serial_setbrg ();
-		udelay (50000);
-		for (;;) {
-			if (getc() == 0x1B) /* ESC */
-				break;
-		}
-	}
+    if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
+        do_echo = 1;
+    } else {
+        do_echo = 0;
+    }
+
+#ifdef  CFG_LOADS_BAUD_CHANGE
+    if (argc >= 2) {
+        offset = simple_strtoul(argv[1], NULL, 16);
+    }
+    if (argc == 3) {
+        load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
+
+        /* default to current baudrate */
+        if (load_baudrate == 0)
+            load_baudrate = current_baudrate;
+    }
+    if (load_baudrate != current_baudrate) {
+        printf ("## Switch baudrate to %d bps and press ENTER ...\n",
+            load_baudrate);
+        udelay(50000);
+        gd->baudrate = load_baudrate;
+        serial_setbrg ();
+        udelay(50000);
+        for (;;) {
+            if (getc() == '\r')
+                break;
+        }
+    }
+#else   /* ! CFG_LOADS_BAUD_CHANGE */
+    if (argc == 2) {
+        offset = simple_strtoul(argv[1], NULL, 16);
+    }
+#endif  /* CFG_LOADS_BAUD_CHANGE */
+
+    printf ("## Ready for S-Record download ...\n");
+
+    addr = load_serial (offset);
+
+    /*
+     * Gather any trailing characters (for instance, the ^D which
+     * is sent by 'cu' after sending a file), and give the
+     * box some time (100 * 1 ms)
+     */
+    for (i=0; i<100; ++i) {
+        if (tstc()) {
+            (void) getc();
+        }
+        udelay(1000);
+    }
+
+    if (addr == ~0) {
+        printf ("## S-Record download aborted\n");
+        rcode = 1;
+    } else {
+        printf ("## Start Addr      = 0x%08lX\n", addr);
+        load_addr = addr;
+    }
+
+#ifdef  CFG_LOADS_BAUD_CHANGE
+    if (load_baudrate != current_baudrate) {
+        printf ("## Switch baudrate to %d bps and press ESC ...\n",
+            current_baudrate);
+        udelay (50000);
+        gd->baudrate = current_baudrate;
+        serial_setbrg ();
+        udelay (50000);
+        for (;;) {
+            if (getc() == 0x1B) /* ESC */
+                break;
+        }
+    }
 #endif
-	return rcode;
+    return rcode;
 }
 
 static ulong
 load_serial (ulong offset)
 {
-	char	record[SREC_MAXRECLEN + 1];	/* buffer for one S-Record	*/
-	char	binbuf[SREC_MAXBINLEN];		/* buffer for binary data	*/
-	int	binlen;				/* no. of data bytes in S-Rec.	*/
-	int	type;				/* return code for record type	*/
-	ulong	addr;				/* load address from S-Record	*/
-	ulong	size;				/* number of bytes transferred	*/
-	char	buf[32];
-	ulong	store_addr;
-	ulong	start_addr = ~0;
-	ulong	end_addr   =  0;
-	int	line_count =  0;
-
-	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
-		type = srec_decode (record, &binlen, &addr, binbuf);
-
-		if (type < 0) {
-			return (~0);		/* Invalid S-Record		*/
-		}
-
-		switch (type) {
-		case SREC_DATA2:
-		case SREC_DATA3:
-		case SREC_DATA4:
-		    store_addr = addr + offset;
+    char    record[SREC_MAXRECLEN + 1]; /* buffer for one S-Record  */
+    char    binbuf[SREC_MAXBINLEN];     /* buffer for binary data   */
+    int binlen;             /* no. of data bytes in S-Rec.  */
+    int type;               /* return code for record type  */
+    ulong   addr;               /* load address from S-Record   */
+    ulong   size;               /* number of bytes transferred  */
+    char    buf[32];
+    ulong   store_addr;
+    ulong   start_addr = ~0;
+    ulong   end_addr   =  0;
+    int line_count =  0;
+
+    while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
+        type = srec_decode (record, &binlen, &addr, binbuf);
+
+        if (type < 0) {
+            return (~0);        /* Invalid S-Record     */
+        }
+
+        switch (type) {
+        case SREC_DATA2:
+        case SREC_DATA3:
+        case SREC_DATA4:
+            store_addr = addr + offset;
 #ifndef CFG_NO_FLASH
-		    if (addr2info(store_addr)) {
-			int rc;
+            if (addr2info(store_addr)) {
+            int rc;
 
-			rc = flash_write((char *)binbuf,store_addr,binlen);
-			if (rc != 0) {
-				flash_perror (rc);
-				return (~0);
-			}
-		    } else
+            rc = flash_write((char *)binbuf,store_addr,binlen);
+            if (rc != 0) {
+                flash_perror (rc);
+                return (~0);
+            }
+            } else
 #endif
-		    {
-			memcpy ((char *)(store_addr), binbuf, binlen);
-		    }
-		    if ((store_addr) < start_addr)
-			start_addr = store_addr;
-		    if ((store_addr + binlen - 1) > end_addr)
-			end_addr = store_addr + binlen - 1;
-		    break;
-		case SREC_END2:
-		case SREC_END3:
-		case SREC_END4:
-		    udelay (10000);
-		    size = end_addr - start_addr + 1;
-		    printf ("\n"
-			    "## First Load Addr = 0x%08lX\n"
-			    "## Last  Load Addr = 0x%08lX\n"
-			    "## Total Size      = 0x%08lX = %ld Bytes\n",
-			    start_addr, end_addr, size, size
-		    );
-		    flush_cache (start_addr, size);
-		    sprintf(buf, "%lX", size);
-		    setenv("filesize", buf);
-		    return (addr);
-		case SREC_START:
-		    break;
-		default:
-		    break;
-		}
-		if (!do_echo) {	/* print a '.' every 100 lines */
-			if ((++line_count % 100) == 0)
-				putc ('.');
-		}
-	}
+            {
+            memcpy ((char *)(store_addr), binbuf, binlen);
+            }
+            if ((store_addr) < start_addr)
+            start_addr = store_addr;
+            if ((store_addr + binlen - 1) > end_addr)
+            end_addr = store_addr + binlen - 1;
+            break;
+        case SREC_END2:
+        case SREC_END3:
+        case SREC_END4:
+            udelay (10000);
+            size = end_addr - start_addr + 1;
+            printf ("\n"
+                "## First Load Addr = 0x%08lX\n"
+                "## Last  Load Addr = 0x%08lX\n"
+                "## Total Size      = 0x%08lX = %ld Bytes\n",
+                start_addr, end_addr, size, size
+            );
+            flush_cache (start_addr, size);
+            sprintf(buf, "%lX", size);
+            setenv("filesize", buf);
+            return (addr);
+        case SREC_START:
+            break;
+        default:
+            break;
+        }
+        if (!do_echo) { /* print a '.' every 100 lines */
+            if ((++line_count % 100) == 0)
+                putc ('.');
+        }
+    }
 
-	return (~0);			/* Download aborted		*/
+    return (~0);            /* Download aborted     */
 }
 
 static int
 read_record (char *buf, ulong len)
 {
-	char *p;
-	char c;
+    char *p;
+    char c;
 
-	--len;	/* always leave room for terminating '\0' byte */
+    --len;  /* always leave room for terminating '\0' byte */
 
-	for (p=buf; p < buf+len; ++p) {
-		c = getc();		/* read character		*/
-		if (do_echo)
-			putc (c);	/* ... and echo it		*/
-
-		switch (c) {
-		case '\r':
-		case '\n':
-			*p = '\0';
-			return (p - buf);
-		case '\0':
-		case 0x03:			/* ^C - Control C		*/
-			return (-1);
-		default:
-			*p = c;
-		}
-
-	    /* Check for the console hangup (if any different from serial) */
-	    if (gd->jt[XF_getc] != getc) {
-		if (ctrlc()) {
-		    return (-1);
-		}
-	    }
-	}
-
-	/* line too long - truncate */
-	*p = '\0';
-	return (p - buf);
+    for (p=buf; p < buf+len; ++p) {
+        c = getc();     /* read character       */
+        if (do_echo)
+            putc (c);   /* ... and echo it      */
+
+        switch (c) {
+        case '\r':
+        case '\n':
+            *p = '\0';
+            return (p - buf);
+        case '\0':
+        case 0x03:          /* ^C - Control C       */
+            return (-1);
+        default:
+            *p = c;
+        }
+
+        /* Check for the console hangup (if any different from serial) */
+        if (gd->jt[XF_getc] != getc) {
+        if (ctrlc()) {
+            return (-1);
+        }
+        }
+    }
+
+    /* line too long - truncate */
+    *p = '\0';
+    return (p - buf);
 }
 
 #if (CONFIG_COMMANDS & CFG_CMD_SAVES)
 
 int do_save_serial (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	ulong offset = 0;
-	ulong size   = 0;
-#ifdef	CFG_LOADS_BAUD_CHANGE
-	int save_baudrate, current_baudrate;
+    ulong offset = 0;
+    ulong size   = 0;
+#ifdef  CFG_LOADS_BAUD_CHANGE
+    int save_baudrate, current_baudrate;
 
-	save_baudrate = current_baudrate = gd->baudrate;
+    save_baudrate = current_baudrate = gd->baudrate;
 #endif
 
-	if (argc >= 2) {
-		offset = simple_strtoul(argv[1], NULL, 16);
-	}
-#ifdef	CFG_LOADS_BAUD_CHANGE
-	if (argc >= 3) {
-		size = simple_strtoul(argv[2], NULL, 16);
-	}
-	if (argc == 4) {
-		save_baudrate = (int)simple_strtoul(argv[3], NULL, 10);
-
-		/* default to current baudrate */
-		if (save_baudrate == 0)
-			save_baudrate = current_baudrate;
-	}
-	if (save_baudrate != current_baudrate) {
-		printf ("## Switch baudrate to %d bps and press ENTER ...\n",
-			save_baudrate);
-		udelay(50000);
-		gd->baudrate = save_baudrate;
-		serial_setbrg ();
-		udelay(50000);
-		for (;;) {
-			if (getc() == '\r')
-				break;
-		}
-	}
-#else	/* ! CFG_LOADS_BAUD_CHANGE */
-	if (argc == 3) {
-		size = simple_strtoul(argv[2], NULL, 16);
-	}
-#endif	/* CFG_LOADS_BAUD_CHANGE */
-
-	printf ("## Ready for S-Record upload, press ENTER to proceed ...\n");
-	for (;;) {
-		if (getc() == '\r')
-			break;
-	}
-	if(save_serial (offset, size)) {
-		printf ("## S-Record upload aborted\n");
-	} else {
-		printf ("## S-Record upload complete\n");
-	}
-#ifdef	CFG_LOADS_BAUD_CHANGE
-	if (save_baudrate != current_baudrate) {
-		printf ("## Switch baudrate to %d bps and press ESC ...\n",
-			(int)current_baudrate);
-		udelay (50000);
-		gd->baudrate = current_baudrate;
-		serial_setbrg ();
-		udelay (50000);
-		for (;;) {
-			if (getc() == 0x1B) /* ESC */
-				break;
-		}
-	}
+    if (argc >= 2) {
+        offset = simple_strtoul(argv[1], NULL, 16);
+    }
+#ifdef  CFG_LOADS_BAUD_CHANGE
+    if (argc >= 3) {
+        size = simple_strtoul(argv[2], NULL, 16);
+    }
+    if (argc == 4) {
+        save_baudrate = (int)simple_strtoul(argv[3], NULL, 10);
+
+        /* default to current baudrate */
+        if (save_baudrate == 0)
+            save_baudrate = current_baudrate;
+    }
+    if (save_baudrate != current_baudrate) {
+        printf ("## Switch baudrate to %d bps and press ENTER ...\n",
+            save_baudrate);
+        udelay(50000);
+        gd->baudrate = save_baudrate;
+        serial_setbrg ();
+        udelay(50000);
+        for (;;) {
+            if (getc() == '\r')
+                break;
+        }
+    }
+#else   /* ! CFG_LOADS_BAUD_CHANGE */
+    if (argc == 3) {
+        size = simple_strtoul(argv[2], NULL, 16);
+    }
+#endif  /* CFG_LOADS_BAUD_CHANGE */
+
+    printf ("## Ready for S-Record upload, press ENTER to proceed ...\n");
+    for (;;) {
+        if (getc() == '\r')
+            break;
+    }
+    if(save_serial (offset, size)) {
+        printf ("## S-Record upload aborted\n");
+    } else {
+        printf ("## S-Record upload complete\n");
+    }
+#ifdef  CFG_LOADS_BAUD_CHANGE
+    if (save_baudrate != current_baudrate) {
+        printf ("## Switch baudrate to %d bps and press ESC ...\n",
+            (int)current_baudrate);
+        udelay (50000);
+        gd->baudrate = current_baudrate;
+        serial_setbrg ();
+        udelay (50000);
+        for (;;) {
+            if (getc() == 0x1B) /* ESC */
+                break;
+        }
+    }
 #endif
-	return 0;
+    return 0;
 }
 
-#define SREC3_START				"S0030000FC\n"
-#define SREC3_FORMAT			"S3%02X%08lX%s%02X\n"
-#define SREC3_END				"S70500000000FA\n"
-#define SREC_BYTES_PER_RECORD	16
+#define SREC3_START             "S0030000FC\n"
+#define SREC3_FORMAT            "S3%02X%08lX%s%02X\n"
+#define SREC3_END               "S70500000000FA\n"
+#define SREC_BYTES_PER_RECORD   16
 
 static int save_serial (ulong address, ulong count)
 {
-	int i, c, reclen, checksum, length;
-	char *hex = "0123456789ABCDEF";
-	char	record[2*SREC_BYTES_PER_RECORD+16];	/* buffer for one S-Record	*/
-	char	data[2*SREC_BYTES_PER_RECORD+1];	/* buffer for hex data	*/
-
-	reclen = 0;
-	checksum  = 0;
-
-	if(write_record(SREC3_START))			/* write the header */
-		return (-1);
-	do {
-		if(count) {						/* collect hex data in the buffer  */
-			c = *(volatile uchar*)(address + reclen);	/* get one byte    */
-			checksum += c;							/* accumulate checksum */
-			data[2*reclen]   = hex[(c>>4)&0x0f];
-			data[2*reclen+1] = hex[c & 0x0f];
-			data[2*reclen+2] = '\0';
-			++reclen;
-			--count;
-		}
-		if(reclen == SREC_BYTES_PER_RECORD || count == 0) {
-			/* enough data collected for one record: dump it */
-			if(reclen) {	/* build & write a data record: */
-				/* address + data + checksum */
-				length = 4 + reclen + 1;
-
-				/* accumulate length bytes into checksum */
-				for(i = 0; i < 2; i++)
-					checksum += (length >> (8*i)) & 0xff;
-
-				/* accumulate address bytes into checksum: */
-				for(i = 0; i < 4; i++)
-					checksum += (address >> (8*i)) & 0xff;
-
-				/* make proper checksum byte: */
-				checksum = ~checksum & 0xff;
-
-				/* output one record: */
-				sprintf(record, SREC3_FORMAT, length, address, data, checksum);
-				if(write_record(record))
-					return (-1);
-			}
-			address  += reclen;  /* increment address */
-			checksum  = 0;
-			reclen    = 0;
-		}
-	}
-	while(count);
-	if(write_record(SREC3_END))	/* write the final record */
-		return (-1);
-	return(0);
+    int i, c, reclen, checksum, length;
+    char *hex = "0123456789ABCDEF";
+    char    record[2*SREC_BYTES_PER_RECORD+16]; /* buffer for one S-Record  */
+    char    data[2*SREC_BYTES_PER_RECORD+1];    /* buffer for hex data  */
+
+    reclen = 0;
+    checksum  = 0;
+
+    if(write_record(SREC3_START))           /* write the header */
+        return (-1);
+    do {
+        if(count) {                     /* collect hex data in the buffer  */
+            c = *(volatile uchar*)(address + reclen);   /* get one byte    */
+            checksum += c;                          /* accumulate checksum */
+            data[2*reclen]   = hex[(c>>4)&0x0f];
+            data[2*reclen+1] = hex[c & 0x0f];
+            data[2*reclen+2] = '\0';
+            ++reclen;
+            --count;
+        }
+        if(reclen == SREC_BYTES_PER_RECORD || count == 0) {
+            /* enough data collected for one record: dump it */
+            if(reclen) {    /* build & write a data record: */
+                /* address + data + checksum */
+                length = 4 + reclen + 1;
+
+                /* accumulate length bytes into checksum */
+                for(i = 0; i < 2; i++)
+                    checksum += (length >> (8*i)) & 0xff;
+
+                /* accumulate address bytes into checksum: */
+                for(i = 0; i < 4; i++)
+                    checksum += (address >> (8*i)) & 0xff;
+
+                /* make proper checksum byte: */
+                checksum = ~checksum & 0xff;
+
+                /* output one record: */
+                sprintf(record, SREC3_FORMAT, length, address, data, checksum);
+                if(write_record(record))
+                    return (-1);
+            }
+            address  += reclen;  /* increment address */
+            checksum  = 0;
+            reclen    = 0;
+        }
+    }
+    while(count);
+    if(write_record(SREC3_END)) /* write the final record */
+        return (-1);
+    return(0);
 }
 
 static int
 write_record (char *buf)
 {
-	char c;
+    char c;
 
-	while((c = *buf++))
-		putc(c);
+    while((c = *buf++))
+        putc(c);
 
-	/* Check for the console hangup (if any different from serial) */
+    /* Check for the console hangup (if any different from serial) */
 
-	if (ctrlc()) {
-	    return (-1);
-	}
-	return (0);
+    if (ctrlc()) {
+        return (-1);
+    }
+    return (0);
 }
 # endif /* CFG_CMD_SAVES */
 
-#endif	/* CFG_CMD_LOADS */
+#endif  /* CFG_CMD_LOADS */
 
 
 #if (CONFIG_COMMANDS & CFG_CMD_LOADB)  /* loadb command (load binary) included */
@@ -409,7 +411,7 @@
 #define XON_CHAR        17
 #define XOFF_CHAR       19
 #define START_CHAR      0x01
-#define ETX_CHAR	0x03
+#define ETX_CHAR    0x03
 #define END_CHAR        0x0D
 #define SPACE           0x20
 #define K_ESCAPE        0x23
@@ -436,189 +438,198 @@
 
 int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	ulong offset = 0;
-	ulong addr;
-	int load_baudrate, current_baudrate;
-	int rcode = 0;
-	char *s;
-
-	/* pre-set offset from CFG_LOAD_ADDR */
-	offset = CFG_LOAD_ADDR;
-
-	/* pre-set offset from $loadaddr */
-	if ((s = getenv("loadaddr")) != NULL) {
-		offset = simple_strtoul(s, NULL, 16);
-	}
-
-	load_baudrate = current_baudrate = gd->baudrate;
-
-	if (argc >= 2) {
-		offset = simple_strtoul(argv[1], NULL, 16);
-	}
-	if (argc == 3) {
-		load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
-
-		/* default to current baudrate */
-		if (load_baudrate == 0)
-			load_baudrate = current_baudrate;
-	}
-
-	if (load_baudrate != current_baudrate) {
-		printf ("## Switch baudrate to %d bps and press ENTER ...\n",
-			load_baudrate);
-		udelay(50000);
-		gd->baudrate = load_baudrate;
-		serial_setbrg ();
-		udelay(50000);
-		for (;;) {
-			if (getc() == '\r')
-				break;
-		}
-	}
-
-	if (strcmp(argv[0],"loady")==0) {
-		printf ("## Ready for binary (ymodem) download "
-			"to 0x%08lX at %d bps...\n",
-			offset,
-			load_baudrate);
-
-		addr = load_serial_ymodem (offset);
-
-	} else {
-
-		printf ("## Ready for binary (kermit) download "
-			"to 0x%08lX at %d bps...\n",
-			offset,
-			load_baudrate);
-		addr = load_serial_bin (offset);
-
-		if (addr == ~0) {
-			load_addr = 0;
-			printf ("## Binary (kermit) download aborted\n");
-			rcode = 1;
-		} else {
-			printf ("## Start Addr      = 0x%08lX\n", addr);
-			load_addr = addr;
-		}
-	}
-	if (load_baudrate != current_baudrate) {
-		printf ("## Switch baudrate to %d bps and press ESC ...\n",
-			current_baudrate);
-		udelay (50000);
-		gd->baudrate = current_baudrate;
-		serial_setbrg ();
-		udelay (50000);
-		for (;;) {
-			if (getc() == 0x1B) /* ESC */
-				break;
-		}
-	}
+    ulong offset = 0;
+    ulong addr;
+    int load_baudrate, current_baudrate;
+    int rcode = 0;
+    char *s;
+
+    /* pre-set offset from CFG_LOAD_ADDR */
+    offset = CFG_LOAD_ADDR;
+
+    /* pre-set offset from $loadaddr */
+    if ((s = getenv("loadaddr")) != NULL) {
+        offset = simple_strtoul(s, NULL, 16);
+    }
+
+    load_baudrate = current_baudrate = gd->baudrate;
+
+    if (argc >= 2) {
+        offset = simple_strtoul(argv[1], NULL, 16);
+    }
+    if (argc == 3) {
+        load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
+
+        /* default to current baudrate */
+        if (load_baudrate == 0)
+            load_baudrate = current_baudrate;
+    }
+
+    if (load_baudrate != current_baudrate) {
+        printf ("## Switch baudrate to %d bps and press ENTER ...\n",
+            load_baudrate);
+        udelay(50000);
+        gd->baudrate = load_baudrate;
+        serial_setbrg ();
+        udelay(50000);
+        for (;;) {
+            if (getc() == '\r')
+                break;
+        }
+    }
+
+    /* support xmodem, www.100ask.net */
+    if (strcmp(argv[0],"loadx")==0) {
+        printf ("## Ready for binary (xmodem) download "
+            "to 0x%08lX at %d bps...\n",
+            offset,
+            load_baudrate);
+
+        addr = load_serial_xmodem (offset);
+
+    } else if (strcmp(argv[0],"loady")==0) {
+        printf ("## Ready for binary (ymodem) download "
+            "to 0x%08lX at %d bps...\n",
+            offset,
+            load_baudrate);
+
+        addr = load_serial_ymodem (offset);
+
+    } else {
+
+        printf ("## Ready for binary (kermit) download "
+            "to 0x%08lX at %d bps...\n",
+            offset,
+            load_baudrate);
+        addr = load_serial_bin (offset);
+
+        if (addr == ~0) {
+            load_addr = 0;
+            printf ("## Binary (kermit) download aborted\n");
+            rcode = 1;
+        } else {
+            printf ("## Start Addr      = 0x%08lX\n", addr);
+            load_addr = addr;
+        }
+    }
+    if (load_baudrate != current_baudrate) {
+        printf ("## Switch baudrate to %d bps and press ESC ...\n",
+            current_baudrate);
+        udelay (50000);
+        gd->baudrate = current_baudrate;
+        serial_setbrg ();
+        udelay (50000);
+        for (;;) {
+            if (getc() == 0x1B) /* ESC */
+                break;
+        }
+    }
 
 #ifdef CONFIG_AUTOSCRIPT
-	if (load_addr) {
-		char *s;
+    if (load_addr) {
+        char *s;
 
-		if (((s = getenv("autoscript")) != NULL) && (strcmp(s,"yes") == 0)) {
-			printf("Running autoscript at addr 0x%08lX ...\n", load_addr);
-			rcode = autoscript (load_addr);
-		}
-	}
+        if (((s = getenv("autoscript")) != NULL) && (strcmp(s,"yes") == 0)) {
+            printf("Running autoscript at addr 0x%08lX ...\n", load_addr);
+            rcode = autoscript (load_addr);
+        }
+    }
 #endif
-	return rcode;
+    return rcode;
 }
 
 
 static ulong load_serial_bin (ulong offset)
 {
-	int size, i;
-	char buf[32];
+    int size, i;
+    char buf[32];
 
-	set_kerm_bin_mode ((ulong *) offset);
-	size = k_recv ();
+    set_kerm_bin_mode ((ulong *) offset);
+    size = k_recv ();
 
-	/*
-	 * Gather any trailing characters (for instance, the ^D which
-	 * is sent by 'cu' after sending a file), and give the
-	 * box some time (100 * 1 ms)
-	 */
-	for (i=0; i<100; ++i) {
-		if (tstc()) {
-			(void) getc();
-		}
-		udelay(1000);
-	}
-
-	flush_cache (offset, size);
-
-	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
-	sprintf(buf, "%X", size);
-	setenv("filesize", buf);
+    /*
+     * Gather any trailing characters (for instance, the ^D which
+     * is sent by 'cu' after sending a file), and give the
+     * box some time (100 * 1 ms)
+     */
+    for (i=0; i<100; ++i) {
+        if (tstc()) {
+            (void) getc();
+        }
+        udelay(1000);
+    }
+
+    flush_cache (offset, size);
+
+    printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
+    sprintf(buf, "%X", size);
+    setenv("filesize", buf);
 
-	return offset;
+    return offset;
 }
 
 void send_pad (void)
 {
-	int count = his_pad_count;
+    int count = his_pad_count;
 
-	while (count-- > 0)
-		putc (his_pad_char);
+    while (count-- > 0)
+        putc (his_pad_char);
 }
 
 /* converts escaped kermit char to binary char */
 char ktrans (char in)
 {
-	if ((in & 0x60) == 0x40) {
-		return (char) (in & ~0x40);
-	} else if ((in & 0x7f) == 0x3f) {
-		return (char) (in | 0x40);
-	} else
-		return in;
+    if ((in & 0x60) == 0x40) {
+        return (char) (in & ~0x40);
+    } else if ((in & 0x7f) == 0x3f) {
+        return (char) (in | 0x40);
+    } else
+        return in;
 }
 
 int chk1 (char *buffer)
 {
-	int total = 0;
+    int total = 0;
 
-	while (*buffer) {
-		total += *buffer++;
-	}
-	return (int) ((total + ((total >> 6) & 0x03)) & 0x3f);
+    while (*buffer) {
+        total += *buffer++;
+    }
+    return (int) ((total + ((total >> 6) & 0x03)) & 0x3f);
 }
 
 void s1_sendpacket (char *packet)
 {
-	send_pad ();
-	while (*packet) {
-		putc (*packet++);
-	}
+    send_pad ();
+    while (*packet) {
+        putc (*packet++);
+    }
 }
 
 static char a_b[24];
 void send_ack (int n)
 {
-	a_b[0] = START_CHAR;
-	a_b[1] = tochar (3);
-	a_b[2] = tochar (n);
-	a_b[3] = ACK_TYPE;
-	a_b[4] = '\0';
-	a_b[4] = tochar (chk1 (&a_b[1]));
-	a_b[5] = his_eol;
-	a_b[6] = '\0';
-	s1_sendpacket (a_b);
+    a_b[0] = START_CHAR;
+    a_b[1] = tochar (3);
+    a_b[2] = tochar (n);
+    a_b[3] = ACK_TYPE;
+    a_b[4] = '\0';
+    a_b[4] = tochar (chk1 (&a_b[1]));
+    a_b[5] = his_eol;
+    a_b[6] = '\0';
+    s1_sendpacket (a_b);
 }
 
 void send_nack (int n)
 {
-	a_b[0] = START_CHAR;
-	a_b[1] = tochar (3);
-	a_b[2] = tochar (n);
-	a_b[3] = NACK_TYPE;
-	a_b[4] = '\0';
-	a_b[4] = tochar (chk1 (&a_b[1]));
-	a_b[5] = his_eol;
-	a_b[6] = '\0';
-	s1_sendpacket (a_b);
+    a_b[0] = START_CHAR;
+    a_b[1] = tochar (3);
+    a_b[2] = tochar (n);
+    a_b[3] = NACK_TYPE;
+    a_b[4] = '\0';
+    a_b[4] = tochar (chk1 (&a_b[1]));
+    a_b[5] = his_eol;
+    a_b[6] = '\0';
+    s1_sendpacket (a_b);
 }
 
 
@@ -637,36 +648,36 @@
 int os_data_header[8];
 static void bin_data_init (void)
 {
-	os_data_state = 0;
-	os_data_count = 0;
-	os_data_addr = bin_start_address;
+    os_data_state = 0;
+    os_data_count = 0;
+    os_data_addr = bin_start_address;
 }
 static void os_data_save (void)
 {
-	os_data_state_saved = os_data_state;
-	os_data_count_saved = os_data_count;
-	os_data_addr_saved = os_data_addr;
+    os_data_state_saved = os_data_state;
+    os_data_count_saved = os_data_count;
+    os_data_addr_saved = os_data_addr;
 }
 static void os_data_restore (void)
 {
-	os_data_state = os_data_state_saved;
-	os_data_count = os_data_count_saved;
-	os_data_addr = os_data_addr_saved;
+    os_data_state = os_data_state_saved;
+    os_data_count = os_data_count_saved;
+    os_data_addr = os_data_addr_saved;
 }
 static void bin_data_char (char new_char)
 {
-	switch (os_data_state) {
-	case 0:					/* data */
-		*os_data_addr++ = new_char;
-		--os_data_count;
-		break;
-	}
+    switch (os_data_state) {
+    case 0:                 /* data */
+        *os_data_addr++ = new_char;
+        --os_data_count;
+        break;
+    }
 }
 static void set_kerm_bin_mode (unsigned long *addr)
 {
-	bin_start_address = (char *) addr;
-	os_data_init = bin_data_init;
-	os_data_char = bin_data_char;
+    bin_start_address = (char *) addr;
+    os_data_init = bin_data_init;
+    os_data_char = bin_data_char;
 }
 
 
@@ -674,34 +685,34 @@
 static int k_data_escape, k_data_escape_saved;
 void k_data_init (void)
 {
-	k_data_escape = 0;
-	os_data_init ();
+    k_data_escape = 0;
+    os_data_init ();
 }
 void k_data_save (void)
 {
-	k_data_escape_saved = k_data_escape;
-	os_data_save ();
+    k_data_escape_saved = k_data_escape;
+    os_data_save ();
 }
 void k_data_restore (void)
 {
-	k_data_escape = k_data_escape_saved;
-	os_data_restore ();
+    k_data_escape = k_data_escape_saved;
+    os_data_restore ();
 }
 void k_data_char (char new_char)
 {
-	if (k_data_escape) {
-		/* last char was escape - translate this character */
-		os_data_char (ktrans (new_char));
-		k_data_escape = 0;
-	} else {
-		if (new_char == his_quote) {
-			/* this char is escape - remember */
-			k_data_escape = 1;
-		} else {
-			/* otherwise send this char as-is */
-			os_data_char (new_char);
-		}
-	}
+    if (k_data_escape) {
+        /* last char was escape - translate this character */
+        os_data_char (ktrans (new_char));
+        k_data_escape = 0;
+    } else {
+        if (new_char == his_quote) {
+            /* this char is escape - remember */
+            k_data_escape = 1;
+        } else {
+            /* otherwise send this char as-is */
+            os_data_char (new_char);
+        }
+    }
 }
 
 #define SEND_DATA_SIZE  20
@@ -712,353 +723,411 @@
    sends an appropriate ack for what we can do */
 void handle_send_packet (int n)
 {
-	int length = 3;
-	int bytes;
+    int length = 3;
+    int bytes;
 
-	/* initialize some protocol parameters */
-	his_eol = END_CHAR;		/* default end of line character */
-	his_pad_count = 0;
-	his_pad_char = '\0';
-	his_quote = K_ESCAPE;
-
-	/* ignore last character if it filled the buffer */
-	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
-		--send_ptr;
-	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
-	do {
-		if (bytes-- <= 0)
-			break;
-		/* handle MAXL - max length */
-		/* ignore what he says - most I'll take (here) is 94 */
-		a_b[++length] = tochar (94);
-		if (bytes-- <= 0)
-			break;
-		/* handle TIME - time you should wait for my packets */
-		/* ignore what he says - don't wait for my ack longer than 1 second */
-		a_b[++length] = tochar (1);
-		if (bytes-- <= 0)
-			break;
-		/* handle NPAD - number of pad chars I need */
-		/* remember what he says - I need none */
-		his_pad_count = untochar (send_parms[2]);
-		a_b[++length] = tochar (0);
-		if (bytes-- <= 0)
-			break;
-		/* handle PADC - pad chars I need */
-		/* remember what he says - I need none */
-		his_pad_char = ktrans (send_parms[3]);
-		a_b[++length] = 0x40;	/* He should ignore this */
-		if (bytes-- <= 0)
-			break;
-		/* handle EOL - end of line he needs */
-		/* remember what he says - I need CR */
-		his_eol = untochar (send_parms[4]);
-		a_b[++length] = tochar (END_CHAR);
-		if (bytes-- <= 0)
-			break;
-		/* handle QCTL - quote control char he'll use */
-		/* remember what he says - I'll use '#' */
-		his_quote = send_parms[5];
-		a_b[++length] = '#';
-		if (bytes-- <= 0)
-			break;
-		/* handle QBIN - 8-th bit prefixing */
-		/* ignore what he says - I refuse */
-		a_b[++length] = 'N';
-		if (bytes-- <= 0)
-			break;
-		/* handle CHKT - the clock check type */
-		/* ignore what he says - I do type 1 (for now) */
-		a_b[++length] = '1';
-		if (bytes-- <= 0)
-			break;
-		/* handle REPT - the repeat prefix */
-		/* ignore what he says - I refuse (for now) */
-		a_b[++length] = 'N';
-		if (bytes-- <= 0)
-			break;
-		/* handle CAPAS - the capabilities mask */
-		/* ignore what he says - I only do long packets - I don't do windows */
-		a_b[++length] = tochar (2);	/* only long packets */
-		a_b[++length] = tochar (0);	/* no windows */
-		a_b[++length] = tochar (94);	/* large packet msb */
-		a_b[++length] = tochar (94);	/* large packet lsb */
-	} while (0);
-
-	a_b[0] = START_CHAR;
-	a_b[1] = tochar (length);
-	a_b[2] = tochar (n);
-	a_b[3] = ACK_TYPE;
-	a_b[++length] = '\0';
-	a_b[length] = tochar (chk1 (&a_b[1]));
-	a_b[++length] = his_eol;
-	a_b[++length] = '\0';
-	s1_sendpacket (a_b);
+    /* initialize some protocol parameters */
+    his_eol = END_CHAR;     /* default end of line character */
+    his_pad_count = 0;
+    his_pad_char = '\0';
+    his_quote = K_ESCAPE;
+
+    /* ignore last character if it filled the buffer */
+    if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
+        --send_ptr;
+    bytes = send_ptr - send_parms;  /* how many bytes we'll process */
+    do {
+        if (bytes-- <= 0)
+            break;
+        /* handle MAXL - max length */
+        /* ignore what he says - most I'll take (here) is 94 */
+        a_b[++length] = tochar (94);
+        if (bytes-- <= 0)
+            break;
+        /* handle TIME - time you should wait for my packets */
+        /* ignore what he says - don't wait for my ack longer than 1 second */
+        a_b[++length] = tochar (1);
+        if (bytes-- <= 0)
+            break;
+        /* handle NPAD - number of pad chars I need */
+        /* remember what he says - I need none */
+        his_pad_count = untochar (send_parms[2]);
+        a_b[++length] = tochar (0);
+        if (bytes-- <= 0)
+            break;
+        /* handle PADC - pad chars I need */
+        /* remember what he says - I need none */
+        his_pad_char = ktrans (send_parms[3]);
+        a_b[++length] = 0x40;   /* He should ignore this */
+        if (bytes-- <= 0)
+            break;
+        /* handle EOL - end of line he needs */
+        /* remember what he says - I need CR */
+        his_eol = untochar (send_parms[4]);
+        a_b[++length] = tochar (END_CHAR);
+        if (bytes-- <= 0)
+            break;
+        /* handle QCTL - quote control char he'll use */
+        /* remember what he says - I'll use '#' */
+        his_quote = send_parms[5];
+        a_b[++length] = '#';
+        if (bytes-- <= 0)
+            break;
+        /* handle QBIN - 8-th bit prefixing */
+        /* ignore what he says - I refuse */
+        a_b[++length] = 'N';
+        if (bytes-- <= 0)
+            break;
+        /* handle CHKT - the clock check type */
+        /* ignore what he says - I do type 1 (for now) */
+        a_b[++length] = '1';
+        if (bytes-- <= 0)
+            break;
+        /* handle REPT - the repeat prefix */
+        /* ignore what he says - I refuse (for now) */
+        a_b[++length] = 'N';
+        if (bytes-- <= 0)
+            break;
+        /* handle CAPAS - the capabilities mask */
+        /* ignore what he says - I only do long packets - I don't do windows */
+        a_b[++length] = tochar (2); /* only long packets */
+        a_b[++length] = tochar (0); /* no windows */
+        a_b[++length] = tochar (94);    /* large packet msb */
+        a_b[++length] = tochar (94);    /* large packet lsb */
+    } while (0);
+
+    a_b[0] = START_CHAR;
+    a_b[1] = tochar (length);
+    a_b[2] = tochar (n);
+    a_b[3] = ACK_TYPE;
+    a_b[++length] = '\0';
+    a_b[length] = tochar (chk1 (&a_b[1]));
+    a_b[++length] = his_eol;
+    a_b[++length] = '\0';
+    s1_sendpacket (a_b);
 }
 
 /* k_recv receives a OS Open image file over kermit line */
 static int k_recv (void)
 {
-	char new_char;
-	char k_state, k_state_saved;
-	int sum;
-	int done;
-	int length;
-	int n, last_n;
-	int z = 0;
-	int len_lo, len_hi;
-
-	/* initialize some protocol parameters */
-	his_eol = END_CHAR;		/* default end of line character */
-	his_pad_count = 0;
-	his_pad_char = '\0';
-	his_quote = K_ESCAPE;
-
-	/* initialize the k_recv and k_data state machine */
-	done = 0;
-	k_state = 0;
-	k_data_init ();
-	k_state_saved = k_state;
-	k_data_save ();
-	n = 0;				/* just to get rid of a warning */
-	last_n = -1;
-
-	/* expect this "type" sequence (but don't check):
-	   S: send initiate
-	   F: file header
-	   D: data (multiple)
-	   Z: end of file
-	   B: break transmission
-	 */
-
-	/* enter main loop */
-	while (!done) {
-		/* set the send packet pointer to begining of send packet parms */
-		send_ptr = send_parms;
-
-		/* With each packet, start summing the bytes starting with the length.
-		   Save the current sequence number.
-		   Note the type of the packet.
-		   If a character less than SPACE (0x20) is received - error.
-		 */
+    char new_char;
+    char k_state, k_state_saved;
+    int sum;
+    int done;
+    int length;
+    int n, last_n;
+    int z = 0;
+    int len_lo, len_hi;
+
+    /* initialize some protocol parameters */
+    his_eol = END_CHAR;     /* default end of line character */
+    his_pad_count = 0;
+    his_pad_char = '\0';
+    his_quote = K_ESCAPE;
+
+    /* initialize the k_recv and k_data state machine */
+    done = 0;
+    k_state = 0;
+    k_data_init ();
+    k_state_saved = k_state;
+    k_data_save ();
+    n = 0;              /* just to get rid of a warning */
+    last_n = -1;
+
+    /* expect this "type" sequence (but don't check):
+       S: send initiate
+       F: file header
+       D: data (multiple)
+       Z: end of file
+       B: break transmission
+     */
+
+    /* enter main loop */
+    while (!done) {
+        /* set the send packet pointer to begining of send packet parms */
+        send_ptr = send_parms;
+
+        /* With each packet, start summing the bytes starting with the length.
+           Save the current sequence number.
+           Note the type of the packet.
+           If a character less than SPACE (0x20) is received - error.
+         */
 
 #if 0
-		/* OLD CODE, Prior to checking sequence numbers */
-		/* first have all state machines save current states */
-		k_state_saved = k_state;
-		k_data_save ();
+        /* OLD CODE, Prior to checking sequence numbers */
+        /* first have all state machines save current states */
+        k_state_saved = k_state;
+        k_data_save ();
 #endif
 
-		/* get a packet */
-		/* wait for the starting character or ^C */
-		for (;;) {
-			switch (getc ()) {
-			case START_CHAR:	/* start packet */
-				goto START;
-			case ETX_CHAR:		/* ^C waiting for packet */
-				return (0);
-			default:
-				;
-			}
-		}
+        /* get a packet */
+        /* wait for the starting character or ^C */
+        for (;;) {
+            switch (getc ()) {
+            case START_CHAR:    /* start packet */
+                goto START;
+            case ETX_CHAR:      /* ^C waiting for packet */
+                return (0);
+            default:
+                ;
+            }
+        }
 START:
-		/* get length of packet */
-		sum = 0;
-		new_char = getc ();
-		if ((new_char & 0xE0) == 0)
-			goto packet_error;
-		sum += new_char & 0xff;
-		length = untochar (new_char);
-		/* get sequence number */
-		new_char = getc ();
-		if ((new_char & 0xE0) == 0)
-			goto packet_error;
-		sum += new_char & 0xff;
-		n = untochar (new_char);
-		--length;
-
-		/* NEW CODE - check sequence numbers for retried packets */
-		/* Note - this new code assumes that the sequence number is correctly
-		 * received.  Handling an invalid sequence number adds another layer
-		 * of complexity that may not be needed - yet!  At this time, I'm hoping
-		 * that I don't need to buffer the incoming data packets and can write
-		 * the data into memory in real time.
-		 */
-		if (n == last_n) {
-			/* same sequence number, restore the previous state */
-			k_state = k_state_saved;
-			k_data_restore ();
-		} else {
-			/* new sequence number, checkpoint the download */
-			last_n = n;
-			k_state_saved = k_state;
-			k_data_save ();
-		}
-		/* END NEW CODE */
-
-		/* get packet type */
-		new_char = getc ();
-		if ((new_char & 0xE0) == 0)
-			goto packet_error;
-		sum += new_char & 0xff;
-		k_state = new_char;
-		--length;
-		/* check for extended length */
-		if (length == -2) {
-			/* (length byte was 0, decremented twice) */
-			/* get the two length bytes */
-			new_char = getc ();
-			if ((new_char & 0xE0) == 0)
-				goto packet_error;
-			sum += new_char & 0xff;
-			len_hi = untochar (new_char);
-			new_char = getc ();
-			if ((new_char & 0xE0) == 0)
-				goto packet_error;
-			sum += new_char & 0xff;
-			len_lo = untochar (new_char);
-			length = len_hi * 95 + len_lo;
-			/* check header checksum */
-			new_char = getc ();
-			if ((new_char & 0xE0) == 0)
-				goto packet_error;
-			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
-				goto packet_error;
-			sum += new_char & 0xff;
+        /* get length of packet */
+        sum = 0;
+        new_char = getc ();
+        if ((new_char & 0xE0) == 0)
+            goto packet_error;
+        sum += new_char & 0xff;
+        length = untochar (new_char);
+        /* get sequence number */
+        new_char = getc ();
+        if ((new_char & 0xE0) == 0)
+            goto packet_error;
+        sum += new_char & 0xff;
+        n = untochar (new_char);
+        --length;
+
+        /* NEW CODE - check sequence numbers for retried packets */
+        /* Note - this new code assumes that the sequence number is correctly
+         * received.  Handling an invalid sequence number adds another layer
+         * of complexity that may not be needed - yet!  At this time, I'm hoping
+         * that I don't need to buffer the incoming data packets and can write
+         * the data into memory in real time.
+         */
+        if (n == last_n) {
+            /* same sequence number, restore the previous state */
+            k_state = k_state_saved;
+            k_data_restore ();
+        } else {
+            /* new sequence number, checkpoint the download */
+            last_n = n;
+            k_state_saved = k_state;
+            k_data_save ();
+        }
+        /* END NEW CODE */
+
+        /* get packet type */
+        new_char = getc ();
+        if ((new_char & 0xE0) == 0)
+            goto packet_error;
+        sum += new_char & 0xff;
+        k_state = new_char;
+        --length;
+        /* check for extended length */
+        if (length == -2) {
+            /* (length byte was 0, decremented twice) */
+            /* get the two length bytes */
+            new_char = getc ();
+            if ((new_char & 0xE0) == 0)
+                goto packet_error;
+            sum += new_char & 0xff;
+            len_hi = untochar (new_char);
+            new_char = getc ();
+            if ((new_char & 0xE0) == 0)
+                goto packet_error;
+            sum += new_char & 0xff;
+            len_lo = untochar (new_char);
+            length = len_hi * 95 + len_lo;
+            /* check header checksum */
+            new_char = getc ();
+            if ((new_char & 0xE0) == 0)
+                goto packet_error;
+            if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
+                goto packet_error;
+            sum += new_char & 0xff;
 /* --length; */ /* new length includes only data and block check to come */
-		}
-		/* bring in rest of packet */
-		while (length > 1) {
-			new_char = getc ();
-			if ((new_char & 0xE0) == 0)
-				goto packet_error;
-			sum += new_char & 0xff;
-			--length;
-			if (k_state == DATA_TYPE) {
-				/* pass on the data if this is a data packet */
-				k_data_char (new_char);
-			} else if (k_state == SEND_TYPE) {
-				/* save send pack in buffer as is */
-				*send_ptr++ = new_char;
-				/* if too much data, back off the pointer */
-				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
-					--send_ptr;
-			}
-		}
-		/* get and validate checksum character */
-		new_char = getc ();
-		if ((new_char & 0xE0) == 0)
-			goto packet_error;
-		if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
-			goto packet_error;
-		/* get END_CHAR */
-		new_char = getc ();
-		if (new_char != END_CHAR) {
-		  packet_error:
-			/* restore state machines */
-			k_state = k_state_saved;
-			k_data_restore ();
-			/* send a negative acknowledge packet in */
-			send_nack (n);
-		} else if (k_state == SEND_TYPE) {
-			/* crack the protocol parms, build an appropriate ack packet */
-			handle_send_packet (n);
-		} else {
-			/* send simple acknowledge packet in */
-			send_ack (n);
-			/* quit if end of transmission */
-			if (k_state == BREAK_TYPE)
-				done = 1;
-		}
-		++z;
-	}
-	return ((ulong) os_data_addr - (ulong) bin_start_address);
+        }
+        /* bring in rest of packet */
+        while (length > 1) {
+            new_char = getc ();
+            if ((new_char & 0xE0) == 0)
+                goto packet_error;
+            sum += new_char & 0xff;
+            --length;
+            if (k_state == DATA_TYPE) {
+                /* pass on the data if this is a data packet */
+                k_data_char (new_char);
+            } else if (k_state == SEND_TYPE) {
+                /* save send pack in buffer as is */
+                *send_ptr++ = new_char;
+                /* if too much data, back off the pointer */
+                if (send_ptr >= &send_parms[SEND_DATA_SIZE])
+                    --send_ptr;
+            }
+        }
+        /* get and validate checksum character */
+        new_char = getc ();
+        if ((new_char & 0xE0) == 0)
+            goto packet_error;
+        if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
+            goto packet_error;
+        /* get END_CHAR */
+        new_char = getc ();
+        if (new_char != END_CHAR) {
+          packet_error:
+            /* restore state machines */
+            k_state = k_state_saved;
+            k_data_restore ();
+            /* send a negative acknowledge packet in */
+            send_nack (n);
+        } else if (k_state == SEND_TYPE) {
+            /* crack the protocol parms, build an appropriate ack packet */
+            handle_send_packet (n);
+        } else {
+            /* send simple acknowledge packet in */
+            send_ack (n);
+            /* quit if end of transmission */
+            if (k_state == BREAK_TYPE)
+                done = 1;
+        }
+        ++z;
+    }
+    return ((ulong) os_data_addr - (ulong) bin_start_address);
 }
 
 static int getcxmodem(void) {
-	if (tstc())
-		return (getc());
-	return -1;
+    if (tstc())
+        return (getc());
+    return -1;
+}
+
+/* support xmodem, www.100ask.net */
+static ulong load_serial_xmodem (ulong offset)
+{
+    int size;
+    char buf[32];
+    int err;
+    int res;
+    connection_info_t info;
+    char xmodemBuf[1024];
+    ulong store_addr = ~0;
+    ulong addr = 0;
+
+    size = 0;
+    info.mode = xyzModem_xmodem;
+    res = xyzModem_stream_open (&info, &err);
+    if (!res) {
+
+        while ((res =
+            xyzModem_stream_read (xmodemBuf, 1024, &err)) > 0) {
+            store_addr = addr + offset;
+            size += res;
+            addr += res;
+#ifndef CFG_NO_FLASH
+            if (addr2info (store_addr)) {
+                int rc;
+
+                rc = flash_write ((char *) xmodemBuf,
+                          store_addr, res);
+                if (rc != 0) {
+                    flash_perror (rc);
+                    return (~0);
+                }
+            } else
+#endif
+            {
+                memcpy ((char *) (store_addr), xmodemBuf,
+                    res);
+            }
+
+        }
+    } else {
+        printf ("%s\n", xyzModem_error (err));
+    }
+
+    xyzModem_stream_close (&err);
+    xyzModem_stream_terminate (false, &getcxmodem);
+
+
+    flush_cache (offset, size);
+
+    printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
+    sprintf (buf, "%X", size);
+    setenv ("filesize", buf);
+
+    return offset;
 }
+
 static ulong load_serial_ymodem (ulong offset)
 {
-	int size;
-	char buf[32];
-	int err;
-	int res;
-	connection_info_t info;
-	char ymodemBuf[1024];
-	ulong store_addr = ~0;
-	ulong addr = 0;
-
-	size = 0;
-	info.mode = xyzModem_ymodem;
-	res = xyzModem_stream_open (&info, &err);
-	if (!res) {
-
-		while ((res =
-			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
-			store_addr = addr + offset;
-			size += res;
-			addr += res;
+    int size;
+    char buf[32];
+    int err;
+    int res;
+    connection_info_t info;
+    char ymodemBuf[1024];
+    ulong store_addr = ~0;
+    ulong addr = 0;
+
+    size = 0;
+    info.mode = xyzModem_ymodem;
+    res = xyzModem_stream_open (&info, &err);
+    if (!res) {
+
+        while ((res =
+            xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
+            store_addr = addr + offset;
+            size += res;
+            addr += res;
 #ifndef CFG_NO_FLASH
-			if (addr2info (store_addr)) {
-				int rc;
+            if (addr2info (store_addr)) {
+                int rc;
 
-				rc = flash_write ((char *) ymodemBuf,
-						  store_addr, res);
-				if (rc != 0) {
-					flash_perror (rc);
-					return (~0);
-				}
-			} else
+                rc = flash_write ((char *) ymodemBuf,
+                          store_addr, res);
+                if (rc != 0) {
+                    flash_perror (rc);
+                    return (~0);
+                }
+            } else
 #endif
-			{
-				memcpy ((char *) (store_addr), ymodemBuf,
-					res);
-			}
+            {
+                memcpy ((char *) (store_addr), ymodemBuf,
+                    res);
+            }
 
-		}
-	} else {
-		printf ("%s\n", xyzModem_error (err));
-	}
+        }
+    } else {
+        printf ("%s\n", xyzModem_error (err));
+    }
 
-	xyzModem_stream_close (&err);
-	xyzModem_stream_terminate (false, &getcxmodem);
+    xyzModem_stream_close (&err);
+    xyzModem_stream_terminate (false, &getcxmodem);
 
 
-	flush_cache (offset, size);
+    flush_cache (offset, size);
 
-	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
-	sprintf (buf, "%X", size);
-	setenv ("filesize", buf);
+    printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
+    sprintf (buf, "%X", size);
+    setenv ("filesize", buf);
 
-	return offset;
+    return offset;
 }
 
-#endif	/* CFG_CMD_LOADB */
+#endif  /* CFG_CMD_LOADB */
 
 /* -------------------------------------------------------------------- */
 
 #if (CONFIG_COMMANDS & CFG_CMD_LOADS)
 
-#ifdef	CFG_LOADS_BAUD_CHANGE
+#ifdef  CFG_LOADS_BAUD_CHANGE
 U_BOOT_CMD(
-	loads, 3, 0,	do_load_serial,
-	"loads   - load S-Record file over serial line\n",
-	"[ off ] [ baud ]\n"
-	"    - load S-Record file over serial line"
-	" with offset 'off' and baudrate 'baud'\n"
+    loads, 3, 0,    do_load_serial,
+    "loads   - load S-Record file over serial line\n",
+    "[ off ] [ baud ]\n"
+    "    - load S-Record file over serial line"
+    " with offset 'off' and baudrate 'baud'\n"
 );
 
-#else	/* ! CFG_LOADS_BAUD_CHANGE */
+#else   /* ! CFG_LOADS_BAUD_CHANGE */
 U_BOOT_CMD(
-	loads, 2, 0,	do_load_serial,
-	"loads   - load S-Record file over serial line\n",
-	"[ off ]\n"
-	"    - load S-Record file over serial line with offset 'off'\n"
+    loads, 2, 0,    do_load_serial,
+    "loads   - load S-Record file over serial line\n",
+    "[ off ]\n"
+    "    - load S-Record file over serial line with offset 'off'\n"
 );
-#endif	/* CFG_LOADS_BAUD_CHANGE */
+#endif  /* CFG_LOADS_BAUD_CHANGE */
 
 /*
  * SAVES always requires LOADS support, but not vice versa
@@ -1066,71 +1135,80 @@
 
 
 #if (CONFIG_COMMANDS & CFG_CMD_SAVES)
-#ifdef	CFG_LOADS_BAUD_CHANGE
+#ifdef  CFG_LOADS_BAUD_CHANGE
 U_BOOT_CMD(
-	saves, 4, 0,	do_save_serial,
-	"saves   - save S-Record file over serial line\n",
-	"[ off ] [size] [ baud ]\n"
-	"    - save S-Record file over serial line"
-	" with offset 'off', size 'size' and baudrate 'baud'\n"
+    saves, 4, 0,    do_save_serial,
+    "saves   - save S-Record file over serial line\n",
+    "[ off ] [size] [ baud ]\n"
+    "    - save S-Record file over serial line"
+    " with offset 'off', size 'size' and baudrate 'baud'\n"
 );
-#else	/* ! CFG_LOADS_BAUD_CHANGE */
+#else   /* ! CFG_LOADS_BAUD_CHANGE */
 U_BOOT_CMD(
-	saves, 3, 0,	do_save_serial,
-	"saves   - save S-Record file over serial line\n",
-	"[ off ] [size]\n"
-	"    - save S-Record file over serial line with offset 'off' and size 'size'\n"
+    saves, 3, 0,    do_save_serial,
+    "saves   - save S-Record file over serial line\n",
+    "[ off ] [size]\n"
+    "    - save S-Record file over serial line with offset 'off' and size 'size'\n"
 );
-#endif	/* CFG_LOADS_BAUD_CHANGE */
-#endif	/* CFG_CMD_SAVES */
-#endif	/* CFG_CMD_LOADS */
+#endif  /* CFG_LOADS_BAUD_CHANGE */
+#endif  /* CFG_CMD_SAVES */
+#endif  /* CFG_CMD_LOADS */
 
 
 #if (CONFIG_COMMANDS & CFG_CMD_LOADB)
 U_BOOT_CMD(
-	loadb, 3, 0,	do_load_serial_bin,
-	"loadb   - load binary file over serial line (kermit mode)\n",
-	"[ off ] [ baud ]\n"
-	"    - load binary file over serial line"
-	" with offset 'off' and baudrate 'baud'\n"
+    loadb, 3, 0,    do_load_serial_bin,
+    "loadb   - load binary file over serial line (kermit mode)\n",
+    "[ off ] [ baud ]\n"
+    "    - load binary file over serial line"
+    " with offset 'off' and baudrate 'baud'\n"
+);
+
+/* support xmodem, www.100ask.net */
+U_BOOT_CMD(
+    loadx, 3, 0,    do_load_serial_bin,
+    "loadx   - load binary file over serial line (xmodem mode)\n",
+    "[ off ] [ baud ]\n"
+    "    - load binary file over serial line"
+    " with offset 'off' and baudrate 'baud'\n"
 );
 
 U_BOOT_CMD(
-	loady, 3, 0,	do_load_serial_bin,
-	"loady   - load binary file over serial line (ymodem mode)\n",
-	"[ off ] [ baud ]\n"
-	"    - load binary file over serial line"
-	" with offset 'off' and baudrate 'baud'\n"
+    loady, 3, 0,    do_load_serial_bin,
+    "loady   - load binary file over serial line (ymodem mode)\n",
+    "[ off ] [ baud ]\n"
+    "    - load binary file over serial line"
+    " with offset 'off' and baudrate 'baud'\n"
 );
 
-#endif	/* CFG_CMD_LOADB */
+#endif  /* CFG_CMD_LOADB */
 
 /* -------------------------------------------------------------------- */
 
 #if (CONFIG_COMMANDS & CFG_CMD_HWFLOW)
 int do_hwflow (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	extern int hwflow_onoff(int);
+    extern int hwflow_onoff(int);
 
-	if (argc == 2) {
-		if (strcmp(argv[1], "off") == 0)
-			hwflow_onoff(-1);
-		else
-			if (strcmp(argv[1], "on") == 0)
-				hwflow_onoff(1);
-			else
-				printf("Usage: %s\n", cmdtp->usage);
-	}
-	printf("RTS/CTS hardware flow control: %s\n", hwflow_onoff(0) ? "on" : "off");
-	return 0;
+    if (argc == 2) {
+        if (strcmp(argv[1], "off") == 0)
+            hwflow_onoff(-1);
+        else
+            if (strcmp(argv[1], "on") == 0)
+                hwflow_onoff(1);
+            else
+                printf("Usage: %s\n", cmdtp->usage);
+    }
+    printf("RTS/CTS hardware flow control: %s\n", hwflow_onoff(0) ? "on" : "off");
+    return 0;
 }
 
 /* -------------------------------------------------------------------- */
 
 U_BOOT_CMD(
-	hwflow, 2, 0,	do_hwflow,
-	"hwflow  - turn the harwdare flow control on/off\n",
-	"[on|off]\n - change RTS/CTS hardware flow control over serial line\n"
+    hwflow, 2, 0,   do_hwflow,
+    "hwflow  - turn the harwdare flow control on/off\n",
+    "[on|off]\n - change RTS/CTS hardware flow control over serial line\n"
 );
 
 #endif /* CFG_CMD_HWFLOW */
diff -urN u-boot-1.1.6/common/cmd_menu_bak.c u-boot-1.1.6_fdt/common/cmd_menu_bak.c
--- u-boot-1.1.6/common/cmd_menu_bak.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/cmd_menu_bak.c	2018-10-22 15:53:21.541641225 +0800
@@ -0,0 +1,310 @@
+/*
+ * thisway.diy@163.com, www.100ask.net
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <def.h>
+#include <nand.h>
+
+extern char console_buffer[];
+extern int readline (const char *const prompt);
+extern char awaitkey(unsigned long delay, int* error_p);
+extern void download_nkbin_to_flash(void);
+
+/**
+ * Parses a string into a number.  The number stored at ptr is
+ * potentially suffixed with K (for kilobytes, or 1024 bytes),
+ * M (for megabytes, or 1048576 bytes), or G (for gigabytes, or
+ * 1073741824).  If the number is suffixed with K, M, or G, then
+ * the return value is the number multiplied by one kilobyte, one
+ * megabyte, or one gigabyte, respectively.
+ *
+ * @param ptr where parse begins
+ * @param retptr output pointer to next char after parse completes (output)
+ * @return resulting unsigned int
+ */
+static unsigned long memsize_parse2 (const char *const ptr, const char **retptr)
+{
+	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
+    int sixteen = 1;
+
+	switch (**retptr) {
+		case 'G':
+		case 'g':
+			ret <<= 10;
+		case 'M':
+		case 'm':
+			ret <<= 10;
+		case 'K':
+		case 'k':
+			ret <<= 10;
+			(*retptr)++;
+            sixteen = 0;
+		default:
+			break;
+	}
+
+    if (sixteen)
+        return simple_strtoul(ptr, NULL, 16);
+    
+	return ret;
+}
+
+
+void param_menu_usage()
+{
+    printf("\r\n##### Parameter Menu #####\r\n");
+    printf("[v] View the parameters\r\n");
+    printf("[s] Set parameter \r\n");
+    printf("[d] Delete parameter \r\n");
+    printf("[w] Write the parameters to flash memeory \r\n");
+    printf("[q] Quit \r\n");
+    printf("Enter your selection: ");
+}
+
+
+void param_menu_shell(void)
+{
+    char c;
+    char cmd_buf[256];
+    char name_buf[20];
+    char val_buf[256];
+    
+    while (1)
+    {
+        param_menu_usage();
+        c = awaitkey(-1, NULL);
+        printf("%c\n", c);
+        switch (c)
+        {
+            case 'v':
+            {
+                strcpy(cmd_buf, "printenv ");
+                printf("Name(enter to view all paramters): ");
+                readline(NULL);
+                strcat(cmd_buf, console_buffer);
+                run_command(cmd_buf, 0);
+                break;
+            }
+            
+            case 's':
+            {
+                sprintf(cmd_buf, "setenv ");
+
+                printf("Name: ");
+                readline(NULL);
+                strcat(cmd_buf, console_buffer);
+
+                printf("Value: ");
+                readline(NULL);
+                strcat(cmd_buf, " ");
+                strcat(cmd_buf, console_buffer);
+
+                run_command(cmd_buf, 0);
+                break;
+            }
+            
+            case 'd':
+            {
+                sprintf(cmd_buf, "setenv ");
+
+                printf("Name: ");
+                readline(NULL);
+                strcat(cmd_buf, console_buffer);
+
+                run_command(cmd_buf, 0);
+                break;
+            }
+            
+            case 'w':
+            {
+                sprintf(cmd_buf, "saveenv");
+                run_command(cmd_buf, 0);
+                break;
+            }
+            
+            case 'q':
+            {
+                return;
+                break;
+            }
+        }
+    }
+}
+
+
+void main_menu_usage(void)
+{
+    printf("\r\n##### 100ask Bootloader for OpenJTAG #####\r\n");
+
+    printf("[n] Download u-boot to Nand Flash\r\n");
+	if (bBootFrmNORFlash())
+	    printf("[o] Download u-boot to Nor Flash\r\n");
+    printf("[k] Download Linux kernel uImage\r\n");
+    printf("[j] Download root_jffs2 image\r\n");
+//    printf("[c] Download root_cramfs image\r\n");
+    printf("[y] Download root_yaffs image\r\n");
+    printf("[d] Download to SDRAM & Run\r\n");
+    printf("[z] Download zImage into RAM\r\n");
+    printf("[g] Boot linux from RAM\r\n");
+    printf("[f] Format the Nand Flash\r\n");
+    printf("[s] Set the boot parameters\r\n");
+    printf("[b] Boot the system\r\n");
+    printf("[r] Reboot u-boot\r\n");
+    printf("[q] Quit from menu\r\n");
+    printf("Enter your selection: ");
+}
+
+
+void menu_shell(void)
+{
+    char c;
+    char cmd_buf[200];
+    char *p = NULL;
+    unsigned long size;
+    unsigned long offset;
+    struct mtd_info *mtd = &nand_info[nand_curr_device];
+
+    while (1)
+    {
+        main_menu_usage();
+        c = awaitkey(-1, NULL);
+        printf("%c\n", c);
+        switch (c)
+        {
+			case 'n':
+			{
+                strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase bootloader; nand write.jffs2 0x30000000 bootloader $(filesize)");
+                run_command(cmd_buf, 0);
+                break;
+			}
+            case 'o':
+            {
+                if (bBootFrmNORFlash())
+                {
+                    strcpy(cmd_buf, "usbslave 1 0x30000000; protect off all; erase 0 +$(filesize); cp.b 0x30000000 0 $(filesize)");
+                    run_command(cmd_buf, 0);
+                }
+				break;
+            }
+            
+            case 'k':
+            {
+                strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase kernel; nand write.jffs2 0x30000000 kernel $(filesize)");
+                run_command(cmd_buf, 0);
+                break;
+            }
+
+            case 'j':
+            {
+                strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase root; nand write.jffs2 0x30000000 root $(filesize)");
+                run_command(cmd_buf, 0);
+                break;
+            }
+#if 0
+            case 'c':
+            {
+                strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase root; nand write.jffs2 0x30000000 root $(filesize)");
+                run_command(cmd_buf, 0);
+                break;
+            }
+#endif
+            case 'y':
+            {
+                strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase root; nand write.yaffs 0x30000000 root $(filesize)");
+                run_command(cmd_buf, 0);
+                break;
+            }
+
+            case 'd':
+            {
+                extern volatile U32 downloadAddress;
+                extern int download_run;
+                
+                download_run = 1;
+                strcpy(cmd_buf, "usbslave 1");
+                run_command(cmd_buf, 0);
+                download_run = 0;
+                sprintf(cmd_buf, "go %x", downloadAddress);
+                run_command(cmd_buf, 0);
+                break;
+            }
+
+			case 'z':
+			{
+				strcpy(cmd_buf, "usbslave 1 0x30008000");
+				run_command(cmd_buf, 0);
+				break;
+			}
+
+			case 'g':
+			{
+				extern void do_bootm_rawLinux (ulong addr);
+				do_bootm_rawLinux(0x30008000);
+			}
+
+            case 'b':
+            {
+                printf("Booting Linux ...\n");
+                strcpy(cmd_buf, "nand read.jffs2 0x30007FC0 kernel; bootm 0x30007FC0");
+                run_command(cmd_buf, 0);
+                break;
+            }
+
+            case 'f':
+            {
+                strcpy(cmd_buf, "nand erase ");
+
+                printf("Start address: ");
+                readline(NULL);
+                strcat(cmd_buf, console_buffer);
+
+                printf("Size(eg. 4000000, 0x4000000, 64m and so on): ");
+                readline(NULL);
+                p = console_buffer;
+                size = memsize_parse2(p, &p);
+                sprintf(console_buffer, " %x", size);
+                strcat(cmd_buf, console_buffer);
+
+                run_command(cmd_buf, 0);
+                break;
+            }
+
+            case 's':
+            {
+                param_menu_shell();
+                break;
+            }
+
+            case 'r':
+            {
+				strcpy(cmd_buf, "reset");
+				run_command(cmd_buf, 0);
+                break;
+            }
+            
+            case 'q':
+            {
+                return;    
+                break;
+            }
+
+        }
+                
+    }
+}
+
+int do_menu (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    menu_shell();
+    return 0;
+}
+
+U_BOOT_CMD(
+	menu,	3,	0,	do_menu,
+	"menu - display a menu, to select the items to do something\n",
+	" - display a menu, to select the items to do something"
+);
+
diff -urN u-boot-1.1.6/common/cmd_menu.c u-boot-1.1.6_fdt/common/cmd_menu.c
--- u-boot-1.1.6/common/cmd_menu.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/cmd_menu.c	2018-10-22 15:53:21.541641225 +0800
@@ -0,0 +1,348 @@
+/*
+ * thisway.diy@163.com, www.100ask.net
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <def.h>
+#include <nand.h>
+
+extern char console_buffer[];
+extern int readline (const char *const prompt);
+extern char awaitkey(unsigned long delay, int* error_p);
+extern void download_nkbin_to_flash(void);
+
+/**
+ * Parses a string into a number.  The number stored at ptr is
+ * potentially suffixed with K (for kilobytes, or 1024 bytes),
+ * M (for megabytes, or 1048576 bytes), or G (for gigabytes, or
+ * 1073741824).  If the number is suffixed with K, M, or G, then
+ * the return value is the number multiplied by one kilobyte, one
+ * megabyte, or one gigabyte, respectively.
+ *
+ * @param ptr where parse begins
+ * @param retptr output pointer to next char after parse completes (output)
+ * @return resulting unsigned int
+ */
+static unsigned long memsize_parse2 (const char *const ptr, const char **retptr)
+{
+	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
+    int sixteen = 1;
+
+	switch (**retptr) {
+		case 'G':
+		case 'g':
+			ret <<= 10;
+		case 'M':
+		case 'm':
+			ret <<= 10;
+		case 'K':
+		case 'k':
+			ret <<= 10;
+			(*retptr)++;
+            sixteen = 0;
+		default:
+			break;
+	}
+
+    if (sixteen)
+        return simple_strtoul(ptr, NULL, 16);
+    
+	return ret;
+}
+
+
+void param_menu_usage()
+{
+    printf("\r\n##### Parameter Menu #####\r\n");
+    printf("[v] View the parameters\r\n");
+    printf("[s] Set parameter \r\n");
+    printf("[d] Delete parameter \r\n");
+    printf("[w] Write the parameters to flash memeory \r\n");
+    printf("[q] Quit \r\n");
+    printf("Enter your selection: ");
+}
+
+
+void param_menu_shell(void)
+{
+    char c;
+    char cmd_buf[256];
+    char name_buf[20];
+    char val_buf[256];
+    
+    while (1)
+    {
+        param_menu_usage();
+        c = awaitkey(-1, NULL);
+        printf("%c\n", c);
+        switch (c)
+        {
+            case 'v':
+            {
+                strcpy(cmd_buf, "printenv ");
+                printf("Name(enter to view all paramters): ");
+                readline(NULL);
+                strcat(cmd_buf, console_buffer);
+                run_command(cmd_buf, 0);
+                break;
+            }
+            
+            case 's':
+            {
+                sprintf(cmd_buf, "setenv ");
+
+                printf("Name: ");
+                readline(NULL);
+                strcat(cmd_buf, console_buffer);
+
+                printf("Value: ");
+                readline(NULL);
+                strcat(cmd_buf, " ");
+                strcat(cmd_buf, console_buffer);
+
+                run_command(cmd_buf, 0);
+                break;
+            }
+            
+            case 'd':
+            {
+                sprintf(cmd_buf, "setenv ");
+
+                printf("Name: ");
+                readline(NULL);
+                strcat(cmd_buf, console_buffer);
+
+                run_command(cmd_buf, 0);
+                break;
+            }
+            
+            case 'w':
+            {
+                sprintf(cmd_buf, "saveenv");
+                run_command(cmd_buf, 0);
+                break;
+            }
+            
+            case 'q':
+            {
+                return;
+                break;
+            }
+        }
+    }
+}
+
+
+void main_menu_usage(void)
+{
+    printf("\r\n##### 100ask Bootloader for OpenJTAG #####\r\n");
+
+    printf("[n] Download u-boot to Nand Flash\r\n");
+	if (bBootFrmNORFlash())
+	    printf("[o] Download u-boot to Nor Flash\r\n");
+
+	printf("[c] Re-scan Nor Flash\r\n");
+    printf("[u] Copy bootloader from nand to nor\r\n");
+    printf("[v] Copy bootloader from nor to nand\r\n");
+	
+    printf("[t] Download device tree file(.dtb)\r\n");
+    printf("[k] Download Linux kernel uImage\r\n");
+    printf("[j] Download root_jffs2 image\r\n");
+//    printf("[c] Download root_cramfs image\r\n");
+    printf("[y] Download root_yaffs image\r\n");
+    printf("[d] Download to SDRAM & Run\r\n");
+    printf("[z] Download zImage into RAM\r\n");
+    printf("[g] Boot linux from RAM\r\n");
+    printf("[f] Format the Nand Flash\r\n");
+    printf("[s] Set the boot parameters\r\n");
+    printf("[b] Boot the system\r\n");
+    printf("[r] Reboot u-boot\r\n");
+    printf("[q] Quit from menu\r\n");
+    printf("Enter your selection: ");
+}
+
+
+void menu_shell(void)
+{
+    char c;
+    char cmd_buf[200];
+    char *p = NULL;
+    unsigned long size;
+    unsigned long offset;
+    struct mtd_info *mtd = &nand_info[nand_curr_device];
+
+    while (1)
+    {
+        main_menu_usage();
+        c = awaitkey(-1, NULL);
+        printf("%c\n", c);
+        switch (c)
+        {
+			case 'n':
+			{
+                strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase bootloader; nand write.jffs2 0x30000000 bootloader $(filesize)");
+                run_command(cmd_buf, 0);
+                break;
+			}
+            case 'o':
+            {
+                if (bBootFrmNORFlash())
+                {
+                    strcpy(cmd_buf, "usbslave 1 0x30000000; protect off all; erase 0 +$(filesize); cp.b 0x30000000 0 $(filesize)");
+                    run_command(cmd_buf, 0);
+                }
+				break;
+            }
+
+            case 'c':
+            {
+				size = flash_init ();
+				display_flash_config (size);
+                
+				break;
+            }
+
+            case 'u':
+            {
+				strcpy(cmd_buf, "nand read.jffs2 30000000 bootloader; protect off all; erase 0 3ffff; cp.b 30000000 0 40000");
+				run_command(cmd_buf, 0);
+                
+				break;
+            }
+
+
+            case 'v':
+            {
+				strcpy(cmd_buf, "nand erase bootloader; nand write.jffs2 0 bootloader");
+				run_command(cmd_buf, 0);
+                
+				break;
+            }
+
+            case 't':
+            {
+                strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase device_tree; nand write.jffs2 0x30000000 device_tree $(filesize)");
+                run_command(cmd_buf, 0);
+                break;
+            }
+            
+            case 'k':
+            {
+                strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase kernel; nand write.jffs2 0x30000000 kernel $(filesize)");
+                run_command(cmd_buf, 0);
+                break;
+            }
+
+            case 'j':
+            {
+                strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase root; nand write.jffs2 0x30000000 root $(filesize)");
+                run_command(cmd_buf, 0);
+                break;
+            }
+#if 0
+            case 'c':
+            {
+                strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase root; nand write.jffs2 0x30000000 root $(filesize)");
+                run_command(cmd_buf, 0);
+                break;
+            }
+#endif
+            case 'y':
+            {
+                strcpy(cmd_buf, "usbslave 1 0x30000000; nand erase root; nand write.yaffs 0x30000000 root $(filesize)");
+                run_command(cmd_buf, 0);
+                break;
+            }
+
+            case 'd':
+            {
+                extern volatile U32 downloadAddress;
+                extern int download_run;
+                
+                download_run = 1;
+                strcpy(cmd_buf, "usbslave 1");
+                run_command(cmd_buf, 0);
+                download_run = 0;
+                sprintf(cmd_buf, "go %x", downloadAddress);
+                run_command(cmd_buf, 0);
+                break;
+            }
+
+			case 'z':
+			{
+				strcpy(cmd_buf, "usbslave 1 0x30008000");
+				run_command(cmd_buf, 0);
+				break;
+			}
+
+			case 'g':
+			{
+				extern void do_bootm_rawLinux (ulong addr);
+				do_bootm_rawLinux(0x30008000);
+			}
+
+            case 'b':
+            {
+                printf("Booting Linux ...\n");
+                strcpy(cmd_buf, "nand read.jffs2 0x30007FC0 kernel; bootm 0x30007FC0");
+                run_command(cmd_buf, 0);
+                break;
+            }
+
+            case 'f':
+            {
+                strcpy(cmd_buf, "nand erase ");
+
+                printf("Start address: ");
+                readline(NULL);
+                strcat(cmd_buf, console_buffer);
+
+                printf("Size(eg. 4000000, 0x4000000, 64m and so on): ");
+                readline(NULL);
+                p = console_buffer;
+                size = memsize_parse2(p, &p);
+                sprintf(console_buffer, " %x", size);
+                strcat(cmd_buf, console_buffer);
+
+                run_command(cmd_buf, 0);
+                break;
+            }
+
+            case 's':
+            {
+                param_menu_shell();
+                break;
+            }
+
+            case 'r':
+            {
+				strcpy(cmd_buf, "reset");
+				run_command(cmd_buf, 0);
+                break;
+            }
+            
+            case 'q':
+            {
+                return;    
+                break;
+            }
+
+        }
+                
+    }
+}
+
+int do_menu (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    menu_shell();
+    return 0;
+}
+
+U_BOOT_CMD(
+	menu,	3,	0,	do_menu,
+	"menu - display a menu, to select the items to do something\n",
+	" - display a menu, to select the items to do something"
+);
+
diff -urN u-boot-1.1.6/common/cmd_nand.c u-boot-1.1.6_fdt/common/cmd_nand.c
--- u-boot-1.1.6/common/cmd_nand.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/common/cmd_nand.c	2018-10-22 15:53:21.541641225 +0800
@@ -28,7 +28,7 @@
 
 #ifdef CONFIG_SHOW_BOOT_PROGRESS
 # include <status_led.h>
-# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+# define SHOW_BOOT_PROGRESS(arg)    show_boot_progress(arg)
 #else
 # define SHOW_BOOT_PROGRESS(arg)
 #endif
@@ -42,572 +42,635 @@
 int mtdparts_init(void);
 int id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num);
 int find_dev_and_part(const char *id, struct mtd_device **dev,
-		u8 *part_num, struct part_info **part);
+        u8 *part_num, struct part_info **part);
 #endif
 
 extern nand_info_t nand_info[];       /* info for NAND chips */
 
 static int nand_dump_oob(nand_info_t *nand, ulong off)
 {
-	return 0;
+    return 0;
 }
 
 static int nand_dump(nand_info_t *nand, ulong off)
 {
-	int i;
-	u_char *buf, *p;
+    int i;
+    u_char *buf, *p;
 
-	buf = malloc(nand->oobblock + nand->oobsize);
-	if (!buf) {
-		puts("No memory for page buffer\n");
-		return 1;
-	}
-	off &= ~(nand->oobblock - 1);
-	i = nand_read_raw(nand, buf, off, nand->oobblock, nand->oobsize);
-	if (i < 0) {
-		printf("Error (%d) reading page %08x\n", i, off);
-		free(buf);
-		return 1;
-	}
-	printf("Page %08x dump:\n", off);
-	i = nand->oobblock >> 4; p = buf;
-	while (i--) {
-		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
-			"  %02x %02x %02x %02x %02x %02x %02x %02x\n",
-			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
-			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
-		p += 16;
-	}
-	puts("OOB:\n");
-	i = nand->oobsize >> 3;
-	while (i--) {
-		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
-			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
-		p += 8;
-	}
-	free(buf);
+    buf = malloc(nand->oobblock + nand->oobsize);
+    if (!buf) {
+        puts("No memory for page buffer\n");
+        return 1;
+    }
+    off &= ~(nand->oobblock - 1);
+    i = nand_read_raw(nand, buf, off, nand->oobblock, nand->oobsize);
+    if (i < 0) {
+        printf("Error (%d) reading page %08x\n", i, off);
+        free(buf);
+        return 1;
+    }
+    printf("Page %08x dump:\n", off);
+    i = nand->oobblock >> 4; p = buf;
+    while (i--) {
+        printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
+            "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
+            p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+            p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+        p += 16;
+    }
+    puts("OOB:\n");
+    i = nand->oobsize >> 3;
+    while (i--) {
+        printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
+            p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+        p += 8;
+    }
+    free(buf);
 
-	return 0;
+    return 0;
 }
 
 /* ------------------------------------------------------------------------- */
 
 static inline int str2long(char *p, ulong *num)
 {
-	char *endptr;
+    char *endptr;
 
-	*num = simple_strtoul(p, &endptr, 16);
-	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+    *num = simple_strtoul(p, &endptr, 16);
+    return (*p != '\0' && *endptr == '\0') ? 1 : 0;
 }
 
 static int
 arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, ulong *size)
 {
-	int idx = nand_curr_device;
+    int idx = nand_curr_device;
 #if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
-	struct mtd_device *dev;
-	struct part_info *part;
-	u8 pnum;
-
-	if (argc >= 1 && !(str2long(argv[0], off))) {
-		if ((mtdparts_init() == 0) &&
-		    (find_dev_and_part(argv[0], &dev, &pnum, &part) == 0)) {
-			if (dev->id->type != MTD_DEV_TYPE_NAND) {
-				puts("not a NAND device\n");
-				return -1;
-			}
-			*off = part->offset;
-			if (argc >= 2) {
-				if (!(str2long(argv[1], size))) {
-					printf("'%s' is not a number\n", argv[1]);
-					return -1;
-				}
-				if (*size > part->size)
-					*size = part->size;
-			} else {
-				*size = part->size;
-			}
-			idx = dev->id->num;
-			*nand = nand_info[idx];
-			goto out;
-		}
-	}
-#endif
-
-	if (argc >= 1) {
-		if (!(str2long(argv[0], off))) {
-			printf("'%s' is not a number\n", argv[0]);
-			return -1;
-		}
-	} else {
-		*off = 0;
-	}
-
-	if (argc >= 2) {
-		if (!(str2long(argv[1], size))) {
-			printf("'%s' is not a number\n", argv[1]);
-			return -1;
-		}
-	} else {
-		*size = nand->size - *off;
-	}
+    struct mtd_device *dev;
+    struct part_info *part;
+    u8 pnum;
+
+    if (argc >= 1 && !(str2long(argv[0], off))) {
+        if ((mtdparts_init() == 0) &&
+            (find_dev_and_part(argv[0], &dev, &pnum, &part) == 0)) {
+            if (dev->id->type != MTD_DEV_TYPE_NAND) {
+                puts("not a NAND device\n");
+                return -1;
+            }
+            *off = part->offset;
+            if (argc >= 2) {
+                if (!(str2long(argv[1], size))) {
+                    printf("'%s' is not a number\n", argv[1]);
+                    return -1;
+                }
+                if (*size > part->size)
+                    *size = part->size;
+            } else {
+                *size = part->size;
+            }
+            idx = dev->id->num;
+            *nand = nand_info[idx];
+            goto out;
+        }
+    }
+#endif
+
+    if (argc >= 1) {
+        if (!(str2long(argv[0], off))) {
+            printf("'%s' is not a number\n", argv[0]);
+            return -1;
+        }
+    } else {
+        *off = 0;
+    }
+
+    if (argc >= 2) {
+        if (!(str2long(argv[1], size))) {
+            printf("'%s' is not a number\n", argv[1]);
+            return -1;
+        }
+    } else {
+        *size = nand->size - *off;
+    }
 
 #if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
 out:
 #endif
-	printf("device %d ", idx);
-	if (*size == nand->size)
-		puts("whole chip\n");
-	else
-		printf("offset 0x%x, size 0x%x\n", *off, *size);
-	return 0;
+    printf("device %d ", idx);
+    if (*size == nand->size)
+        puts("whole chip\n");
+    else
+        printf("offset 0x%x, size 0x%x\n", *off, *size);
+    return 0;
 }
 
 int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
-	int i, dev, ret;
-	ulong addr, off, size;
-	char *cmd, *s;
-	nand_info_t *nand;
-	int quiet = 0;
-	const char *quiet_str = getenv("quiet");
-
-	/* at least two arguments please */
-	if (argc < 2)
-		goto usage;
-
-	if (quiet_str)
-		quiet = simple_strtoul(quiet_str, NULL, 0) != 0;
-
-	cmd = argv[1];
-
-	if (strcmp(cmd, "info") == 0) {
-
-		putc('\n');
-		for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
-			if (nand_info[i].name)
-				printf("Device %d: %s, sector size %lu KiB\n",
-					i, nand_info[i].name,
-					nand_info[i].erasesize >> 10);
-		}
-		return 0;
-	}
-
-	if (strcmp(cmd, "device") == 0) {
-
-		if (argc < 3) {
-			if ((nand_curr_device < 0) ||
-			    (nand_curr_device >= CFG_MAX_NAND_DEVICE))
-				puts("\nno devices available\n");
-			else
-				printf("\nDevice %d: %s\n", nand_curr_device,
-					nand_info[nand_curr_device].name);
-			return 0;
-		}
-		dev = (int)simple_strtoul(argv[2], NULL, 10);
-		if (dev < 0 || dev >= CFG_MAX_NAND_DEVICE || !nand_info[dev].name) {
-			puts("No such device\n");
-			return 1;
-		}
-		printf("Device %d: %s", dev, nand_info[dev].name);
-		puts("... is now current device\n");
-		nand_curr_device = dev;
+    int i, dev, ret;
+    ulong addr, off, size;
+    char *cmd, *s;
+    nand_info_t *nand;
+    int quiet = 0;
+    const char *quiet_str = getenv("quiet");
+
+    /* at least two arguments please */
+    if (argc < 2)
+        goto usage;
+
+    if (quiet_str)
+        quiet = simple_strtoul(quiet_str, NULL, 0) != 0;
+
+    cmd = argv[1];
+
+    if (strcmp(cmd, "info") == 0) {
+
+        putc('\n');
+        for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
+            if (nand_info[i].name)
+                printf("Device %d: %s, sector size %lu KiB\n",
+                    i, nand_info[i].name,
+                    nand_info[i].erasesize >> 10);
+        }
+        return 0;
+    }
+
+    if (strcmp(cmd, "device") == 0) {
+
+        if (argc < 3) {
+            if ((nand_curr_device < 0) ||
+                (nand_curr_device >= CFG_MAX_NAND_DEVICE))
+                puts("\nno devices available\n");
+            else
+                printf("\nDevice %d: %s\n", nand_curr_device,
+                    nand_info[nand_curr_device].name);
+            return 0;
+        }
+        dev = (int)simple_strtoul(argv[2], NULL, 10);
+        if (dev < 0 || dev >= CFG_MAX_NAND_DEVICE || !nand_info[dev].name) {
+            puts("No such device\n");
+            return 1;
+        }
+        printf("Device %d: %s", dev, nand_info[dev].name);
+        puts("... is now current device\n");
+        nand_curr_device = dev;
 
 #ifdef CFG_NAND_SELECT_DEVICE
-		/*
-		 * Select the chip in the board/cpu specific driver
-		 */
-		board_nand_select_device(nand_info[dev].priv, dev);
-#endif
-
-		return 0;
-	}
-
-	if (strcmp(cmd, "bad") != 0 && strcmp(cmd, "erase") != 0 &&
-	    strncmp(cmd, "dump", 4) != 0 &&
-	    strncmp(cmd, "read", 4) != 0 && strncmp(cmd, "write", 5) != 0 &&
-	    strcmp(cmd, "scrub") != 0 && strcmp(cmd, "markbad") != 0 &&
-	    strcmp(cmd, "biterr") != 0 &&
-	    strcmp(cmd, "lock") != 0 && strcmp(cmd, "unlock") != 0 )
-		goto usage;
-
-	/* the following commands operate on the current device */
-	if (nand_curr_device < 0 || nand_curr_device >= CFG_MAX_NAND_DEVICE ||
-	    !nand_info[nand_curr_device].name) {
-		puts("\nno devices available\n");
-		return 1;
-	}
-	nand = &nand_info[nand_curr_device];
-
-	if (strcmp(cmd, "bad") == 0) {
-		printf("\nDevice %d bad blocks:\n", nand_curr_device);
-		for (off = 0; off < nand->size; off += nand->erasesize)
-			if (nand_block_isbad(nand, off))
-				printf("  %08x\n", off);
-		return 0;
-	}
-
-	/*
-	 * Syntax is:
-	 *   0    1     2       3    4
-	 *   nand erase [clean] [off size]
-	 */
-	if (strcmp(cmd, "erase") == 0 || strcmp(cmd, "scrub") == 0) {
-		nand_erase_options_t opts;
-		/* "clean" at index 2 means request to write cleanmarker */
-		int clean = argc > 2 && !strcmp("clean", argv[2]);
-		int o = clean ? 3 : 2;
-		int scrub = !strcmp(cmd, "scrub");
-
-		printf("\nNAND %s: ", scrub ? "scrub" : "erase");
-		/* skip first two or three arguments, look for offset and size */
-		if (arg_off_size(argc - o, argv + o, nand, &off, &size) != 0)
-			return 1;
-
-		memset(&opts, 0, sizeof(opts));
-		opts.offset = off;
-		opts.length = size;
-		opts.jffs2  = clean;
-		opts.quiet  = quiet;
-
-		if (scrub) {
-			puts("Warning: "
-			     "scrub option will erase all factory set "
-			     "bad blocks!\n"
-			     "         "
-			     "There is no reliable way to recover them.\n"
-			     "         "
-			     "Use this command only for testing purposes "
-			     "if you\n"
-			     "         "
-			     "are sure of what you are doing!\n"
-			     "\nReally scrub this NAND flash? <y/N>\n");
-
-			if (getc() == 'y' && getc() == '\r') {
-				opts.scrub = 1;
-			} else {
-				puts("scrub aborted\n");
-				return -1;
-			}
-		}
-		ret = nand_erase_opts(nand, &opts);
-		printf("%s\n", ret ? "ERROR" : "OK");
-
-		return ret == 0 ? 0 : 1;
-	}
-
-	if (strncmp(cmd, "dump", 4) == 0) {
-		if (argc < 3)
-			goto usage;
-
-		s = strchr(cmd, '.');
-		off = (int)simple_strtoul(argv[2], NULL, 16);
-
-		if (s != NULL && strcmp(s, ".oob") == 0)
-			ret = nand_dump_oob(nand, off);
-		else
-			ret = nand_dump(nand, off);
-
-		return ret == 0 ? 1 : 0;
-
-	}
-
-	/* read write */
-	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
-		int read;
-
-		if (argc < 4)
-			goto usage;
-
-		addr = (ulong)simple_strtoul(argv[2], NULL, 16);
-
-		read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
-		printf("\nNAND %s: ", read ? "read" : "write");
-		if (arg_off_size(argc - 3, argv + 3, nand, &off, &size) != 0)
-			return 1;
-
-		s = strchr(cmd, '.');
-		if (s != NULL &&
-		    (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i"))) {
-			if (read) {
-				/* read */
-				nand_read_options_t opts;
-				memset(&opts, 0, sizeof(opts));
-				opts.buffer	= (u_char*) addr;
-				opts.length	= size;
-				opts.offset	= off;
-				opts.quiet      = quiet;
-				ret = nand_read_opts(nand, &opts);
-			} else {
-				/* write */
-				nand_write_options_t opts;
-				memset(&opts, 0, sizeof(opts));
-				opts.buffer	= (u_char*) addr;
-				opts.length	= size;
-				opts.offset	= off;
-				/* opts.forcejffs2 = 1; */
-				opts.pad	= 1;
-				opts.blockalign = 1;
-				opts.quiet      = quiet;
-				ret = nand_write_opts(nand, &opts);
-			}
-		} else {
-			if (read)
-				ret = nand_read(nand, off, &size, (u_char *)addr);
-			else
-				ret = nand_write(nand, off, &size, (u_char *)addr);
-		}
-
-		printf(" %d bytes %s: %s\n", size,
-		       read ? "read" : "written", ret ? "ERROR" : "OK");
-
-		return ret == 0 ? 0 : 1;
-	}
-
-	if (strcmp(cmd, "markbad") == 0) {
-		addr = (ulong)simple_strtoul(argv[2], NULL, 16);
-
-		int ret = nand->block_markbad(nand, addr);
-		if (ret == 0) {
-			printf("block 0x%08lx successfully marked as bad\n",
-			       (ulong) addr);
-			return 0;
-		} else {
-			printf("block 0x%08lx NOT marked as bad! ERROR %d\n",
-			       (ulong) addr, ret);
-		}
-		return 1;
-	}
-	if (strcmp(cmd, "biterr") == 0) {
-		/* todo */
-		return 1;
-	}
-
-	if (strcmp(cmd, "lock") == 0) {
-		int tight  = 0;
-		int status = 0;
-		if (argc == 3) {
-			if (!strcmp("tight", argv[2]))
-				tight = 1;
-			if (!strcmp("status", argv[2]))
-				status = 1;
-		}
-
-		if (status) {
-			ulong block_start = 0;
-			ulong off;
-			int last_status = -1;
-
-			struct nand_chip *nand_chip = nand->priv;
-			/* check the WP bit */
-			nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
-			printf("device is %swrite protected\n",
-			       (nand_chip->read_byte(nand) & 0x80 ?
-				"NOT " : "" ) );
-
-			for (off = 0; off < nand->size; off += nand->oobblock) {
-				int s = nand_get_lock_status(nand, off);
-
-				/* print message only if status has changed
-				 * or at end of chip
-				 */
-				if (off == nand->size - nand->oobblock
-				    || (s != last_status && off != 0))	{
-
-					printf("%08x - %08x: %8d pages %s%s%s\n",
-					       block_start,
-					       off-1,
-					       (off-block_start)/nand->oobblock,
-					       ((last_status & NAND_LOCK_STATUS_TIGHT) ? "TIGHT " : ""),
-					       ((last_status & NAND_LOCK_STATUS_LOCK) ? "LOCK " : ""),
-					       ((last_status & NAND_LOCK_STATUS_UNLOCK) ? "UNLOCK " : ""));
-				}
-
-				last_status = s;
-		       }
-		} else {
-			if (!nand_lock(nand, tight)) {
-				puts("NAND flash successfully locked\n");
-			} else {
-				puts("Error locking NAND flash\n");
-				return 1;
-			}
-		}
-		return 0;
-	}
-
-	if (strcmp(cmd, "unlock") == 0) {
-		if (arg_off_size(argc - 2, argv + 2, nand, &off, &size) < 0)
-			return 1;
-
-		if (!nand_unlock(nand, off, size)) {
-			puts("NAND flash successfully unlocked\n");
-		} else {
-			puts("Error unlocking NAND flash, "
-			     "write and erase will probably fail\n");
-			return 1;
-		}
-		return 0;
-	}
+        /*
+         * Select the chip in the board/cpu specific driver
+         */
+        board_nand_select_device(nand_info[dev].priv, dev);
+#endif
+
+        return 0;
+    }
+
+    if (strcmp(cmd, "bad") != 0 && strcmp(cmd, "erase") != 0 &&
+        strncmp(cmd, "dump", 4) != 0 &&
+        strncmp(cmd, "read", 4) != 0 && strncmp(cmd, "write", 5) != 0 &&
+        strcmp(cmd, "scrub") != 0 && strcmp(cmd, "markbad") != 0 &&
+        strcmp(cmd, "biterr") != 0 &&
+        strcmp(cmd, "lock") != 0 && strcmp(cmd, "unlock") != 0 )
+        goto usage;
+
+    /* the following commands operate on the current device */
+    if (nand_curr_device < 0 || nand_curr_device >= CFG_MAX_NAND_DEVICE ||
+        !nand_info[nand_curr_device].name) {
+        puts("\nno devices available\n");
+        return 1;
+    }
+    nand = &nand_info[nand_curr_device];
+
+    if (strcmp(cmd, "bad") == 0) {
+        printf("\nDevice %d bad blocks:\n", nand_curr_device);
+        for (off = 0; off < nand->size; off += nand->erasesize)
+            if (nand_block_isbad(nand, off))
+                printf("  %08x\n", off);
+        return 0;
+    }
+
+    /*
+     * Syntax is:
+     *   0    1     2       3    4
+     *   nand erase [clean] [off size]
+     */
+    if (strcmp(cmd, "erase") == 0 || strcmp(cmd, "scrub") == 0) {
+        nand_erase_options_t opts;
+        /* "clean" at index 2 means request to write cleanmarker */
+        int clean = argc > 2 && !strcmp("clean", argv[2]);
+        int o = clean ? 3 : 2;
+        int scrub = !strcmp(cmd, "scrub");
+
+        printf("\nNAND %s: ", scrub ? "scrub" : "erase");
+        /* skip first two or three arguments, look for offset and size */
+        if (arg_off_size(argc - o, argv + o, nand, &off, &size) != 0)
+            return 1;
+
+        memset(&opts, 0, sizeof(opts));
+        opts.offset = off;
+        opts.length = size;
+        opts.jffs2  = clean;
+        opts.quiet  = quiet;
+
+        if (scrub) {
+            puts("Warning: "
+                 "scrub option will erase all factory set "
+                 "bad blocks!\n"
+                 "         "
+                 "There is no reliable way to recover them.\n"
+                 "         "
+                 "Use this command only for testing purposes "
+                 "if you\n"
+                 "         "
+                 "are sure of what you are doing!\n"
+                 "\nReally scrub this NAND flash? <y/N>\n");
+
+            if (getc() == 'y' && getc() == '\r') {
+                opts.scrub = 1;
+            } else {
+                puts("scrub aborted\n");
+                return -1;
+            }
+        }
+        ret = nand_erase_opts(nand, &opts);
+        printf("%s\n", ret ? "ERROR" : "OK");
+
+        return ret == 0 ? 0 : 1;
+    }
+
+    if (strncmp(cmd, "dump", 4) == 0) {
+        if (argc < 3)
+            goto usage;
+
+        s = strchr(cmd, '.');
+        off = (int)simple_strtoul(argv[2], NULL, 16);
+
+        if (s != NULL && strcmp(s, ".oob") == 0)
+            ret = nand_dump_oob(nand, off);
+        else
+            ret = nand_dump(nand, off);
+
+        return ret == 0 ? 1 : 0;
+
+    }
+
+    /* read write */
+    if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
+        int read;
+
+        if (argc < 4)
+            goto usage;
+
+        addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+
+        read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
+        printf("\nNAND %s: ", read ? "read" : "write");
+        if (arg_off_size(argc - 3, argv + 3, nand, &off, &size) != 0)
+            return 1;
+
+        s = strchr(cmd, '.');
+        if (s != NULL &&
+            (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i"))) {
+            if (read) {
+                /* read */
+                nand_read_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                opts.quiet      = quiet;
+                ret = nand_read_opts(nand, &opts);
+            } else {
+                /* write */
+                nand_write_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                /* opts.forcejffs2 = 1; */
+                opts.pad    = 1;
+                opts.blockalign = 1;
+                opts.quiet      = quiet;
+                ret = nand_write_opts(nand, &opts);
+            }
+        }else if (  s != NULL && !strcmp(s, ".yaffs")){
+            if (read) {
+                /* read */
+                nand_read_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                opts.readoob = 1;
+                opts.quiet      = quiet;
+                ret = nand_read_opts(nand, &opts);
+            } else {
+                /* write */
+                nand_write_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                /* opts.forceyaffs = 1; */
+                opts.noecc = 1;
+                opts.writeoob = 1;
+                opts.blockalign = 1;
+                opts.quiet      = quiet;
+                opts.skipfirstblk = 1;
+                ret = nand_write_opts(nand, &opts);
+            }
+        }else if (  s != NULL && !strcmp(s, ".raw")){
+            if (read) {
+                /* read */
+                nand_read_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                opts.readoob = 0;
+                opts.quiet      = quiet;
+                opts.noecc  = 1;
+                opts.nocheckbadblk = 1;
+                ret = nand_read_opts(nand, &opts);
+            } else {
+                /* write */
+                nand_write_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                /* opts.forceyaffs = 1; */
+                opts.noecc = 1;
+                opts.writeoob = 0;
+                opts.blockalign = 1;
+                opts.quiet      = quiet;
+                opts.skipfirstblk = 0;
+                opts.nocheckbadblk = 1;
+                ret = nand_write_opts(nand, &opts);
+            }
+        }        else {
+            if (read)
+                ret = nand_read(nand, off, &size, (u_char *)addr);
+            else
+                ret = nand_write(nand, off, &size, (u_char *)addr);
+        }
+
+        printf(" %d bytes %s: %s\n", size,
+               read ? "read" : "written", ret ? "ERROR" : "OK");
+
+        return ret == 0 ? 0 : 1;
+    }
+
+    if (strcmp(cmd, "markbad") == 0) {
+        addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+
+        int ret = nand->block_markbad(nand, addr);
+        if (ret == 0) {
+            printf("block 0x%08lx successfully marked as bad\n",
+                   (ulong) addr);
+            return 0;
+        } else {
+            printf("block 0x%08lx NOT marked as bad! ERROR %d\n",
+                   (ulong) addr, ret);
+        }
+        return 1;
+    }
+    if (strcmp(cmd, "biterr") == 0) {
+        /* todo */
+        return 1;
+    }
+
+    if (strcmp(cmd, "lock") == 0) {
+        int tight  = 0;
+        int status = 0;
+        if (argc == 3) {
+            if (!strcmp("tight", argv[2]))
+                tight = 1;
+            if (!strcmp("status", argv[2]))
+                status = 1;
+        }
+
+        if (status) {
+            ulong block_start = 0;
+            ulong off;
+            int last_status = -1;
+
+            struct nand_chip *nand_chip = nand->priv;
+            /* check the WP bit */
+            nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
+            printf("device is %swrite protected\n",
+                   (nand_chip->read_byte(nand) & 0x80 ?
+                "NOT " : "" ) );
+
+            for (off = 0; off < nand->size; off += nand->oobblock) {
+                int s = nand_get_lock_status(nand, off);
+
+                /* print message only if status has changed
+                 * or at end of chip
+                 */
+                if (off == nand->size - nand->oobblock
+                    || (s != last_status && off != 0))  {
+
+                    printf("%08x - %08x: %8d pages %s%s%s\n",
+                           block_start,
+                           off-1,
+                           (off-block_start)/nand->oobblock,
+                           ((last_status & NAND_LOCK_STATUS_TIGHT) ? "TIGHT " : ""),
+                           ((last_status & NAND_LOCK_STATUS_LOCK) ? "LOCK " : ""),
+                           ((last_status & NAND_LOCK_STATUS_UNLOCK) ? "UNLOCK " : ""));
+                }
+
+                last_status = s;
+               }
+        } else {
+            if (!nand_lock(nand, tight)) {
+                puts("NAND flash successfully locked\n");
+            } else {
+                puts("Error locking NAND flash\n");
+                return 1;
+            }
+        }
+        return 0;
+    }
+
+    if (strcmp(cmd, "unlock") == 0) {
+        if (arg_off_size(argc - 2, argv + 2, nand, &off, &size) < 0)
+            return 1;
+
+        if (!nand_unlock(nand, off, size)) {
+            puts("NAND flash successfully unlocked\n");
+        } else {
+            puts("Error unlocking NAND flash, "
+                 "write and erase will probably fail\n");
+            return 1;
+        }
+        return 0;
+    }
 
 usage:
-	printf("Usage:\n%s\n", cmdtp->usage);
-	return 1;
+    printf("Usage:\n%s\n", cmdtp->usage);
+    return 1;
 }
 
 U_BOOT_CMD(nand, 5, 1, do_nand,
-	"nand    - NAND sub-system\n",
-	"info                  - show available NAND devices\n"
-	"nand device [dev]     - show or set current device\n"
-	"nand read[.jffs2]     - addr off|partition size\n"
-	"nand write[.jffs2]    - addr off|partiton size - read/write `size' bytes starting\n"
-	"    at offset `off' to/from memory address `addr'\n"
-	"nand erase [clean] [off size] - erase `size' bytes from\n"
-	"    offset `off' (entire device if not specified)\n"
-	"nand bad - show bad blocks\n"
-	"nand dump[.oob] off - dump page\n"
-	"nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n"
-	"nand markbad off - mark bad block at offset (UNSAFE)\n"
-	"nand biterr off - make a bit error at offset (UNSAFE)\n"
-	"nand lock [tight] [status] - bring nand to lock state or display locked pages\n"
-	"nand unlock [offset] [size] - unlock section\n");
+    "nand    - NAND sub-system\n",
+    "info                  - show available NAND devices\n"
+    "nand device [dev]     - show or set current device\n"
+    "nand read[.jffs2]     - addr off|partition size\n"
+    "nand write[.jffs2]    - addr off|partiton size - read/write `size' bytes starting\n"
+    "    at offset `off' to/from memory address `addr'\n"
+    "nand read.yaffs addr off size - read the `size' byte yaffs image starting\n"
+    "    at offset `off' to memory address `addr'\n"
+    "nand write.yaffs addr off size - write the `size' byte yaffs image starting\n"
+    "    at offset `off' from memory address `addr'\n"
+    "nand read.raw addr off size - read the `size' bytes starting\n"
+    "    at offset `off' to memory address `addr', without oob and ecc\n"
+    "nand write.raw addr off size - write the `size' bytes starting\n"
+    "    at offset `off' from memory address `addr', without oob and ecc\n"
+    "nand erase [clean] [off size] - erase `size' bytes from\n"
+    "    offset `off' (entire device if not specified)\n"
+    "nand bad - show bad blocks\n"
+    "nand dump[.oob] off - dump page\n"
+    "nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n"
+    "nand markbad off - mark bad block at offset (UNSAFE)\n"
+    "nand biterr off - make a bit error at offset (UNSAFE)\n"
+    "nand lock [tight] [status] - bring nand to lock state or display locked pages\n"
+    "nand unlock [offset] [size] - unlock section\n");
 
 static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
-			   ulong offset, ulong addr, char *cmd)
+               ulong offset, ulong addr, char *cmd)
 {
-	int r;
-	char *ep;
-	ulong cnt;
-	image_header_t *hdr;
-
-	printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
-
-	cnt = nand->oobblock;
-	r = nand_read(nand, offset, &cnt, (u_char *) addr);
-	if (r) {
-		puts("** Read error\n");
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
-
-	hdr = (image_header_t *) addr;
-
-	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
-		printf("\n** Bad Magic Number 0x%x **\n", hdr->ih_magic);
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
-
-	print_image_hdr(hdr);
-
-	cnt = (ntohl(hdr->ih_size) + sizeof (image_header_t));
-
-	r = nand_read(nand, offset, &cnt, (u_char *) addr);
-	if (r) {
-		puts("** Read error\n");
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
-
-	/* Loading ok, update default load address */
-
-	load_addr = addr;
-
-	/* Check if we should attempt an auto-start */
-	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
-		char *local_args[2];
-		extern int do_bootm(cmd_tbl_t *, int, int, char *[]);
-
-		local_args[0] = cmd;
-		local_args[1] = NULL;
-
-		printf("Automatic boot of image at addr 0x%08lx ...\n", addr);
-
-		do_bootm(cmdtp, 0, 1, local_args);
-		return 1;
-	}
-	return 0;
+    int r;
+    char *ep;
+    ulong cnt;
+    image_header_t *hdr;
+
+    printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
+
+    cnt = nand->oobblock;
+    r = nand_read(nand, offset, &cnt, (u_char *) addr);
+    if (r) {
+        puts("** Read error\n");
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
+
+    hdr = (image_header_t *) addr;
+
+    if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+        printf("\n** Bad Magic Number 0x%x **\n", hdr->ih_magic);
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
+
+    print_image_hdr(hdr);
+
+    cnt = (ntohl(hdr->ih_size) + sizeof (image_header_t));
+
+    r = nand_read(nand, offset, &cnt, (u_char *) addr);
+    if (r) {
+        puts("** Read error\n");
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
+
+    /* Loading ok, update default load address */
+
+    load_addr = addr;
+
+    /* Check if we should attempt an auto-start */
+    if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
+        char *local_args[2];
+        extern int do_bootm(cmd_tbl_t *, int, int, char *[]);
+
+        local_args[0] = cmd;
+        local_args[1] = NULL;
+
+        printf("Automatic boot of image at addr 0x%08lx ...\n", addr);
+
+        do_bootm(cmdtp, 0, 1, local_args);
+        return 1;
+    }
+    return 0;
 }
 
 int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
-	char *boot_device = NULL;
-	int idx;
-	ulong addr, offset = 0;
+    char *boot_device = NULL;
+    int idx;
+    ulong addr, offset = 0;
 #if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
-	struct mtd_device *dev;
-	struct part_info *part;
-	u8 pnum;
-
-	if (argc >= 2) {
-		char *p = (argc == 2) ? argv[1] : argv[2];
-		if (!(str2long(p, &addr)) && (mtdparts_init() == 0) &&
-		    (find_dev_and_part(p, &dev, &pnum, &part) == 0)) {
-			if (dev->id->type != MTD_DEV_TYPE_NAND) {
-				puts("Not a NAND device\n");
-				return 1;
-			}
-			if (argc > 3)
-				goto usage;
-			if (argc == 3)
-				addr = simple_strtoul(argv[2], NULL, 16);
-			else
-				addr = CFG_LOAD_ADDR;
-			return nand_load_image(cmdtp, &nand_info[dev->id->num],
-					       part->offset, addr, argv[0]);
-		}
-	}
-#endif
-
-	switch (argc) {
-	case 1:
-		addr = CFG_LOAD_ADDR;
-		boot_device = getenv("bootdevice");
-		break;
-	case 2:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = getenv("bootdevice");
-		break;
-	case 3:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = argv[2];
-		break;
-	case 4:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = argv[2];
-		offset = simple_strtoul(argv[3], NULL, 16);
-		break;
-	default:
+    struct mtd_device *dev;
+    struct part_info *part;
+    u8 pnum;
+
+    if (argc >= 2) {
+        char *p = (argc == 2) ? argv[1] : argv[2];
+        if (!(str2long(p, &addr)) && (mtdparts_init() == 0) &&
+            (find_dev_and_part(p, &dev, &pnum, &part) == 0)) {
+            if (dev->id->type != MTD_DEV_TYPE_NAND) {
+                puts("Not a NAND device\n");
+                return 1;
+            }
+            if (argc > 3)
+                goto usage;
+            if (argc == 3)
+                addr = simple_strtoul(argv[1], NULL, 16);
+            else
+                addr = CFG_LOAD_ADDR;
+            return nand_load_image(cmdtp, &nand_info[dev->id->num],
+                           part->offset, addr, argv[0]);
+        }
+    }
+#endif
+
+    switch (argc) {
+    case 1:
+        addr = CFG_LOAD_ADDR;
+        boot_device = getenv("bootdevice");
+        break;
+    case 2:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = getenv("bootdevice");
+        break;
+    case 3:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = argv[2];
+        break;
+    case 4:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = argv[2];
+        offset = simple_strtoul(argv[3], NULL, 16);
+        break;
+    default:
 #if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
 usage:
 #endif
-		printf("Usage:\n%s\n", cmdtp->usage);
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
-
-	if (!boot_device) {
-		puts("\n** No boot device **\n");
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
-
-	idx = simple_strtoul(boot_device, NULL, 16);
-
-	if (idx < 0 || idx >= CFG_MAX_NAND_DEVICE || !nand_info[idx].name) {
-		printf("\n** Device %d not available\n", idx);
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
+        printf("Usage:\n%s\n", cmdtp->usage);
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
+
+    if (!boot_device) {
+        puts("\n** No boot device **\n");
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
+
+    idx = simple_strtoul(boot_device, NULL, 16);
+
+    if (idx < 0 || idx >= CFG_MAX_NAND_DEVICE || !nand_info[idx].name) {
+        printf("\n** Device %d not available\n", idx);
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
 
-	return nand_load_image(cmdtp, &nand_info[idx], offset, addr, argv[0]);
+    return nand_load_image(cmdtp, &nand_info[idx], offset, addr, argv[0]);
 }
 
 U_BOOT_CMD(nboot, 4, 1, do_nandboot,
-	"nboot   - boot from NAND device\n",
-	"[partition] | [[[loadAddr] dev] offset]\n");
+    "nboot   - boot from NAND device\n",
+    "[[loadAddr] partition] | [[[loadAddr] dev] offset]\n");
 
-#endif				/* (CONFIG_COMMANDS & CFG_CMD_NAND) */
+#endif              /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
 
 #else /* CFG_NAND_LEGACY */
 /*
@@ -622,7 +685,7 @@
 
 #ifdef CONFIG_SHOW_BOOT_PROGRESS
 # include <status_led.h>
-# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+# define SHOW_BOOT_PROGRESS(arg)    show_boot_progress(arg)
 #else
 # define SHOW_BOOT_PROGRESS(arg)
 #endif
@@ -640,8 +703,8 @@
 
 #define ROUND_DOWN(value,boundary)      ((value) & (~((boundary)-1)))
 
-#undef	NAND_DEBUG
-#undef	PSYCHO_DEBUG
+#undef  NAND_DEBUG
+#undef  PSYCHO_DEBUG
 
 /* ****************** WARNING *********************
  * When ALLOW_ERASE_BAD_DEBUG is non-zero the erase command will
@@ -656,16 +719,16 @@
  * and attempting to program or erase bad blocks can affect
  * the data in _other_ (good) blocks.
  */
-#define	 ALLOW_ERASE_BAD_DEBUG 0
+#define  ALLOW_ERASE_BAD_DEBUG 0
 
 #define CONFIG_MTD_NAND_ECC  /* enable ECC */
 #define CONFIG_MTD_NAND_ECC_JFFS2
 
 /* bits for nand_legacy_rw() `cmd'; or together as needed */
-#define NANDRW_READ	0x01
-#define NANDRW_WRITE	0x00
-#define NANDRW_JFFS2	0x02
-#define NANDRW_JFFS2_SKIP	0x04
+#define NANDRW_READ 0x01
+#define NANDRW_WRITE    0x00
+#define NANDRW_JFFS2    0x02
+#define NANDRW_JFFS2_SKIP   0x04
 
 /*
  * Imports from nand_legacy.c
@@ -673,15 +736,15 @@
 extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
 extern int curr_device;
 extern int nand_legacy_erase(struct nand_chip *nand, size_t ofs,
-			    size_t len, int clean);
+                size_t len, int clean);
 extern int nand_legacy_rw(struct nand_chip *nand, int cmd, size_t start,
-			 size_t len, size_t *retlen, u_char *buf);
+             size_t len, size_t *retlen, u_char *buf);
 extern void nand_print(struct nand_chip *nand);
 extern void nand_print_bad(struct nand_chip *nand);
 extern int nand_read_oob(struct nand_chip *nand, size_t ofs,
-			       size_t len, size_t *retlen, u_char *buf);
+                   size_t len, size_t *retlen, u_char *buf);
 extern int nand_write_oob(struct nand_chip *nand, size_t ofs,
-				size_t len, size_t *retlen, const u_char *buf);
+                size_t len, size_t *retlen, const u_char *buf);
 
 
 int do_nand (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
@@ -691,294 +754,294 @@
     switch (argc) {
     case 0:
     case 1:
-	printf ("Usage:\n%s\n", cmdtp->usage);
-	return 1;
+    printf ("Usage:\n%s\n", cmdtp->usage);
+    return 1;
     case 2:
-	if (strcmp(argv[1],"info") == 0) {
-		int i;
+    if (strcmp(argv[1],"info") == 0) {
+        int i;
 
-		putc ('\n');
+        putc ('\n');
 
-		for (i=0; i<CFG_MAX_NAND_DEVICE; ++i) {
-			if(nand_dev_desc[i].ChipID == NAND_ChipID_UNKNOWN)
-				continue; /* list only known devices */
-			printf ("Device %d: ", i);
-			nand_print(&nand_dev_desc[i]);
-		}
-		return 0;
-
-	} else if (strcmp(argv[1],"device") == 0) {
-		if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
-			puts ("\nno devices available\n");
-			return 1;
-		}
-		printf ("\nDevice %d: ", curr_device);
-		nand_print(&nand_dev_desc[curr_device]);
-		return 0;
-
-	} else if (strcmp(argv[1],"bad") == 0) {
-		if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
-			puts ("\nno devices available\n");
-			return 1;
-		}
-		printf ("\nDevice %d bad blocks:\n", curr_device);
-		nand_print_bad(&nand_dev_desc[curr_device]);
-		return 0;
-
-	}
-	printf ("Usage:\n%s\n", cmdtp->usage);
-	return 1;
-    case 3:
-	if (strcmp(argv[1],"device") == 0) {
-		int dev = (int)simple_strtoul(argv[2], NULL, 10);
+        for (i=0; i<CFG_MAX_NAND_DEVICE; ++i) {
+            if(nand_dev_desc[i].ChipID == NAND_ChipID_UNKNOWN)
+                continue; /* list only known devices */
+            printf ("Device %d: ", i);
+            nand_print(&nand_dev_desc[i]);
+        }
+        return 0;
+
+    } else if (strcmp(argv[1],"device") == 0) {
+        if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
+            puts ("\nno devices available\n");
+            return 1;
+        }
+        printf ("\nDevice %d: ", curr_device);
+        nand_print(&nand_dev_desc[curr_device]);
+        return 0;
+
+    } else if (strcmp(argv[1],"bad") == 0) {
+        if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
+            puts ("\nno devices available\n");
+            return 1;
+        }
+        printf ("\nDevice %d bad blocks:\n", curr_device);
+        nand_print_bad(&nand_dev_desc[curr_device]);
+        return 0;
 
-		printf ("\nDevice %d: ", dev);
-		if (dev >= CFG_MAX_NAND_DEVICE) {
-			puts ("unknown device\n");
-			return 1;
-		}
-		nand_print(&nand_dev_desc[dev]);
-		/*nand_print (dev);*/
+    }
+    printf ("Usage:\n%s\n", cmdtp->usage);
+    return 1;
+    case 3:
+    if (strcmp(argv[1],"device") == 0) {
+        int dev = (int)simple_strtoul(argv[2], NULL, 10);
 
-		if (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN) {
-			return 1;
-		}
+        printf ("\nDevice %d: ", dev);
+        if (dev >= CFG_MAX_NAND_DEVICE) {
+            puts ("unknown device\n");
+            return 1;
+        }
+        nand_print(&nand_dev_desc[dev]);
+        /*nand_print (dev);*/
+
+        if (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN) {
+            return 1;
+        }
 
-		curr_device = dev;
+        curr_device = dev;
 
-		puts ("... is now current device\n");
+        puts ("... is now current device\n");
 
-		return 0;
-	}
-	else if (strcmp(argv[1],"erase") == 0 && strcmp(argv[2], "clean") == 0) {
-		struct nand_chip* nand = &nand_dev_desc[curr_device];
-		ulong off = 0;
-		ulong size = nand->totlen;
-		int ret;
+        return 0;
+    }
+    else if (strcmp(argv[1],"erase") == 0 && strcmp(argv[2], "clean") == 0) {
+        struct nand_chip* nand = &nand_dev_desc[curr_device];
+        ulong off = 0;
+        ulong size = nand->totlen;
+        int ret;
 
-		printf ("\nNAND erase: device %d offset %ld, size %ld ... ",
-			curr_device, off, size);
+        printf ("\nNAND erase: device %d offset %ld, size %ld ... ",
+            curr_device, off, size);
 
-		ret = nand_legacy_erase (nand, off, size, 1);
+        ret = nand_legacy_erase (nand, off, size, 1);
 
-		printf("%s\n", ret ? "ERROR" : "OK");
+        printf("%s\n", ret ? "ERROR" : "OK");
 
-		return ret;
-	}
+        return ret;
+    }
 
-	printf ("Usage:\n%s\n", cmdtp->usage);
-	return 1;
+    printf ("Usage:\n%s\n", cmdtp->usage);
+    return 1;
     default:
-	/* at least 4 args */
+    /* at least 4 args */
 
-	if (strncmp(argv[1], "read", 4) == 0 ||
-	    strncmp(argv[1], "write", 5) == 0) {
-		ulong addr = simple_strtoul(argv[2], NULL, 16);
-		ulong off  = simple_strtoul(argv[3], NULL, 16);
-		ulong size = simple_strtoul(argv[4], NULL, 16);
-		int cmd    = (strncmp(argv[1], "read", 4) == 0) ?
-				NANDRW_READ : NANDRW_WRITE;
-		int ret, total;
-		char* cmdtail = strchr(argv[1], '.');
-
-		if (cmdtail && !strncmp(cmdtail, ".oob", 2)) {
-			/* read out-of-band data */
-			if (cmd & NANDRW_READ) {
-				ret = nand_read_oob(nand_dev_desc + curr_device,
-						    off, size, (size_t *)&total,
-						    (u_char*)addr);
-			}
-			else {
-				ret = nand_write_oob(nand_dev_desc + curr_device,
-						     off, size, (size_t *)&total,
-						     (u_char*)addr);
-			}
-			return ret;
-		}
-		else if (cmdtail && !strncmp(cmdtail, ".jffs2", 2))
-			cmd |= NANDRW_JFFS2;	/* skip bad blocks */
-		else if (cmdtail && !strncmp(cmdtail, ".jffs2s", 2)) {
-			cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
-			if (cmd & NANDRW_READ)
-				cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
-		}
+    if (strncmp(argv[1], "read", 4) == 0 ||
+        strncmp(argv[1], "write", 5) == 0) {
+        ulong addr = simple_strtoul(argv[2], NULL, 16);
+        ulong off  = simple_strtoul(argv[3], NULL, 16);
+        ulong size = simple_strtoul(argv[4], NULL, 16);
+        int cmd    = (strncmp(argv[1], "read", 4) == 0) ?
+                NANDRW_READ : NANDRW_WRITE;
+        int ret, total;
+        char* cmdtail = strchr(argv[1], '.');
+
+        if (cmdtail && !strncmp(cmdtail, ".oob", 2)) {
+            /* read out-of-band data */
+            if (cmd & NANDRW_READ) {
+                ret = nand_read_oob(nand_dev_desc + curr_device,
+                            off, size, (size_t *)&total,
+                            (u_char*)addr);
+            }
+            else {
+                ret = nand_write_oob(nand_dev_desc + curr_device,
+                             off, size, (size_t *)&total,
+                             (u_char*)addr);
+            }
+            return ret;
+        }
+        else if (cmdtail && !strncmp(cmdtail, ".jffs2", 2))
+            cmd |= NANDRW_JFFS2;    /* skip bad blocks */
+        else if (cmdtail && !strncmp(cmdtail, ".jffs2s", 2)) {
+            cmd |= NANDRW_JFFS2;    /* skip bad blocks (on read too) */
+            if (cmd & NANDRW_READ)
+                cmd |= NANDRW_JFFS2_SKIP;   /* skip bad blocks (on read too) */
+        }
 #ifdef SXNI855T
-		/* need ".e" same as ".j" for compatibility with older units */
-		else if (cmdtail && !strcmp(cmdtail, ".e"))
-			cmd |= NANDRW_JFFS2;	/* skip bad blocks */
+        /* need ".e" same as ".j" for compatibility with older units */
+        else if (cmdtail && !strcmp(cmdtail, ".e"))
+            cmd |= NANDRW_JFFS2;    /* skip bad blocks */
 #endif
 #ifdef CFG_NAND_SKIP_BAD_DOT_I
-		/* need ".i" same as ".jffs2s" for compatibility with older units (esd) */
-		/* ".i" for image -> read skips bad block (no 0xff) */
-		else if (cmdtail && !strcmp(cmdtail, ".i")) {
-			cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
-			if (cmd & NANDRW_READ)
-				cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
-		}
+        /* need ".i" same as ".jffs2s" for compatibility with older units (esd) */
+        /* ".i" for image -> read skips bad block (no 0xff) */
+        else if (cmdtail && !strcmp(cmdtail, ".i")) {
+            cmd |= NANDRW_JFFS2;    /* skip bad blocks (on read too) */
+            if (cmd & NANDRW_READ)
+                cmd |= NANDRW_JFFS2_SKIP;   /* skip bad blocks (on read too) */
+        }
 #endif /* CFG_NAND_SKIP_BAD_DOT_I */
-		else if (cmdtail) {
-			printf ("Usage:\n%s\n", cmdtp->usage);
-			return 1;
-		}
-
-		printf ("\nNAND %s: device %d offset %ld, size %ld ...\n",
-			(cmd & NANDRW_READ) ? "read" : "write",
-			curr_device, off, size);
-
-		ret = nand_legacy_rw(nand_dev_desc + curr_device, cmd, off, size,
-			     (size_t *)&total, (u_char*)addr);
-
-		printf (" %d bytes %s: %s\n", total,
-			(cmd & NANDRW_READ) ? "read" : "written",
-			ret ? "ERROR" : "OK");
-
-		return ret;
-	} else if (strcmp(argv[1],"erase") == 0 &&
-		   (argc == 4 || strcmp("clean", argv[2]) == 0)) {
-		int clean = argc == 5;
-		ulong off = simple_strtoul(argv[2 + clean], NULL, 16);
-		ulong size = simple_strtoul(argv[3 + clean], NULL, 16);
-		int ret;
-
-		printf ("\nNAND erase: device %d offset %ld, size %ld ...\n",
-			curr_device, off, size);
-
-		ret = nand_legacy_erase (nand_dev_desc + curr_device,
-					off, size, clean);
-
-		printf("%s\n", ret ? "ERROR" : "OK");
-
-		return ret;
-	} else {
-		printf ("Usage:\n%s\n", cmdtp->usage);
-		rcode = 1;
-	}
+        else if (cmdtail) {
+            printf ("Usage:\n%s\n", cmdtp->usage);
+            return 1;
+        }
+
+        printf ("\nNAND %s: device %d offset %ld, size %ld ...\n",
+            (cmd & NANDRW_READ) ? "read" : "write",
+            curr_device, off, size);
+
+        ret = nand_legacy_rw(nand_dev_desc + curr_device, cmd, off, size,
+                 (size_t *)&total, (u_char*)addr);
+
+        printf (" %d bytes %s: %s\n", total,
+            (cmd & NANDRW_READ) ? "read" : "written",
+            ret ? "ERROR" : "OK");
+
+        return ret;
+    } else if (strcmp(argv[1],"erase") == 0 &&
+           (argc == 4 || strcmp("clean", argv[2]) == 0)) {
+        int clean = argc == 5;
+        ulong off = simple_strtoul(argv[2 + clean], NULL, 16);
+        ulong size = simple_strtoul(argv[3 + clean], NULL, 16);
+        int ret;
+
+        printf ("\nNAND erase: device %d offset %ld, size %ld ...\n",
+            curr_device, off, size);
+
+        ret = nand_legacy_erase (nand_dev_desc + curr_device,
+                    off, size, clean);
+
+        printf("%s\n", ret ? "ERROR" : "OK");
+
+        return ret;
+    } else {
+        printf ("Usage:\n%s\n", cmdtp->usage);
+        rcode = 1;
+    }
 
-	return rcode;
+    return rcode;
     }
 }
 
 U_BOOT_CMD(
-	nand,	5,	1,	do_nand,
-	"nand    - legacy NAND sub-system\n",
-	"info  - show available NAND devices\n"
-	"nand device [dev] - show or set current device\n"
-	"nand read[.jffs2[s]]  addr off size\n"
-	"nand write[.jffs2] addr off size - read/write `size' bytes starting\n"
-	"    at offset `off' to/from memory address `addr'\n"
-	"nand erase [clean] [off size] - erase `size' bytes from\n"
-	"    offset `off' (entire device if not specified)\n"
-	"nand bad - show bad blocks\n"
-	"nand read.oob addr off size - read out-of-band data\n"
-	"nand write.oob addr off size - read out-of-band data\n"
+    nand,   5,  1,  do_nand,
+    "nand    - legacy NAND sub-system\n",
+    "info  - show available NAND devices\n"
+    "nand device [dev] - show or set current device\n"
+    "nand read[.jffs2[s]]  addr off size\n"
+    "nand write[.jffs2] addr off size - read/write `size' bytes starting\n"
+    "    at offset `off' to/from memory address `addr'\n"
+    "nand erase [clean] [off size] - erase `size' bytes from\n"
+    "    offset `off' (entire device if not specified)\n"
+    "nand bad - show bad blocks\n"
+    "nand read.oob addr off size - read out-of-band data\n"
+    "nand write.oob addr off size - read out-of-band data\n"
 );
 
 int do_nandboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	char *boot_device = NULL;
-	char *ep;
-	int dev;
-	ulong cnt;
-	ulong addr;
-	ulong offset = 0;
-	image_header_t *hdr;
-	int rcode = 0;
-	switch (argc) {
-	case 1:
-		addr = CFG_LOAD_ADDR;
-		boot_device = getenv ("bootdevice");
-		break;
-	case 2:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = getenv ("bootdevice");
-		break;
-	case 3:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = argv[2];
-		break;
-	case 4:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = argv[2];
-		offset = simple_strtoul(argv[3], NULL, 16);
-		break;
-	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	if (!boot_device) {
-		puts ("\n** No boot device **\n");
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	dev = simple_strtoul(boot_device, &ep, 16);
-
-	if ((dev >= CFG_MAX_NAND_DEVICE) ||
-	    (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN)) {
-		printf ("\n** Device %d not available\n", dev);
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	printf ("\nLoading from device %d: %s at 0x%lx (offset 0x%lx)\n",
-		dev, nand_dev_desc[dev].name, nand_dev_desc[dev].IO_ADDR,
-		offset);
-
-	if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ, offset,
-			SECTORSIZE, NULL, (u_char *)addr)) {
-		printf ("** Read error on %d\n", dev);
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	hdr = (image_header_t *)addr;
-
-	if (ntohl(hdr->ih_magic) == IH_MAGIC) {
-
-		print_image_hdr (hdr);
-
-		cnt = (ntohl(hdr->ih_size) + sizeof(image_header_t));
-		cnt -= SECTORSIZE;
-	} else {
-		printf ("\n** Bad Magic Number 0x%x **\n", ntohl(hdr->ih_magic));
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ,
-			offset + SECTORSIZE, cnt, NULL,
-			(u_char *)(addr+SECTORSIZE))) {
-		printf ("** Read error on %d\n", dev);
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	/* Loading ok, update default load address */
-
-	load_addr = addr;
-
-	/* Check if we should attempt an auto-start */
-	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep,"yes") == 0)) {
-		char *local_args[2];
-		extern int do_bootm (cmd_tbl_t *, int, int, char *[]);
-
-		local_args[0] = argv[0];
-		local_args[1] = NULL;
-
-		printf ("Automatic boot of image at addr 0x%08lx ...\n", addr);
-
-		do_bootm (cmdtp, 0, 1, local_args);
-		rcode = 1;
-	}
-	return rcode;
+    char *boot_device = NULL;
+    char *ep;
+    int dev;
+    ulong cnt;
+    ulong addr;
+    ulong offset = 0;
+    image_header_t *hdr;
+    int rcode = 0;
+    switch (argc) {
+    case 1:
+        addr = CFG_LOAD_ADDR;
+        boot_device = getenv ("bootdevice");
+        break;
+    case 2:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = getenv ("bootdevice");
+        break;
+    case 3:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = argv[2];
+        break;
+    case 4:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = argv[2];
+        offset = simple_strtoul(argv[3], NULL, 16);
+        break;
+    default:
+        printf ("Usage:\n%s\n", cmdtp->usage);
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    if (!boot_device) {
+        puts ("\n** No boot device **\n");
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    dev = simple_strtoul(boot_device, &ep, 16);
+
+    if ((dev >= CFG_MAX_NAND_DEVICE) ||
+        (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN)) {
+        printf ("\n** Device %d not available\n", dev);
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    printf ("\nLoading from device %d: %s at 0x%lx (offset 0x%lx)\n",
+        dev, nand_dev_desc[dev].name, nand_dev_desc[dev].IO_ADDR,
+        offset);
+
+    if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ, offset,
+            SECTORSIZE, NULL, (u_char *)addr)) {
+        printf ("** Read error on %d\n", dev);
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    hdr = (image_header_t *)addr;
+
+    if (ntohl(hdr->ih_magic) == IH_MAGIC) {
+
+        print_image_hdr (hdr);
+
+        cnt = (ntohl(hdr->ih_size) + sizeof(image_header_t));
+        cnt -= SECTORSIZE;
+    } else {
+        printf ("\n** Bad Magic Number 0x%x **\n", ntohl(hdr->ih_magic));
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ,
+            offset + SECTORSIZE, cnt, NULL,
+            (u_char *)(addr+SECTORSIZE))) {
+        printf ("** Read error on %d\n", dev);
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    /* Loading ok, update default load address */
+
+    load_addr = addr;
+
+    /* Check if we should attempt an auto-start */
+    if (((ep = getenv("autostart")) != NULL) && (strcmp(ep,"yes") == 0)) {
+        char *local_args[2];
+        extern int do_bootm (cmd_tbl_t *, int, int, char *[]);
+
+        local_args[0] = argv[0];
+        local_args[1] = NULL;
+
+        printf ("Automatic boot of image at addr 0x%08lx ...\n", addr);
+
+        do_bootm (cmdtp, 0, 1, local_args);
+        rcode = 1;
+    }
+    return rcode;
 }
 
 U_BOOT_CMD(
-	nboot,	4,	1,	do_nandboot,
-	"nboot   - boot from NAND device\n",
-	"loadAddr dev\n"
+    nboot,  4,  1,  do_nandboot,
+    "nboot   - boot from NAND device\n",
+    "loadAddr dev\n"
 );
 
 #endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
diff -urN u-boot-1.1.6/common/cmd_nand_legacy.c u-boot-1.1.6_fdt/common/cmd_nand_legacy.c
--- u-boot-1.1.6/common/cmd_nand_legacy.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/cmd_nand_legacy.c	2018-10-22 15:53:21.541641225 +0800
@@ -0,0 +1,999 @@
+/*
+ * Driver for NAND support, Rick Bronson
+ * borrowed heavily from:
+ * (c) 1999 Machine Vision Holdings, Inc.
+ * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
+ *
+ * Added 16-bit nand support
+ * (C) 2004 Texas Instruments
+ */
+
+#include <common.h>
+
+
+#ifndef CFG_NAND_LEGACY
+/*
+ *
+ * New NAND support
+ *
+ */
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+
+#include <command.h>
+#include <watchdog.h>
+#include <malloc.h>
+#include <asm/byteorder.h>
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+# include <status_led.h>
+# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+#else
+# define SHOW_BOOT_PROGRESS(arg)
+#endif
+
+#include <jffs2/jffs2.h>
+#include <nand.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+
+/* parition handling routines */
+int mtdparts_init(void);
+int id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num);
+int find_dev_and_part(const char *id, struct mtd_device **dev,
+		u8 *part_num, struct part_info **part);
+#endif
+
+extern nand_info_t nand_info[];       /* info for NAND chips */
+
+static int nand_dump_oob(nand_info_t *nand, ulong off)
+{
+	return 0;
+}
+
+static int nand_dump(nand_info_t *nand, ulong off)
+{
+	int i;
+	u_char *buf, *p;
+
+	buf = malloc(nand->oobblock + nand->oobsize);
+	if (!buf) {
+		puts("No memory for page buffer\n");
+		return 1;
+	}
+	off &= ~(nand->oobblock - 1);
+	i = nand_read_raw(nand, buf, off, nand->oobblock, nand->oobsize);
+	if (i < 0) {
+		printf("Error (%d) reading page %08x\n", i, off);
+		free(buf);
+		return 1;
+	}
+	printf("Page %08x dump:\n", off);
+	i = nand->oobblock >> 4; p = buf;
+	while (i--) {
+		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
+			"  %02x %02x %02x %02x %02x %02x %02x %02x\n",
+			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+		p += 16;
+	}
+	puts("OOB:\n");
+	i = nand->oobsize >> 3;
+	while (i--) {
+		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
+			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+		p += 8;
+	}
+	free(buf);
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static inline int str2long(char *p, ulong *num)
+{
+	char *endptr;
+
+	*num = simple_strtoul(p, &endptr, 16);
+	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+}
+
+static int
+arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, ulong *size)
+{
+	int idx = nand_curr_device;
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+	struct mtd_device *dev;
+	struct part_info *part;
+	u8 pnum;
+
+	if (argc >= 1 && !(str2long(argv[0], off))) {
+		if ((mtdparts_init() == 0) &&
+		    (find_dev_and_part(argv[0], &dev, &pnum, &part) == 0)) {
+			if (dev->id->type != MTD_DEV_TYPE_NAND) {
+				puts("not a NAND device\n");
+				return -1;
+			}
+			*off = part->offset;
+			if (argc >= 2) {
+				if (!(str2long(argv[1], size))) {
+					printf("'%s' is not a number\n", argv[1]);
+					return -1;
+				}
+				if (*size > part->size)
+					*size = part->size;
+			} else {
+				*size = part->size;
+			}
+			idx = dev->id->num;
+			*nand = nand_info[idx];
+			goto out;
+		}
+	}
+#endif
+
+	if (argc >= 1) {
+		if (!(str2long(argv[0], off))) {
+			printf("'%s' is not a number\n", argv[0]);
+			return -1;
+		}
+	} else {
+		*off = 0;
+	}
+
+	if (argc >= 2) {
+		if (!(str2long(argv[1], size))) {
+			printf("'%s' is not a number\n", argv[1]);
+			return -1;
+		}
+	} else {
+		*size = nand->size - *off;
+	}
+
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+out:
+#endif
+	printf("device %d ", idx);
+	if (*size == nand->size)
+		puts("whole chip\n");
+	else
+		printf("offset 0x%x, size 0x%x\n", *off, *size);
+	return 0;
+}
+
+int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	int i, dev, ret;
+	ulong addr, off, size;
+	char *cmd, *s;
+	nand_info_t *nand;
+	int quiet = 0;
+	const char *quiet_str = getenv("quiet");
+
+	/* at least two arguments please */
+	if (argc < 2)
+		goto usage;
+
+	if (quiet_str)
+		quiet = simple_strtoul(quiet_str, NULL, 0) != 0;
+
+	cmd = argv[1];
+
+	if (strcmp(cmd, "info") == 0) {
+
+		putc('\n');
+		for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
+			if (nand_info[i].name)
+				printf("Device %d: %s, sector size %lu KiB\n",
+					i, nand_info[i].name,
+					nand_info[i].erasesize >> 10);
+		}
+		return 0;
+	}
+
+	if (strcmp(cmd, "device") == 0) {
+
+		if (argc < 3) {
+			if ((nand_curr_device < 0) ||
+			    (nand_curr_device >= CFG_MAX_NAND_DEVICE))
+				puts("\nno devices available\n");
+			else
+				printf("\nDevice %d: %s\n", nand_curr_device,
+					nand_info[nand_curr_device].name);
+			return 0;
+		}
+		dev = (int)simple_strtoul(argv[2], NULL, 10);
+		if (dev < 0 || dev >= CFG_MAX_NAND_DEVICE || !nand_info[dev].name) {
+			puts("No such device\n");
+			return 1;
+		}
+		printf("Device %d: %s", dev, nand_info[dev].name);
+		puts("... is now current device\n");
+		nand_curr_device = dev;
+
+#ifdef CFG_NAND_SELECT_DEVICE
+		/*
+		 * Select the chip in the board/cpu specific driver
+		 */
+		board_nand_select_device(nand_info[dev].priv, dev);
+#endif
+
+		return 0;
+	}
+
+	if (strcmp(cmd, "bad") != 0 && strcmp(cmd, "erase") != 0 &&
+	    strncmp(cmd, "dump", 4) != 0 &&
+	    strncmp(cmd, "read", 4) != 0 && strncmp(cmd, "write", 5) != 0 &&
+	    strcmp(cmd, "scrub") != 0 && strcmp(cmd, "markbad") != 0 &&
+	    strcmp(cmd, "biterr") != 0 &&
+	    strcmp(cmd, "lock") != 0 && strcmp(cmd, "unlock") != 0 )
+		goto usage;
+
+	/* the following commands operate on the current device */
+	if (nand_curr_device < 0 || nand_curr_device >= CFG_MAX_NAND_DEVICE ||
+	    !nand_info[nand_curr_device].name) {
+		puts("\nno devices available\n");
+		return 1;
+	}
+	nand = &nand_info[nand_curr_device];
+
+	if (strcmp(cmd, "bad") == 0) {
+		printf("\nDevice %d bad blocks:\n", nand_curr_device);
+		for (off = 0; off < nand->size; off += nand->erasesize)
+			if (nand_block_isbad(nand, off))
+				printf("  %08x\n", off);
+		return 0;
+	}
+
+	/*
+	 * Syntax is:
+	 *   0    1     2       3    4
+	 *   nand erase [clean] [off size]
+	 */
+	if (strcmp(cmd, "erase") == 0 || strcmp(cmd, "scrub") == 0) {
+		nand_erase_options_t opts;
+		/* "clean" at index 2 means request to write cleanmarker */
+		int clean = argc > 2 && !strcmp("clean", argv[2]);
+		int o = clean ? 3 : 2;
+		int scrub = !strcmp(cmd, "scrub");
+
+		printf("\nNAND %s: ", scrub ? "scrub" : "erase");
+		/* skip first two or three arguments, look for offset and size */
+		if (arg_off_size(argc - o, argv + o, nand, &off, &size) != 0)
+			return 1;
+
+		memset(&opts, 0, sizeof(opts));
+		opts.offset = off;
+		opts.length = size;
+		opts.jffs2  = clean;
+		opts.quiet  = quiet;
+
+		if (scrub) {
+			puts("Warning: "
+			     "scrub option will erase all factory set "
+			     "bad blocks!\n"
+			     "         "
+			     "There is no reliable way to recover them.\n"
+			     "         "
+			     "Use this command only for testing purposes "
+			     "if you\n"
+			     "         "
+			     "are sure of what you are doing!\n"
+			     "\nReally scrub this NAND flash? <y/N>\n");
+
+			if (getc() == 'y' && getc() == '\r') {
+				opts.scrub = 1;
+			} else {
+				puts("scrub aborted\n");
+				return -1;
+			}
+		}
+		ret = nand_erase_opts(nand, &opts);
+		printf("%s\n", ret ? "ERROR" : "OK");
+
+		return ret == 0 ? 0 : 1;
+	}
+
+	if (strncmp(cmd, "dump", 4) == 0) {
+		if (argc < 3)
+			goto usage;
+
+		s = strchr(cmd, '.');
+		off = (int)simple_strtoul(argv[2], NULL, 16);
+
+		if (s != NULL && strcmp(s, ".oob") == 0)
+			ret = nand_dump_oob(nand, off);
+		else
+			ret = nand_dump(nand, off);
+
+		return ret == 0 ? 1 : 0;
+
+	}
+
+	/* read write */
+	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
+		int read;
+
+		if (argc < 4)
+			goto usage;
+
+		addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+
+		read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
+		printf("\nNAND %s: ", read ? "read" : "write");
+		if (arg_off_size(argc - 3, argv + 3, nand, &off, &size) != 0)
+			return 1;
+
+		s = strchr(cmd, '.');
+		if (s != NULL &&
+		    (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i"))) {
+			if (read) {
+				/* read */
+				nand_read_options_t opts;
+				memset(&opts, 0, sizeof(opts));
+				opts.buffer	= (u_char*) addr;
+				opts.length	= size;
+				opts.offset	= off;
+				opts.quiet      = quiet;
+				ret = nand_read_opts(nand, &opts);
+			} else {
+				/* write */
+				nand_write_options_t opts;
+				memset(&opts, 0, sizeof(opts));
+				opts.buffer	= (u_char*) addr;
+				opts.length	= size;
+				opts.offset	= off;
+				/* opts.forcejffs2 = 1; */
+				opts.pad	= 1;
+				opts.blockalign = 1;
+				opts.quiet      = quiet;
+				ret = nand_write_opts(nand, &opts);
+			}
+		} else {
+			if (read)
+				ret = nand_read(nand, off, &size, (u_char *)addr);
+			else
+				ret = nand_write(nand, off, &size, (u_char *)addr);
+		}
+
+		printf(" %d bytes %s: %s\n", size,
+		       read ? "read" : "written", ret ? "ERROR" : "OK");
+
+		return ret == 0 ? 0 : 1;
+	}
+
+	if (strcmp(cmd, "markbad") == 0) {
+		addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+
+		int ret = nand->block_markbad(nand, addr);
+		if (ret == 0) {
+			printf("block 0x%08lx successfully marked as bad\n",
+			       (ulong) addr);
+			return 0;
+		} else {
+			printf("block 0x%08lx NOT marked as bad! ERROR %d\n",
+			       (ulong) addr, ret);
+		}
+		return 1;
+	}
+	if (strcmp(cmd, "biterr") == 0) {
+		/* todo */
+		return 1;
+	}
+
+	if (strcmp(cmd, "lock") == 0) {
+		int tight  = 0;
+		int status = 0;
+		if (argc == 3) {
+			if (!strcmp("tight", argv[2]))
+				tight = 1;
+			if (!strcmp("status", argv[2]))
+				status = 1;
+		}
+
+		if (status) {
+			ulong block_start = 0;
+			ulong off;
+			int last_status = -1;
+
+			struct nand_chip *nand_chip = nand->priv;
+			/* check the WP bit */
+			nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
+			printf("device is %swrite protected\n",
+			       (nand_chip->read_byte(nand) & 0x80 ?
+				"NOT " : "" ) );
+
+			for (off = 0; off < nand->size; off += nand->oobblock) {
+				int s = nand_get_lock_status(nand, off);
+
+				/* print message only if status has changed
+				 * or at end of chip
+				 */
+				if (off == nand->size - nand->oobblock
+				    || (s != last_status && off != 0))	{
+
+					printf("%08x - %08x: %8d pages %s%s%s\n",
+					       block_start,
+					       off-1,
+					       (off-block_start)/nand->oobblock,
+					       ((last_status & NAND_LOCK_STATUS_TIGHT) ? "TIGHT " : ""),
+					       ((last_status & NAND_LOCK_STATUS_LOCK) ? "LOCK " : ""),
+					       ((last_status & NAND_LOCK_STATUS_UNLOCK) ? "UNLOCK " : ""));
+				}
+
+				last_status = s;
+		       }
+		} else {
+			if (!nand_lock(nand, tight)) {
+				puts("NAND flash successfully locked\n");
+			} else {
+				puts("Error locking NAND flash\n");
+				return 1;
+			}
+		}
+		return 0;
+	}
+
+	if (strcmp(cmd, "unlock") == 0) {
+		if (arg_off_size(argc - 2, argv + 2, nand, &off, &size) < 0)
+			return 1;
+
+		if (!nand_unlock(nand, off, size)) {
+			puts("NAND flash successfully unlocked\n");
+		} else {
+			puts("Error unlocking NAND flash, "
+			     "write and erase will probably fail\n");
+			return 1;
+		}
+		return 0;
+	}
+
+usage:
+	printf("Usage:\n%s\n", cmdtp->usage);
+	return 1;
+}
+
+U_BOOT_CMD(nand, 5, 1, do_nand,
+	"nand    - NAND sub-system\n",
+	"info                  - show available NAND devices\n"
+	"nand device [dev]     - show or set current device\n"
+	"nand read[.jffs2]     - addr off|partition size\n"
+	"nand write[.jffs2]    - addr off|partiton size - read/write `size' bytes starting\n"
+	"    at offset `off' to/from memory address `addr'\n"
+	"nand erase [clean] [off size] - erase `size' bytes from\n"
+	"    offset `off' (entire device if not specified)\n"
+	"nand bad - show bad blocks\n"
+	"nand dump[.oob] off - dump page\n"
+	"nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n"
+	"nand markbad off - mark bad block at offset (UNSAFE)\n"
+	"nand biterr off - make a bit error at offset (UNSAFE)\n"
+	"nand lock [tight] [status] - bring nand to lock state or display locked pages\n"
+	"nand unlock [offset] [size] - unlock section\n");
+
+static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
+			   ulong offset, ulong addr, char *cmd)
+{
+	int r;
+	char *ep;
+	ulong cnt;
+	image_header_t *hdr;
+
+	printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
+
+	cnt = nand->oobblock;
+	r = nand_read(nand, offset, &cnt, (u_char *) addr);
+	if (r) {
+		puts("** Read error\n");
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	hdr = (image_header_t *) addr;
+
+	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+		printf("\n** Bad Magic Number 0x%x **\n", hdr->ih_magic);
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	print_image_hdr(hdr);
+
+	cnt = (ntohl(hdr->ih_size) + sizeof (image_header_t));
+
+	r = nand_read(nand, offset, &cnt, (u_char *) addr);
+	if (r) {
+		puts("** Read error\n");
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	/* Loading ok, update default load address */
+
+	load_addr = addr;
+
+	/* Check if we should attempt an auto-start */
+	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
+		char *local_args[2];
+		extern int do_bootm(cmd_tbl_t *, int, int, char *[]);
+
+		local_args[0] = cmd;
+		local_args[1] = NULL;
+
+		printf("Automatic boot of image at addr 0x%08lx ...\n", addr);
+
+		do_bootm(cmdtp, 0, 1, local_args);
+		return 1;
+	}
+	return 0;
+}
+
+int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	char *boot_device = NULL;
+	int idx;
+	ulong addr, offset = 0;
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+	struct mtd_device *dev;
+	struct part_info *part;
+	u8 pnum;
+
+	if (argc >= 2) {
+		char *p = (argc == 2) ? argv[1] : argv[2];
+		if (!(str2long(p, &addr)) && (mtdparts_init() == 0) &&
+		    (find_dev_and_part(p, &dev, &pnum, &part) == 0)) {
+			if (dev->id->type != MTD_DEV_TYPE_NAND) {
+				puts("Not a NAND device\n");
+				return 1;
+			}
+			if (argc > 3)
+				goto usage;
+			if (argc == 3)
+				addr = simple_strtoul(argv[2], NULL, 16);
+			else
+				addr = CFG_LOAD_ADDR;
+			return nand_load_image(cmdtp, &nand_info[dev->id->num],
+					       part->offset, addr, argv[0]);
+		}
+	}
+#endif
+
+	switch (argc) {
+	case 1:
+		addr = CFG_LOAD_ADDR;
+		boot_device = getenv("bootdevice");
+		break;
+	case 2:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = getenv("bootdevice");
+		break;
+	case 3:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = argv[2];
+		break;
+	case 4:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = argv[2];
+		offset = simple_strtoul(argv[3], NULL, 16);
+		break;
+	default:
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+usage:
+#endif
+		printf("Usage:\n%s\n", cmdtp->usage);
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	if (!boot_device) {
+		puts("\n** No boot device **\n");
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	idx = simple_strtoul(boot_device, NULL, 16);
+
+	if (idx < 0 || idx >= CFG_MAX_NAND_DEVICE || !nand_info[idx].name) {
+		printf("\n** Device %d not available\n", idx);
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	return nand_load_image(cmdtp, &nand_info[idx], offset, addr, argv[0]);
+}
+
+U_BOOT_CMD(nboot, 4, 1, do_nandboot,
+	"nboot   - boot from NAND device\n",
+	"[partition] | [[[loadAddr] dev] offset]\n");
+
+#endif				/* (CONFIG_COMMANDS & CFG_CMD_NAND) */
+
+#else /* CFG_NAND_LEGACY */
+/*
+ *
+ * Legacy NAND support - to be phased out
+ *
+ */
+#include <command.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <watchdog.h>
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+# include <status_led.h>
+# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+#else
+# define SHOW_BOOT_PROGRESS(arg)
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#include <linux/mtd/nand_legacy.h>
+#if 0
+#include <linux/mtd/nand_ids.h>
+#include <jffs2/jffs2.h>
+#endif
+
+#ifdef CONFIG_OMAP1510
+void archflashwp(void *archdata, int wp);
+#endif
+
+#define ROUND_DOWN(value,boundary)      ((value) & (~((boundary)-1)))
+
+#undef	NAND_DEBUG
+#undef	PSYCHO_DEBUG
+
+/* ****************** WARNING *********************
+ * When ALLOW_ERASE_BAD_DEBUG is non-zero the erase command will
+ * erase (or at least attempt to erase) blocks that are marked
+ * bad. This can be very handy if you are _sure_ that the block
+ * is OK, say because you marked a good block bad to test bad
+ * block handling and you are done testing, or if you have
+ * accidentally marked blocks bad.
+ *
+ * Erasing factory marked bad blocks is a _bad_ idea. If the
+ * erase succeeds there is no reliable way to find them again,
+ * and attempting to program or erase bad blocks can affect
+ * the data in _other_ (good) blocks.
+ */
+#define	 ALLOW_ERASE_BAD_DEBUG 0
+
+#define CONFIG_MTD_NAND_ECC  /* enable ECC */
+#define CONFIG_MTD_NAND_ECC_JFFS2
+
+/* bits for nand_legacy_rw() `cmd'; or together as needed */
+#define NANDRW_READ	0x01
+#define NANDRW_WRITE	0x00
+#define NANDRW_JFFS2	0x02
+#define NANDRW_JFFS2_SKIP	0x04
+#define NANDRW_YAFFS	0x08    /* to write yaffs image, www.100ask.net */
+
+/*
+ * Imports from nand_legacy.c
+ */
+extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+extern int curr_device;
+extern int nand_legacy_erase(struct nand_chip *nand, size_t ofs,
+			    size_t len, int clean);
+extern int nand_legacy_rw(struct nand_chip *nand, int cmd, size_t start,
+			 size_t len, size_t *retlen, u_char *buf);
+extern void nand_print(struct nand_chip *nand);
+extern void nand_print_bad(struct nand_chip *nand);
+extern int nand_read_oob(struct nand_chip *nand, size_t ofs,
+			       size_t len, size_t *retlen, u_char *buf);
+extern int nand_write_oob(struct nand_chip *nand, size_t ofs,
+				size_t len, size_t *retlen, const u_char *buf);
+
+
+int do_nand (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int rcode = 0;
+
+    switch (argc) {
+    case 0:
+    case 1:
+	printf ("Usage:\n%s\n", cmdtp->usage);
+	return 1;
+    case 2:
+	if (strcmp(argv[1],"info") == 0) {
+		int i;
+
+		putc ('\n');
+
+		for (i=0; i<CFG_MAX_NAND_DEVICE; ++i) {
+			if(nand_dev_desc[i].ChipID == NAND_ChipID_UNKNOWN)
+				continue; /* list only known devices */
+			printf ("Device %d: ", i);
+			nand_print(&nand_dev_desc[i]);
+		}
+		return 0;
+
+	} else if (strcmp(argv[1],"device") == 0) {
+		if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
+			puts ("\nno devices available\n");
+			return 1;
+		}
+		printf ("\nDevice %d: ", curr_device);
+		nand_print(&nand_dev_desc[curr_device]);
+		return 0;
+
+	} else if (strcmp(argv[1],"bad") == 0) {
+		if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
+			puts ("\nno devices available\n");
+			return 1;
+		}
+		printf ("\nDevice %d bad blocks:\n", curr_device);
+		nand_print_bad(&nand_dev_desc[curr_device]);
+		return 0;
+
+	}
+	printf ("Usage:\n%s\n", cmdtp->usage);
+	return 1;
+    case 3:
+	if (strcmp(argv[1],"device") == 0) {
+		int dev = (int)simple_strtoul(argv[2], NULL, 10);
+
+		printf ("\nDevice %d: ", dev);
+		if (dev >= CFG_MAX_NAND_DEVICE) {
+			puts ("unknown device\n");
+			return 1;
+		}
+		nand_print(&nand_dev_desc[dev]);
+		/*nand_print (dev);*/
+
+		if (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN) {
+			return 1;
+		}
+
+		curr_device = dev;
+
+		puts ("... is now current device\n");
+
+		return 0;
+	}
+	else if (strcmp(argv[1],"erase") == 0 && strcmp(argv[2], "clean") == 0) {
+		struct nand_chip* nand = &nand_dev_desc[curr_device];
+		ulong off = 0;
+		ulong size = nand->totlen;
+		int ret;
+
+		printf ("\nNAND erase: device %d offset %ld, size %ld ... ",
+			curr_device, off, size);
+
+		ret = nand_legacy_erase (nand, off, size, 1);
+
+		printf("%s\n", ret ? "ERROR" : "OK");
+
+		return ret;
+	}
+
+	printf ("Usage:\n%s\n", cmdtp->usage);
+	return 1;
+    default:
+	/* at least 4 args */
+
+	if (strncmp(argv[1], "read", 4) == 0 ||
+	    strncmp(argv[1], "write", 5) == 0) {
+		ulong addr = simple_strtoul(argv[2], NULL, 16);
+		ulong off  = simple_strtoul(argv[3], NULL, 16);
+		ulong size = simple_strtoul(argv[4], NULL, 16);
+		int cmd    = (strncmp(argv[1], "read", 4) == 0) ?
+				NANDRW_READ : NANDRW_WRITE;
+		int ret, total;
+		char* cmdtail = strchr(argv[1], '.');
+
+		// if (cmdtail && !strncmp(cmdtail, ".oob", 2)) {
+		/* fixed by www.100ask.net */
+		if (cmdtail && !strcmp(cmdtail, ".oob")) {
+			/* read out-of-band data */
+			if (cmd & NANDRW_READ) {
+				ret = nand_read_oob(nand_dev_desc + curr_device,
+						    off, size, (size_t *)&total,
+						    (u_char*)addr);
+			}
+			else {
+				ret = nand_write_oob(nand_dev_desc + curr_device,
+						     off, size, (size_t *)&total,
+						     (u_char*)addr);
+			}
+			return ret;
+		}
+		//else if (cmdtail && !strncmp(cmdtail, ".jffs2", 2))
+		/* fixed by www.100ask.net */
+		else if (cmdtail && !strcmp(cmdtail, ".jffs2"))
+			cmd |= NANDRW_JFFS2;	/* skip bad blocks */
+		//else if (cmdtail && !strncmp(cmdtail, ".jffs2s", 2)) {
+		/* fixed by www.100ask.net */
+		else if ((cmd & NANDRW_WRITE) && cmdtail && !strcmp(cmdtail, ".jffs2s")) {
+			cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
+			if (cmd & NANDRW_READ)
+				cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
+		}
+        /* write yaffs image, www.100ask.net */
+		else if (cmdtail && !strcmp(cmdtail, ".yaffs")) {
+			cmd |= NANDRW_YAFFS;
+		}
+#ifdef SXNI855T
+		/* need ".e" same as ".j" for compatibility with older units */
+		else if (cmdtail && !strcmp(cmdtail, ".e"))
+			cmd |= NANDRW_JFFS2;	/* skip bad blocks */
+#endif
+#ifdef CFG_NAND_SKIP_BAD_DOT_I
+		/* need ".i" same as ".jffs2s" for compatibility with older units (esd) */
+		/* ".i" for image -> read skips bad block (no 0xff) */
+		else if (cmdtail && !strcmp(cmdtail, ".i")) {
+			cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
+			if (cmd & NANDRW_READ)
+				cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
+		}
+#endif /* CFG_NAND_SKIP_BAD_DOT_I */
+		else if (cmdtail) {
+			printf ("Usage:\n%s\n", cmdtp->usage);
+			return 1;
+		}
+
+		printf ("\nNAND %s: device %d offset %ld, size %ld ...\n",
+			(cmd & NANDRW_READ) ? "read" : "write",
+			curr_device, off, size);
+
+		ret = nand_legacy_rw(nand_dev_desc + curr_device, cmd, off, size,
+			     (size_t *)&total, (u_char*)addr);
+
+		printf (" %d bytes %s: %s\n", total,
+			(cmd & NANDRW_READ) ? "read" : "written",
+			ret ? "ERROR" : "OK");
+
+		return ret;
+	} else if (strcmp(argv[1],"erase") == 0 &&
+		   (argc == 4 || strcmp("clean", argv[2]) == 0)) {
+		int clean = argc == 5;
+		ulong off = simple_strtoul(argv[2 + clean], NULL, 16);
+		ulong size = simple_strtoul(argv[3 + clean], NULL, 16);
+		int ret;
+
+		printf ("\nNAND erase: device %d offset %ld, size %ld ...\n",
+			curr_device, off, size);
+
+		ret = nand_legacy_erase (nand_dev_desc + curr_device,
+					off, size, clean);
+
+		printf("%s\n", ret ? "ERROR" : "OK");
+
+		return ret;
+	} else {
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		rcode = 1;
+	}
+
+	return rcode;
+    }
+}
+
+U_BOOT_CMD(
+	nand,	5,	1,	do_nand,
+	"nand    - legacy NAND sub-system\n",
+	"info  - show available NAND devices\n"
+	"nand device [dev] - show or set current device\n"
+	"nand read[.jffs2[s]]  addr off size\n"
+	"nand write[.jffs2] addr off size - read/write `size' bytes starting\n"
+	"    at offset `off' to/from memory address `addr'\n"
+	"nand erase [clean] [off size] - erase `size' bytes from\n"
+	"    offset `off' (entire device if not specified)\n"
+	"nand bad - show bad blocks\n"
+	"nand read.oob addr off size - read out-of-band data\n"
+	"nand write.oob addr off size - read out-of-band data\n"
+	"nand write.yaffs addr off size - write the `size' byte yaffs image starting\n"
+	"    at offset `off' from memory address `addr'\n"
+);
+
+int do_nandboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	char *boot_device = NULL;
+	char *ep;
+	int dev;
+	ulong cnt;
+	ulong addr;
+	ulong offset = 0;
+	image_header_t *hdr;
+	int rcode = 0;
+	switch (argc) {
+	case 1:
+		addr = CFG_LOAD_ADDR;
+		boot_device = getenv ("bootdevice");
+		break;
+	case 2:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = getenv ("bootdevice");
+		break;
+	case 3:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = argv[2];
+		break;
+	case 4:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = argv[2];
+		offset = simple_strtoul(argv[3], NULL, 16);
+		break;
+	default:
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	if (!boot_device) {
+		puts ("\n** No boot device **\n");
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	dev = simple_strtoul(boot_device, &ep, 16);
+
+	if ((dev >= CFG_MAX_NAND_DEVICE) ||
+	    (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN)) {
+		printf ("\n** Device %d not available\n", dev);
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	printf ("\nLoading from device %d: %s at 0x%lx (offset 0x%lx)\n",
+		dev, nand_dev_desc[dev].name, nand_dev_desc[dev].IO_ADDR,
+		offset);
+
+	if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ, offset,
+			SECTORSIZE, NULL, (u_char *)addr)) {
+		printf ("** Read error on %d\n", dev);
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	hdr = (image_header_t *)addr;
+
+	if (ntohl(hdr->ih_magic) == IH_MAGIC) {
+
+		print_image_hdr (hdr);
+
+		cnt = (ntohl(hdr->ih_size) + sizeof(image_header_t));
+		cnt -= SECTORSIZE;
+	} else {
+		printf ("\n** Bad Magic Number 0x%x **\n", ntohl(hdr->ih_magic));
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ,
+			offset + SECTORSIZE, cnt, NULL,
+			(u_char *)(addr+SECTORSIZE))) {
+		printf ("** Read error on %d\n", dev);
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	/* Loading ok, update default load address */
+
+	load_addr = addr;
+
+	/* Check if we should attempt an auto-start */
+	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep,"yes") == 0)) {
+		char *local_args[2];
+		extern int do_bootm (cmd_tbl_t *, int, int, char *[]);
+
+		local_args[0] = argv[0];
+		local_args[1] = NULL;
+
+		printf ("Automatic boot of image at addr 0x%08lx ...\n", addr);
+
+		do_bootm (cmdtp, 0, 1, local_args);
+		rcode = 1;
+	}
+	return rcode;
+}
+
+U_BOOT_CMD(
+	nboot,	4,	1,	do_nandboot,
+	"nboot   - boot from NAND device\n",
+	"loadAddr dev\n"
+);
+
+#endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
+
+#endif /* CFG_NAND_LEGACY */
diff -urN u-boot-1.1.6/common/cmd_suspend.c u-boot-1.1.6_fdt/common/cmd_suspend.c
--- u-boot-1.1.6/common/cmd_suspend.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/cmd_suspend.c	2018-10-22 15:53:21.541641225 +0800
@@ -0,0 +1,89 @@
+
+/*
+ * weidongshan@qq.com, www.100ask.net
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <def.h>
+#include <nand.h>
+#include <s3c24x0.h>
+
+extern void s3c2440_cpu_suspend(void);
+
+static void delay(volatile int d)
+{
+	while(d--);
+}
+
+int do_suspend (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	/* 休眠: */
+	
+	/* 1. 配置GPIO: 比如想维持LED亮或灭, 用于唤醒CPU的引脚要设为中断功能 */
+	/* 对于NAND启动: 要设置EINT23,22,21为输入引脚 */
+	rGPGCON &= ~((3<<30) | (3<<28) | (3<<26));
+
+	/* JZ2440只有S2/S3/S4可用作唤醒源,设置它们对应的GPIO用于中断模式 */
+	rGPFCON &= ~((3<<0) | (3<<4));
+	rGPFCON |= ((2<<0) | (2<<4));
+
+	rGPGCON &= ~(3<<6);
+	rGPGCON |= (2<<6);
+
+	/* 2. 设置INTMSK屏蔽所有中断: 在sleep模式下,这些引脚只是用于唤醒系统,当CPU正常运行时可以重新设置INTMSK让这些引脚用于中断功能 */	
+	rINTMSK = ~0;
+
+	/* 3. 配置唤醒源 */
+	rEXTINT0 |= (6<<0) | (6<<8); /* EINT0,2双边沿触发 */
+	rEXTINT1 |= (6<<12);   /* EINT11双边沿触发 */
+
+	/* 4. 设置MISCCR[13:12]=11b, 使得USB模块进入休眠 */
+	rMISCCR |= (3<<12);
+
+	/* 5. 在GSTATUS[4:3]保存某值, 它们可以在系统被唤醒时使用 */
+	//rGSTATUS3 = ;  /* 唤醒时首先执行的函数的地址 */
+	//rGSTATUS4 = ;  /*  */
+
+	/* 6. 设置 MISCCR[1:0] 使能数据总线的上拉电阻 */
+	rMISCCR &= ~(3);
+
+	/* 7. 清除 LCDCON1.ENVID 以停止LCD */
+	rLCDCON1 &= ~1;
+
+	/* 8~12使用汇编来实现,参考内核源码:
+	 *    arch\arm\mach-s3c2410\sleep.S
+	*/
+
+	/* 8. 读这2个寄存器: rREFRESH and rCLKCON, 以便填充TLB
+	 *    如果不使用MMU的话,这个目的可以忽略 
+	 */
+
+	/* 9. 设置 REFRESH[22]=1b,让SDRAM进入self-refresh mode */
+
+	/* 10. 等待SDRAM成功进入self-refresh mode  */
+
+	/* 11.设置 MISCCR[19:17]=111b以保护SDRAM信号(SCLK0,SCLK1 and SCKE) */
+
+	/* 12. 设置CLKCON的SLEEP位让系统进入sleep mode */	
+	printf("suspend ...");
+	delay(1000000);
+	s3c2440_cpu_suspend();  /* 执行到这里就不会返回,直到CPU被唤醒 */
+
+	/* 恢复运行: 重新初始化硬件 */
+	serial_init();
+	printf("wake up\n");
+	
+	
+    return 0;
+}
+
+
+U_BOOT_CMD(
+	suspend,	1,	0,	do_suspend,
+	"suspend - suspend the board\n",
+	" - suspend the board"
+);
+
+
diff -urN u-boot-1.1.6/common/cmd_usbslave.c u-boot-1.1.6_fdt/common/cmd_usbslave.c
--- u-boot-1.1.6/common/cmd_usbslave.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/cmd_usbslave.c	2018-10-22 15:53:21.541641225 +0800
@@ -0,0 +1,78 @@
+/*
+ * thisway.diy@163.com, www.100ask.net
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/byteorder.h>
+#include <def.h>
+
+#ifdef CONFIG_USB_DEVICE
+
+int g_bUSBWait = 1;
+u32 g_dwDownloadLen = 0;
+
+extern int download_run;
+extern volatile U32 dwUSBBufBase;
+extern volatile u32 dwUSBBufSize;
+
+extern __u32 usb_receive(char *buf, size_t len, U32 wait);
+
+int do_usbslave (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int i;
+    size_t len = ~0UL;
+    char buf[32];
+
+    /* download_run为1时表示将文件保存在USB Host发送工具dnw指定的位置
+     * download_run为0时表示将文件保存在参数argv[2]指定的位置
+     * 要下载程序到内存，然后直接运行时，要设置download_run=1，这也是这个参数名字的来由
+     */
+    download_run = 1;
+    switch (argc) {
+        case 1:
+        {
+            break;
+        }
+        case 2:
+        {
+            g_bUSBWait = (int)simple_strtoul(argv[1], NULL, 16);
+            break;
+        }
+
+        case 3:
+        {
+            g_bUSBWait = (int)simple_strtoul(argv[1], NULL, 16);
+            load_addr = simple_strtoul(argv[2], NULL, 16);
+            download_run = 0;
+            break;
+        }
+        
+        default: 
+        {
+            printf ("Usage:\n%s\n", cmdtp->usage);
+    		return 1;
+        }
+    }
+
+    dwUSBBufBase = load_addr;  
+    dwUSBBufSize = (FREE_RAM_SIZE&(~(0x80000-1)));  
+    if (g_bUSBWait)
+        len = FREE_RAM_SIZE;
+
+    g_dwDownloadLen = usb_receive(dwUSBBufBase, len, g_bUSBWait);
+    sprintf(buf, "%X", g_dwDownloadLen);
+    setenv("filesize", buf);
+    
+	return 0;
+}
+
+U_BOOT_CMD(
+	usbslave,	3,	0,	do_usbslave,
+	"usbslave - get file from host(PC)\n",
+	"[wait] [loadAddress]\n"
+	"\"wait\" is 0 or 1, 0 means for return immediately, not waits for the finish of transferring\n"
+);
+
+#endif
diff -urN u-boot-1.1.6/common/env_nand.c u-boot-1.1.6_fdt/common/env_nand.c
--- u-boot-1.1.6/common/env_nand.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/common/env_nand.c	2018-10-22 15:53:21.541641225 +0800
@@ -268,10 +268,9 @@
 void env_relocate_spec (void)
 {
 #if !defined(ENV_IS_EMBEDDED)
-	ulong total;
+	ulong total = CFG_ENV_SIZE;
 	int ret;
 
-	total = CFG_ENV_SIZE;
 	ret = nand_read(&nand_info[0], CFG_ENV_OFFSET, &total, (u_char*)env_ptr);
   	if (ret || total != CFG_ENV_SIZE)
 		return use_default();
diff -urN u-boot-1.1.6/common/fdt/cmd_fdt.c u-boot-1.1.6_fdt/common/fdt/cmd_fdt.c
--- u-boot-1.1.6/common/fdt/cmd_fdt.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/cmd_fdt.c	2018-10-22 17:06:37.073560131 +0800
@@ -0,0 +1,1108 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2007
+ * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
+ * Based on code written by:
+ *   Pantelis Antoniou <pantelis.antoniou@gmail.com> and
+ *   Matthew McClintock <msm@freescale.com>
+ */
+
+#include <common.h>
+#include <command.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <asm/global_data.h>
+#include <linux/libfdt.h>
+#include <fdt_support.h>
+//#include <mapmem.h>
+#include <asm/io.h>
+
+#define MAX_LEVEL	32		/* how deeply nested we will go */
+#define SCRATCHPAD	1024		/* bytes of scratchpad memory */
+#define CMD_FDT_MAX_DUMP 64
+
+#define map_sysmem(addr, len) addr
+#define env_get getenv
+#define env_set setenv
+
+/*
+ * Global data (for the gd->bd)
+ */
+DECLARE_GLOBAL_DATA_PTR;
+
+static int fdt_valid(struct fdt_header **blobp);
+static int fdt_parse_prop(char *const*newval, int count, char *data, int *len);
+static int fdt_print(const char *pathp, char *prop, int depth);
+static int is_printable_string(const void *data, int len);
+
+/*
+ * The working_fdt points to our working flattened device tree.
+ */
+struct fdt_header *working_fdt;
+
+void set_working_fdt_addr(ulong addr)
+{
+	void *buf;
+
+	buf = map_sysmem(addr, 0);
+	working_fdt = buf;
+	//env_set_hex("fdtaddr", addr);
+}
+
+/*
+ * Get a value from the fdt and format it to be set in the environment
+ */
+static int fdt_value_env_set(const void *nodep, int len, const char *var)
+{
+	if (is_printable_string(nodep, len))
+		env_set(var, (void *)nodep);
+	else if (len == 4) {
+		char buf[11];
+
+		sprintf(buf, "0x%08X", fdt32_to_cpu(*(fdt32_t *)nodep));
+		env_set(var, buf);
+	} else if (len%4 == 0 && len <= 20) {
+		/* Needed to print things like sha1 hashes. */
+		char buf[41];
+		int i;
+
+		for (i = 0; i < len; i += sizeof(unsigned int))
+			sprintf(buf + (i * 2), "%08x",
+				*(unsigned int *)(nodep + i));
+		env_set(var, buf);
+	} else {
+		printf("error: unprintable value\n");
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * Flattened Device Tree command, see the help for parameter definitions.
+ */
+static int do_fdt(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	if (argc < 2)
+		return -1;
+
+	/*
+	 * Set the address of the fdt
+	 */
+	if (strncmp(argv[1], "ad", 2) == 0) {
+		unsigned long addr;
+		int control = 0;
+		struct fdt_header *blob;
+		/*
+		 * Set the address [and length] of the fdt.
+		 */
+		argc -= 2;
+		argv += 2;
+/* Temporary #ifdef - some archs don't have fdt_blob yet */
+#ifdef CONFIG_OF_CONTROL
+		if (argc && !strcmp(*argv, "-c")) {
+			control = 1;
+			argc--;
+			argv++;
+		}
+#endif
+		if (argc == 0) {
+			blob = working_fdt;
+			if (!blob || !fdt_valid(&blob))
+				return 1;
+			return 0;
+		}
+
+		addr = simple_strtoul(argv[0], NULL, 16);
+		blob = map_sysmem(addr, 0);
+		if (!fdt_valid(&blob))
+			return 1;
+		set_working_fdt_addr(addr);
+
+		if (argc >= 2) {
+			int  len;
+			int  err;
+			/*
+			 * Optional new length
+			 */
+			len = simple_strtoul(argv[1], NULL, 16);
+			if (len < fdt_totalsize(blob)) {
+				printf ("New length %d < existing length %d, "
+					"ignoring.\n",
+					len, fdt_totalsize(blob));
+			} else {
+				/*
+				 * Open in place with a new length.
+				 */
+				err = fdt_open_into(blob, blob, len);
+				if (err != 0) {
+					printf ("libfdt fdt_open_into(): %s\n",
+						fdt_strerror(err));
+				}
+			}
+		}
+
+		return 0;
+	}
+
+	if (!working_fdt) {
+		puts(
+			"No FDT memory address configured. Please configure\n"
+			"the FDT address via \"fdt addr <address>\" command.\n"
+			"Aborting!\n");
+		return -1;
+	}
+
+	/*
+	 * Move the working_fdt
+	 */
+	if (strncmp(argv[1], "mo", 2) == 0) {
+		struct fdt_header *newaddr;
+		int  len;
+		int  err;
+
+		if (argc < 4)
+			return -1;
+
+		/*
+		 * Set the address and length of the fdt.
+		 */
+		working_fdt = (struct fdt_header *)simple_strtoul(argv[2], NULL, 16);
+		if (!fdt_valid(&working_fdt))
+			return 1;
+
+		newaddr = (struct fdt_header *)simple_strtoul(argv[3],NULL,16);
+
+		/*
+		 * If the user specifies a length, use that.  Otherwise use the
+		 * current length.
+		 */
+		if (argc <= 4) {
+			len = fdt_totalsize(working_fdt);
+		} else {
+			len = simple_strtoul(argv[4], NULL, 16);
+			if (len < fdt_totalsize(working_fdt)) {
+				printf ("New length 0x%X < existing length "
+					"0x%X, aborting.\n",
+					len, fdt_totalsize(working_fdt));
+				return 1;
+			}
+		}
+
+		/*
+		 * Copy to the new location.
+		 */
+		err = fdt_open_into(working_fdt, newaddr, len);
+		if (err != 0) {
+			printf ("libfdt fdt_open_into(): %s\n",
+				fdt_strerror(err));
+			return 1;
+		}
+		working_fdt = newaddr;
+#ifdef CONFIG_OF_SYSTEM_SETUP
+	/* Call the board-specific fixup routine */
+	} else if (strncmp(argv[1], "sys", 3) == 0) {
+		int err = ft_system_setup(working_fdt, gd->bd);
+
+		if (err) {
+			printf("Failed to add system information to FDT: %s\n",
+			       fdt_strerror(err));
+			return -1;
+		}
+#endif
+	/*
+	 * Make a new node
+	 */
+	} else if (strncmp(argv[1], "mk", 2) == 0) {
+		char *pathp;		/* path */
+		char *nodep;		/* new node to add */
+		int  nodeoffset;	/* node offset from libfdt */
+		int  err;
+
+		/*
+		 * Parameters: Node path, new node to be appended to the path.
+		 */
+		if (argc < 4)
+			return -1;
+
+		pathp = argv[2];
+		nodep = argv[3];
+
+		nodeoffset = fdt_path_offset (working_fdt, pathp);
+		if (nodeoffset < 0) {
+			/*
+			 * Not found or something else bad happened.
+			 */
+			printf ("libfdt fdt_path_offset() returned %s\n",
+				fdt_strerror(nodeoffset));
+			return 1;
+		}
+		err = fdt_add_subnode(working_fdt, nodeoffset, nodep);
+		if (err < 0) {
+			printf ("libfdt fdt_add_subnode(): %s\n",
+				fdt_strerror(err));
+			return 1;
+		}
+
+	/*
+	 * Set the value of a property in the working_fdt.
+	 */
+	} else if (argv[1][0] == 's') {
+		char *pathp;		/* path */
+		char *prop;		/* property */
+		int  nodeoffset;	/* node offset from libfdt */
+		static char data[SCRATCHPAD];/* property storage */
+		const void *ptmp;
+		int  len;		/* new length of the property */
+		int  ret;		/* return value */
+
+		/*
+		 * Parameters: Node path, property, optional value.
+		 */
+		if (argc < 4)
+			return -1;
+
+		pathp  = argv[2];
+		prop   = argv[3];
+
+		nodeoffset = fdt_path_offset (working_fdt, pathp);
+		if (nodeoffset < 0) {
+			/*
+			 * Not found or something else bad happened.
+			 */
+			printf ("libfdt fdt_path_offset() returned %s\n",
+				fdt_strerror(nodeoffset));
+			return 1;
+		}
+
+		if (argc == 4) {
+			len = 0;
+		} else {
+			ptmp = fdt_getprop(working_fdt, nodeoffset, prop, &len);
+			if (len > SCRATCHPAD) {
+				printf("prop (%d) doesn't fit in scratchpad!\n",
+				       len);
+				return 1;
+			}
+			if (ptmp != NULL)
+				memcpy(data, ptmp, len);
+
+			ret = fdt_parse_prop(&argv[4], argc - 4, data, &len);
+			if (ret != 0)
+				return ret;
+		}
+
+		ret = fdt_setprop(working_fdt, nodeoffset, prop, data, len);
+		if (ret < 0) {
+			printf ("libfdt fdt_setprop(): %s\n", fdt_strerror(ret));
+			return 1;
+		}
+
+	/********************************************************************
+	 * Get the value of a property in the working_fdt.
+	 ********************************************************************/
+	} else if (argv[1][0] == 'g') {
+		char *subcmd;		/* sub-command */
+		char *pathp;		/* path */
+		char *prop;		/* property */
+		char *var;		/* variable to store result */
+		int  nodeoffset;	/* node offset from libfdt */
+		const void *nodep;	/* property node pointer */
+		int  len = 0;		/* new length of the property */
+
+		/*
+		 * Parameters: Node path, property, optional value.
+		 */
+		if (argc < 5)
+			return -1;
+
+		subcmd = argv[2];
+
+		if (argc < 6 && subcmd[0] != 's')
+			return -1;
+
+		var    = argv[3];
+		pathp  = argv[4];
+		prop   = argv[5];
+
+		nodeoffset = fdt_path_offset(working_fdt, pathp);
+		if (nodeoffset < 0) {
+			/*
+			 * Not found or something else bad happened.
+			 */
+			printf("libfdt fdt_path_offset() returned %s\n",
+				fdt_strerror(nodeoffset));
+			return 1;
+		}
+
+		if (subcmd[0] == 'n' || (subcmd[0] == 's' && argc == 5)) {
+			int reqIndex = -1;
+			int startDepth = fdt_node_depth(
+				working_fdt, nodeoffset);
+			int curDepth = startDepth;
+			int curIndex = -1;
+			int nextNodeOffset = fdt_next_node(
+				working_fdt, nodeoffset, &curDepth);
+
+			if (subcmd[0] == 'n')
+				reqIndex = simple_strtoul(argv[5], NULL, 16);
+
+			while (curDepth > startDepth) {
+				if (curDepth == startDepth + 1)
+					curIndex++;
+				if (subcmd[0] == 'n' && curIndex == reqIndex) {
+					const char *node_name;
+
+					node_name = fdt_get_name(working_fdt,
+								 nextNodeOffset,
+								 NULL);
+					env_set(var, node_name);
+					return 0;
+				}
+				nextNodeOffset = fdt_next_node(
+					working_fdt, nextNodeOffset, &curDepth);
+				if (nextNodeOffset < 0)
+					break;
+			}
+			if (subcmd[0] == 's') {
+				/* get the num nodes at this level */
+				//env_set_ulong(var, curIndex + 1);
+			} else {
+				/* node index not found */
+				printf("libfdt node not found\n");
+				return 1;
+			}
+		} else {
+			nodep = fdt_getprop(
+				working_fdt, nodeoffset, prop, &len);
+			if (len == 0) {
+				/* no property value */
+				env_set(var, "");
+				return 0;
+			} else if (nodep && len > 0) {
+				if (subcmd[0] == 'v') {
+					int ret;
+
+					ret = fdt_value_env_set(nodep, len,
+								var);
+					if (ret != 0)
+						return ret;
+				} else if (subcmd[0] == 'a') {
+					/* Get address */
+					char buf[11];
+
+					sprintf(buf, "0x%p", nodep);
+					env_set(var, buf);
+				} else if (subcmd[0] == 's') {
+					/* Get size */
+					char buf[11];
+
+					sprintf(buf, "0x%08X", len);
+					env_set(var, buf);
+				} else
+					return -1;
+				return 0;
+			} else {
+				printf("libfdt fdt_getprop(): %s\n",
+					fdt_strerror(len));
+				return 1;
+			}
+		}
+
+	/*
+	 * Print (recursive) / List (single level)
+	 */
+	} else if ((argv[1][0] == 'p') || (argv[1][0] == 'l')) {
+		int depth = MAX_LEVEL;	/* how deep to print */
+		char *pathp;		/* path */
+		char *prop;		/* property */
+		int  ret;		/* return value */
+		static char root[2] = "/";
+
+		/*
+		 * list is an alias for print, but limited to 1 level
+		 */
+		if (argv[1][0] == 'l') {
+			depth = 1;
+		}
+
+		/*
+		 * Get the starting path.  The root node is an oddball,
+		 * the offset is zero and has no name.
+		 */
+		if (argc == 2)
+			pathp = root;
+		else
+			pathp = argv[2];
+		if (argc > 3)
+			prop = argv[3];
+		else
+			prop = NULL;
+
+		ret = fdt_print(pathp, prop, depth);
+		if (ret != 0)
+			return ret;
+
+	/*
+	 * Remove a property/node
+	 */
+	} else if (strncmp(argv[1], "rm", 2) == 0) {
+		int  nodeoffset;	/* node offset from libfdt */
+		int  err;
+
+		/*
+		 * Get the path.  The root node is an oddball, the offset
+		 * is zero and has no name.
+		 */
+		nodeoffset = fdt_path_offset (working_fdt, argv[2]);
+		if (nodeoffset < 0) {
+			/*
+			 * Not found or something else bad happened.
+			 */
+			printf ("libfdt fdt_path_offset() returned %s\n",
+				fdt_strerror(nodeoffset));
+			return 1;
+		}
+		/*
+		 * Do the delete.  A fourth parameter means delete a property,
+		 * otherwise delete the node.
+		 */
+		if (argc > 3) {
+			err = fdt_delprop(working_fdt, nodeoffset, argv[3]);
+			if (err < 0) {
+				printf("libfdt fdt_delprop():  %s\n",
+					fdt_strerror(err));
+				return err;
+			}
+		} else {
+			err = fdt_del_node(working_fdt, nodeoffset);
+			if (err < 0) {
+				printf("libfdt fdt_del_node():  %s\n",
+					fdt_strerror(err));
+				return err;
+			}
+		}
+
+	/*
+	 * Display header info
+	 */
+	} else if (argv[1][0] == 'h') {
+		u32 version = fdt_version(working_fdt);
+		printf("magic:\t\t\t0x%x\n", fdt_magic(working_fdt));
+		printf("totalsize:\t\t0x%x (%d)\n", fdt_totalsize(working_fdt),
+		       fdt_totalsize(working_fdt));
+		printf("off_dt_struct:\t\t0x%x\n",
+		       fdt_off_dt_struct(working_fdt));
+		printf("off_dt_strings:\t\t0x%x\n",
+		       fdt_off_dt_strings(working_fdt));
+		printf("off_mem_rsvmap:\t\t0x%x\n",
+		       fdt_off_mem_rsvmap(working_fdt));
+		printf("version:\t\t%d\n", version);
+		printf("last_comp_version:\t%d\n",
+		       fdt_last_comp_version(working_fdt));
+		if (version >= 2)
+			printf("boot_cpuid_phys:\t0x%x\n",
+				fdt_boot_cpuid_phys(working_fdt));
+		if (version >= 3)
+			printf("size_dt_strings:\t0x%x\n",
+				fdt_size_dt_strings(working_fdt));
+		if (version >= 17)
+			printf("size_dt_struct:\t\t0x%x\n",
+				fdt_size_dt_struct(working_fdt));
+		printf("number mem_rsv:\t\t0x%x\n",
+		       fdt_num_mem_rsv(working_fdt));
+		printf("\n");
+
+	/*
+	 * Set boot cpu id
+	 */
+	} else if (strncmp(argv[1], "boo", 3) == 0) {
+		unsigned long tmp = simple_strtoul(argv[2], NULL, 16);
+		fdt_set_boot_cpuid_phys(working_fdt, tmp);
+
+	/*
+	 * memory command
+	 */
+	} else if (strncmp(argv[1], "me", 2) == 0) {
+		uint64_t addr, size;
+		int err;
+		addr = simple_strtoull(argv[2], NULL, 16);
+		size = simple_strtoull(argv[3], NULL, 16);
+		err = fdt_fixup_memory(working_fdt, addr, size);
+		if (err < 0)
+			return err;
+
+	/*
+	 * mem reserve commands
+	 */
+	} else if (strncmp(argv[1], "rs", 2) == 0) {
+		if (argv[2][0] == 'p') {
+			uint64_t addr, size;
+			int total = fdt_num_mem_rsv(working_fdt);
+			int j, err;
+			printf("index\t\t   start\t\t    size\n");
+			printf("-------------------------------"
+				"-----------------\n");
+			for (j = 0; j < total; j++) {
+				err = fdt_get_mem_rsv(working_fdt, j, &addr, &size);
+				if (err < 0) {
+					printf("libfdt fdt_get_mem_rsv():  %s\n",
+							fdt_strerror(err));
+					return err;
+				}
+				printf("    %x\t%08x%08x\t%08x%08x\n", j,
+					(u32)(addr >> 32),
+					(u32)(addr & 0xffffffff),
+					(u32)(size >> 32),
+					(u32)(size & 0xffffffff));
+			}
+		} else if (argv[2][0] == 'a') {
+			uint64_t addr, size;
+			int err;
+			addr = simple_strtoull(argv[3], NULL, 16);
+			size = simple_strtoull(argv[4], NULL, 16);
+			err = fdt_add_mem_rsv(working_fdt, addr, size);
+
+			if (err < 0) {
+				printf("libfdt fdt_add_mem_rsv():  %s\n",
+					fdt_strerror(err));
+				return err;
+			}
+		} else if (argv[2][0] == 'd') {
+			unsigned long idx = simple_strtoul(argv[3], NULL, 16);
+			int err = fdt_del_mem_rsv(working_fdt, idx);
+
+			if (err < 0) {
+				printf("libfdt fdt_del_mem_rsv():  %s\n",
+					fdt_strerror(err));
+				return err;
+			}
+		} else {
+			/* Unrecognized command */
+			return -1;
+		}
+	}
+#ifdef CONFIG_OF_BOARD_SETUP
+	/* Call the board-specific fixup routine */
+	else if (strncmp(argv[1], "boa", 3) == 0) {
+		int err = ft_board_setup(working_fdt, gd->bd);
+
+		if (err) {
+			printf("Failed to update board information in FDT: %s\n",
+			       fdt_strerror(err));
+			return -1;
+		}
+#ifdef CONFIG_SOC_KEYSTONE
+		ft_board_setup_ex(working_fdt, gd->bd);
+#endif
+	}
+#endif
+	/* Create a chosen node */
+	else if (strncmp(argv[1], "cho", 3) == 0) {
+		unsigned long initrd_start = 0, initrd_end = 0;
+
+		if ((argc != 2) && (argc != 4))
+			return -1;
+
+		if (argc == 4) {
+			initrd_start = simple_strtoul(argv[2], NULL, 16);
+			initrd_end = simple_strtoul(argv[3], NULL, 16);
+		}
+
+		fdt_chosen(working_fdt);
+		fdt_initrd(working_fdt, initrd_start, initrd_end);
+
+#if defined(CONFIG_FIT_SIGNATURE)
+	} else if (strncmp(argv[1], "che", 3) == 0) {
+		int cfg_noffset;
+		int ret;
+		unsigned long addr;
+		struct fdt_header *blob;
+
+		if (!working_fdt)
+			return -1;
+
+		if (argc > 2) {
+			addr = simple_strtoul(argv[2], NULL, 16);
+			blob = map_sysmem(addr, 0);
+		} else {
+//			blob = (struct fdt_header *)gd->fdt_blob;
+		}
+		if (!fdt_valid(&blob))
+			return 1;
+
+//		gd->fdt_blob = blob;
+		cfg_noffset = fit_conf_get_node(working_fdt, NULL);
+		if (!cfg_noffset) {
+			printf("Could not find configuration node: %s\n",
+			       fdt_strerror(cfg_noffset));
+			return -1;
+		}
+
+		ret = fit_config_verify(working_fdt, cfg_noffset);
+		if (ret == 0)
+			return 0;
+		else
+			return -1;
+#endif
+
+	}
+#ifdef CONFIG_OF_LIBFDT_OVERLAY
+	/* apply an overlay */
+	else if (strncmp(argv[1], "ap", 2) == 0) {
+		unsigned long addr;
+		struct fdt_header *blob;
+		int ret;
+
+		if (argc != 3)
+			return -1;
+
+		if (!working_fdt)
+			return -1;
+
+		addr = simple_strtoul(argv[2], NULL, 16);
+		blob = map_sysmem(addr, 0);
+		if (!fdt_valid(&blob))
+			return -1;
+
+		/* apply method prints messages on error */
+		ret = fdt_overlay_apply_verbose(working_fdt, blob);
+		if (ret)
+			return -1;
+	}
+#endif
+	/* resize the fdt */
+	else if (strncmp(argv[1], "re", 2) == 0) {
+		uint extrasize;
+		if (argc > 2)
+			extrasize = simple_strtoul(argv[2], NULL, 16);
+		else
+			extrasize = 0;
+		fdt_shrink_to_minimum(working_fdt, extrasize);
+	}
+	else {
+		/* Unrecognized command */
+		return -1;
+	}
+
+	return 0;
+}
+
+/****************************************************************************/
+
+/**
+ * fdt_valid() - Check if an FDT is valid. If not, change it to NULL
+ *
+ * @blobp: Pointer to FDT pointer
+ * @return 1 if OK, 0 if bad (in which case *blobp is set to NULL)
+ */
+static int fdt_valid(struct fdt_header **blobp)
+{
+	const void *blob = *blobp;
+	int err;
+
+	if (blob == NULL) {
+		printf ("The address of the fdt is invalid (NULL).\n");
+		return 0;
+	}
+
+	err = fdt_check_header(blob);
+	if (err == 0)
+		return 1;	/* valid */
+
+	if (err < 0) {
+		printf("libfdt fdt_check_header(): %s", fdt_strerror(err));
+		/*
+		 * Be more informative on bad version.
+		 */
+		if (err == -FDT_ERR_BADVERSION) {
+			if (fdt_version(blob) <
+			    FDT_FIRST_SUPPORTED_VERSION) {
+				printf (" - too old, fdt %d < %d",
+					fdt_version(blob),
+					FDT_FIRST_SUPPORTED_VERSION);
+			}
+			if (fdt_last_comp_version(blob) >
+			    FDT_LAST_SUPPORTED_VERSION) {
+				printf (" - too new, fdt %d > %d",
+					fdt_version(blob),
+					FDT_LAST_SUPPORTED_VERSION);
+			}
+		}
+		printf("\n");
+		*blobp = NULL;
+		return 0;
+	}
+	return 1;
+}
+
+/****************************************************************************/
+
+/*
+ * Parse the user's input, partially heuristic.  Valid formats:
+ * <0x00112233 4 05>	- an array of cells.  Numbers follow standard
+ *			C conventions.
+ * [00 11 22 .. nn] - byte stream
+ * "string"	- If the the value doesn't start with "<" or "[", it is
+ *			treated as a string.  Note that the quotes are
+ *			stripped by the parser before we get the string.
+ * newval: An array of strings containing the new property as specified
+ *	on the command line
+ * count: The number of strings in the array
+ * data: A bytestream to be placed in the property
+ * len: The length of the resulting bytestream
+ */
+static int fdt_parse_prop(char * const *newval, int count, char *data, int *len)
+{
+	char *cp;		/* temporary char pointer */
+	char *newp;		/* temporary newval char pointer */
+	unsigned long tmp;	/* holds converted values */
+	int stridx = 0;
+
+	*len = 0;
+	newp = newval[0];
+
+	/* An array of cells */
+	if (*newp == '<') {
+		newp++;
+		while ((*newp != '>') && (stridx < count)) {
+			/*
+			 * Keep searching until we find that last ">"
+			 * That way users don't have to escape the spaces
+			 */
+			if (*newp == '\0') {
+				newp = newval[++stridx];
+				continue;
+			}
+
+			cp = newp;
+			tmp = simple_strtoul(cp, &newp, 0);
+			if (*cp != '?')
+				*(fdt32_t *)data = cpu_to_fdt32(tmp);
+			else
+				newp++;
+
+			data  += 4;
+			*len += 4;
+
+			/* If the ptr didn't advance, something went wrong */
+			if ((newp - cp) <= 0) {
+				printf("Sorry, I could not convert \"%s\"\n",
+					cp);
+				return 1;
+			}
+
+			while (*newp == ' ')
+				newp++;
+		}
+
+		if (*newp != '>') {
+			printf("Unexpected character '%c'\n", *newp);
+			return 1;
+		}
+	} else if (*newp == '[') {
+		/*
+		 * Byte stream.  Convert the values.
+		 */
+		newp++;
+		while ((stridx < count) && (*newp != ']')) {
+			while (*newp == ' ')
+				newp++;
+			if (*newp == '\0') {
+				newp = newval[++stridx];
+				continue;
+			}
+			if (!isxdigit(*newp))
+				break;
+			tmp = simple_strtoul(newp, &newp, 16);
+			*data++ = tmp & 0xFF;
+			*len    = *len + 1;
+		}
+		if (*newp != ']') {
+			printf("Unexpected character '%c'\n", *newp);
+			return 1;
+		}
+	} else {
+		/*
+		 * Assume it is one or more strings.  Copy it into our
+		 * data area for convenience (including the
+		 * terminating '\0's).
+		 */
+		while (stridx < count) {
+			size_t length = strlen(newp) + 1;
+			strcpy(data, newp);
+			data += length;
+			*len += length;
+			newp = newval[++stridx];
+		}
+	}
+	return 0;
+}
+
+/****************************************************************************/
+
+/*
+ * Heuristic to guess if this is a string or concatenated strings.
+ */
+
+static int is_printable_string(const void *data, int len)
+{
+	const char *s = data;
+
+	/* zero length is not */
+	if (len == 0)
+		return 0;
+
+	/* must terminate with zero or '\n' */
+	if (s[len - 1] != '\0' && s[len - 1] != '\n')
+		return 0;
+
+	/* printable or a null byte (concatenated strings) */
+	while (((*s == '\0') || isprint(*s) || isspace(*s)) && (len > 0)) {
+		/*
+		 * If we see a null, there are three possibilities:
+		 * 1) If len == 1, it is the end of the string, printable
+		 * 2) Next character also a null, not printable.
+		 * 3) Next character not a null, continue to check.
+		 */
+		if (s[0] == '\0') {
+			if (len == 1)
+				return 1;
+			if (s[1] == '\0')
+				return 0;
+		}
+		s++;
+		len--;
+	}
+
+	/* Not the null termination, or not done yet: not printable */
+	if (*s != '\0' || (len != 0))
+		return 0;
+
+	return 1;
+}
+
+
+/*
+ * Print the property in the best format, a heuristic guess.  Print as
+ * a string, concatenated strings, a byte, word, double word, or (if all
+ * else fails) it is printed as a stream of bytes.
+ */
+static void print_data(const void *data, int len)
+{
+	int j;
+
+	/* no data, don't print */
+	if (len == 0)
+		return;
+
+	/*
+	 * It is a string, but it may have multiple strings (embedded '\0's).
+	 */
+	if (is_printable_string(data, len)) {
+		puts("\"");
+		j = 0;
+		while (j < len) {
+			if (j > 0)
+				puts("\", \"");
+			puts(data);
+			j    += strlen(data) + 1;
+			data += strlen(data) + 1;
+		}
+		puts("\"");
+		return;
+	}
+
+	if ((len %4) == 0) {
+		if (len > CMD_FDT_MAX_DUMP)
+			printf("* 0x%p [0x%08x]", data, len);
+		else {
+			const __be32 *p;
+
+			printf("<");
+			for (j = 0, p = data; j < len/4; j++)
+				printf("0x%08x%s", fdt32_to_cpu(p[j]),
+					j < (len/4 - 1) ? " " : "");
+			printf(">");
+		}
+	} else { /* anything else... hexdump */
+		if (len > CMD_FDT_MAX_DUMP)
+			printf("* 0x%p [0x%08x]", data, len);
+		else {
+			const u8 *s;
+
+			printf("[");
+			for (j = 0, s = data; j < len; j++)
+				printf("%02x%s", s[j], j < len - 1 ? " " : "");
+			printf("]");
+		}
+	}
+}
+
+/****************************************************************************/
+
+/*
+ * Recursively print (a portion of) the working_fdt.  The depth parameter
+ * determines how deeply nested the fdt is printed.
+ */
+static int fdt_print(const char *pathp, char *prop, int depth)
+{
+	static char tabs[MAX_LEVEL+1] =
+		"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"
+		"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t";
+	const void *nodep;	/* property node pointer */
+	int  nodeoffset;	/* node offset from libfdt */
+	int  nextoffset;	/* next node offset from libfdt */
+	uint32_t tag;		/* tag */
+	int  len;		/* length of the property */
+	int  level = 0;		/* keep track of nesting level */
+	const struct fdt_property *fdt_prop;
+
+	nodeoffset = fdt_path_offset (working_fdt, pathp);
+	if (nodeoffset < 0) {
+		/*
+		 * Not found or something else bad happened.
+		 */
+		printf ("libfdt fdt_path_offset() returned %s\n",
+			fdt_strerror(nodeoffset));
+		return 1;
+	}
+	/*
+	 * The user passed in a property as well as node path.
+	 * Print only the given property and then return.
+	 */
+	if (prop) {
+		nodep = fdt_getprop (working_fdt, nodeoffset, prop, &len);
+		if (len == 0) {
+			/* no property value */
+			printf("%s %s\n", pathp, prop);
+			return 0;
+		} else if (nodep && len > 0) {
+			printf("%s = ", prop);
+			print_data (nodep, len);
+			printf("\n");
+			return 0;
+		} else {
+			printf ("libfdt fdt_getprop(): %s\n",
+				fdt_strerror(len));
+			return 1;
+		}
+	}
+
+	/*
+	 * The user passed in a node path and no property,
+	 * print the node and all subnodes.
+	 */
+	while(level >= 0) {
+		tag = fdt_next_tag(working_fdt, nodeoffset, &nextoffset);
+		switch(tag) {
+		case FDT_BEGIN_NODE:
+			pathp = fdt_get_name(working_fdt, nodeoffset, NULL);
+			if (level <= depth) {
+				if (pathp == NULL)
+					pathp = "/* NULL pointer error */";
+				if (*pathp == '\0')
+					pathp = "/";	/* root is nameless */
+				printf("%s%s {\n",
+					&tabs[MAX_LEVEL - level], pathp);
+			}
+			level++;
+			if (level >= MAX_LEVEL) {
+				printf("Nested too deep, aborting.\n");
+				return 1;
+			}
+			break;
+		case FDT_END_NODE:
+			level--;
+			if (level <= depth)
+				printf("%s};\n", &tabs[MAX_LEVEL - level]);
+			if (level == 0) {
+				level = -1;		/* exit the loop */
+			}
+			break;
+		case FDT_PROP:
+			fdt_prop = fdt_offset_ptr(working_fdt, nodeoffset,
+					sizeof(*fdt_prop));
+			pathp    = fdt_string(working_fdt,
+					fdt32_to_cpu(fdt_prop->nameoff));
+			len      = fdt32_to_cpu(fdt_prop->len);
+			nodep    = fdt_prop->data;
+			if (len < 0) {
+				printf ("libfdt fdt_getprop(): %s\n",
+					fdt_strerror(len));
+				return 1;
+			} else if (len == 0) {
+				/* the property has no value */
+				if (level <= depth)
+					printf("%s%s;\n",
+						&tabs[MAX_LEVEL - level],
+						pathp);
+			} else {
+				if (level <= depth) {
+					printf("%s%s = ",
+						&tabs[MAX_LEVEL - level],
+						pathp);
+					print_data (nodep, len);
+					printf(";\n");
+				}
+			}
+			break;
+		case FDT_NOP:
+			printf("%s/* NOP */\n", &tabs[MAX_LEVEL - level]);
+			break;
+		case FDT_END:
+			return 1;
+		default:
+			if (level <= depth)
+				printf("Unknown tag 0x%08X\n", tag);
+			return 1;
+		}
+		nodeoffset = nextoffset;
+	}
+	return 0;
+}
+
+/********************************************************************/
+//#ifdef CONFIG_SYS_LONGHELP
+static char fdt_help_text[] =
+	"addr [-c]  <addr> [<length>]   - Set the [control] fdt location to <addr>\n"
+#ifdef CONFIG_OF_LIBFDT_OVERLAY
+	"fdt apply <addr>                    - Apply overlay to the DT\n"
+#endif
+#ifdef CONFIG_OF_BOARD_SETUP
+	"fdt boardsetup                      - Do board-specific set up\n"
+#endif
+#ifdef CONFIG_OF_SYSTEM_SETUP
+	"fdt systemsetup                     - Do system-specific set up\n"
+#endif
+	"fdt move   <fdt> <newaddr> <length> - Copy the fdt to <addr> and make it active\n"
+	"fdt resize [<extrasize>]            - Resize fdt to size + padding to 4k addr + some optional <extrasize> if needed\n"
+	"fdt print  <path> [<prop>]          - Recursive print starting at <path>\n"
+	"fdt list   <path> [<prop>]          - Print one level starting at <path>\n"
+	"fdt get value <var> <path> <prop>   - Get <property> and store in <var>\n"
+	"fdt get name <var> <path> <index>   - Get name of node <index> and store in <var>\n"
+	"fdt get addr <var> <path> <prop>    - Get start address of <property> and store in <var>\n"
+	"fdt get size <var> <path> [<prop>]  - Get size of [<property>] or num nodes and store in <var>\n"
+	"fdt set    <path> <prop> [<val>]    - Set <property> [to <val>]\n"
+	"fdt mknode <path> <node>            - Create a new node after <path>\n"
+	"fdt rm     <path> [<prop>]          - Delete the node or <property>\n"
+	"fdt header                          - Display header info\n"
+	"fdt bootcpu <id>                    - Set boot cpuid\n"
+	"fdt memory <addr> <size>            - Add/Update memory node\n"
+	"fdt rsvmem print                    - Show current mem reserves\n"
+	"fdt rsvmem add <addr> <size>        - Add a mem reserve\n"
+	"fdt rsvmem delete <index>           - Delete a mem reserves\n"
+	"fdt chosen [<start> <end>]          - Add/update the /chosen branch in the tree\n"
+	"                                        <start>/<end> - initrd start/end addr\n"
+#if defined(CONFIG_FIT_SIGNATURE)
+	"fdt checksign [<addr>]              - check FIT signature\n"
+	"                                        <start> - addr of key blob\n"
+	"                                                  default gd->fdt_blob\n"
+#endif
+	"NOTE: Dereference aliases by omitting the leading '/', "
+		"e.g. fdt print ethernet0.";
+//#endif
+
+U_BOOT_CMD(
+	fdt,	255,	0,	do_fdt,
+	"flattened device tree utility commands", fdt_help_text
+);
diff -urN u-boot-1.1.6/common/fdt/fdt_addresses.c u-boot-1.1.6_fdt/common/fdt/fdt_addresses.c
--- u-boot-1.1.6/common/fdt/fdt_addresses.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt_addresses.c	2018-10-22 15:54:19.557640154 +0800
@@ -0,0 +1,96 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2014 David Gibson <david@gibson.dropbear.id.au>
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+int fdt_address_cells(const void *fdt, int nodeoffset)
+{
+	const fdt32_t *ac;
+	int val;
+	int len;
+
+	ac = fdt_getprop(fdt, nodeoffset, "#address-cells", &len);
+	if (!ac)
+		return 2;
+
+	if (len != sizeof(*ac))
+		return -FDT_ERR_BADNCELLS;
+
+	val = fdt32_to_cpu(*ac);
+	if ((val <= 0) || (val > FDT_MAX_NCELLS))
+		return -FDT_ERR_BADNCELLS;
+
+	return val;
+}
+
+int fdt_size_cells(const void *fdt, int nodeoffset)
+{
+	const fdt32_t *sc;
+	int val;
+	int len;
+
+	sc = fdt_getprop(fdt, nodeoffset, "#size-cells", &len);
+	if (!sc)
+		return 2;
+
+	if (len != sizeof(*sc))
+		return -FDT_ERR_BADNCELLS;
+
+	val = fdt32_to_cpu(*sc);
+	if ((val < 0) || (val > FDT_MAX_NCELLS))
+		return -FDT_ERR_BADNCELLS;
+
+	return val;
+}
diff -urN u-boot-1.1.6/common/fdt/fdt.c u-boot-1.1.6_fdt/common/fdt/fdt.c
--- u-boot-1.1.6/common/fdt/fdt.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt.c	2018-10-22 16:36:27.753593511 +0800
@@ -0,0 +1,254 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+int fdt_check_header(const void *fdt)
+{
+	if (fdt_magic(fdt) == FDT_MAGIC) {
+		/* Complete tree */
+		if (fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)
+			return -FDT_ERR_BADVERSION;
+		if (fdt_last_comp_version(fdt) > FDT_LAST_SUPPORTED_VERSION)
+			return -FDT_ERR_BADVERSION;
+	} else if (fdt_magic(fdt) == FDT_SW_MAGIC) {
+		/* Unfinished sequential-write blob */
+		if (fdt_size_dt_struct(fdt) == 0)
+			return -FDT_ERR_BADSTATE;
+	} else {
+		return -FDT_ERR_BADMAGIC;
+	}
+
+	return 0;
+}
+
+const void *fdt_offset_ptr(const void *fdt, int offset, unsigned int len)
+{
+	unsigned absoffset = offset + fdt_off_dt_struct(fdt);
+
+	if ((absoffset < offset)
+	    || ((absoffset + len) < absoffset)
+	    || (absoffset + len) > fdt_totalsize(fdt))
+		return NULL;
+
+	if (fdt_version(fdt) >= 0x11)
+		if (((offset + len) < offset)
+		    || ((offset + len) > fdt_size_dt_struct(fdt)))
+			return NULL;
+
+	return fdt_offset_ptr_(fdt, offset);
+}
+
+uint32_t fdt_next_tag(const void *fdt, int startoffset, int *nextoffset)
+{
+	const fdt32_t *tagp, *lenp;
+	uint32_t tag;
+	int offset = startoffset;
+	const char *p;
+
+	*nextoffset = -FDT_ERR_TRUNCATED;
+	tagp = fdt_offset_ptr(fdt, offset, FDT_TAGSIZE);
+	if (!tagp)
+		return FDT_END; /* premature end */
+	tag = fdt32_to_cpu(*tagp);
+	offset += FDT_TAGSIZE;
+
+	*nextoffset = -FDT_ERR_BADSTRUCTURE;
+	switch (tag) {
+	case FDT_BEGIN_NODE:
+		/* skip name */
+		do {
+			p = fdt_offset_ptr(fdt, offset++, 1);
+		} while (p && (*p != '\0'));
+		if (!p)
+			return FDT_END; /* premature end */
+		break;
+
+	case FDT_PROP:
+		lenp = fdt_offset_ptr(fdt, offset, sizeof(*lenp));
+		if (!lenp)
+			return FDT_END; /* premature end */
+		/* skip-name offset, length and value */
+		offset += sizeof(struct fdt_property) - FDT_TAGSIZE
+			+ fdt32_to_cpu(*lenp);
+		if (fdt_version(fdt) < 0x10 && fdt32_to_cpu(*lenp) >= 8 &&
+		    ((offset - fdt32_to_cpu(*lenp)) % 8) != 0)
+			offset += 4;
+		break;
+
+	case FDT_END:
+	case FDT_END_NODE:
+	case FDT_NOP:
+		break;
+
+	default:
+		return FDT_END;
+	}
+
+	if (!fdt_offset_ptr(fdt, startoffset, offset - startoffset))
+		return FDT_END; /* premature end */
+
+	*nextoffset = FDT_TAGALIGN(offset);
+	return tag;
+}
+
+int fdt_check_node_offset_(const void *fdt, int offset)
+{
+	if ((offset < 0) || (offset % FDT_TAGSIZE)
+	    || (fdt_next_tag(fdt, offset, &offset) != FDT_BEGIN_NODE))
+		return -FDT_ERR_BADOFFSET;
+
+	return offset;
+}
+
+int fdt_check_prop_offset_(const void *fdt, int offset)
+{
+	if ((offset < 0) || (offset % FDT_TAGSIZE)
+	    || (fdt_next_tag(fdt, offset, &offset) != FDT_PROP))
+		return -FDT_ERR_BADOFFSET;
+
+	return offset;
+}
+
+int fdt_next_node(const void *fdt, int offset, int *depth)
+{
+	int nextoffset = 0;
+	uint32_t tag;
+
+	if (offset >= 0)
+		if ((nextoffset = fdt_check_node_offset_(fdt, offset)) < 0)
+			return nextoffset;
+
+	do {
+		offset = nextoffset;
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+
+		switch (tag) {
+		case FDT_PROP:
+		case FDT_NOP:
+			break;
+
+		case FDT_BEGIN_NODE:
+			if (depth)
+				(*depth)++;
+			break;
+
+		case FDT_END_NODE:
+			if (depth && ((--(*depth)) < 0))
+				return nextoffset;
+			break;
+
+		case FDT_END:
+			if ((nextoffset >= 0)
+			    || ((nextoffset == -FDT_ERR_TRUNCATED) && !depth))
+				return -FDT_ERR_NOTFOUND;
+			else
+				return nextoffset;
+		}
+	} while (tag != FDT_BEGIN_NODE);
+
+	return offset;
+}
+
+int fdt_first_subnode(const void *fdt, int offset)
+{
+	int depth = 0;
+
+	offset = fdt_next_node(fdt, offset, &depth);
+	if (offset < 0 || depth != 1)
+		return -FDT_ERR_NOTFOUND;
+
+	return offset;
+}
+
+int fdt_next_subnode(const void *fdt, int offset)
+{
+	int depth = 1;
+
+	/*
+	 * With respect to the parent, the depth of the next subnode will be
+	 * the same as the last.
+	 */
+	do {
+		offset = fdt_next_node(fdt, offset, &depth);
+		if (offset < 0 || depth < 1)
+			return -FDT_ERR_NOTFOUND;
+	} while (depth > 1);
+
+	return offset;
+}
+
+const char *fdt_find_string_(const char *strtab, int tabsize, const char *s)
+{
+	int len = strlen(s) + 1;
+	const char *last = strtab + tabsize - len;
+	const char *p;
+
+	for (p = strtab; p <= last; p++)
+		if (memcmp(p, s, len) == 0)
+			return p;
+	return NULL;
+}
+
+int fdt_move(const void *fdt, void *buf, int bufsize)
+{
+	FDT_CHECK_HEADER(fdt);
+
+	if (fdt_totalsize(fdt) > bufsize)
+		return -FDT_ERR_NOSPACE;
+
+	memmove(buf, fdt, fdt_totalsize(fdt));
+	return 0;
+}
diff -urN u-boot-1.1.6/common/fdt/fdt_empty_tree.c u-boot-1.1.6_fdt/common/fdt/fdt_empty_tree.c
--- u-boot-1.1.6/common/fdt/fdt_empty_tree.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt_empty_tree.c	2018-10-22 15:54:19.557640154 +0800
@@ -0,0 +1,83 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2012 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+int fdt_create_empty_tree(void *buf, int bufsize)
+{
+	int err;
+
+	err = fdt_create(buf, bufsize);
+	if (err)
+		return err;
+
+	err = fdt_finish_reservemap(buf);
+	if (err)
+		return err;
+
+	err = fdt_begin_node(buf, "");
+	if (err)
+		return err;
+
+	err =  fdt_end_node(buf);
+	if (err)
+		return err;
+
+	err = fdt_finish(buf);
+	if (err)
+		return err;
+
+	return fdt_open_into(buf, buf, bufsize);
+}
diff -urN u-boot-1.1.6/common/fdt/fdt.h u-boot-1.1.6_fdt/common/fdt/fdt.h
--- u-boot-1.1.6/common/fdt/fdt.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt.h	2018-10-22 15:54:19.553640155 +0800
@@ -0,0 +1,111 @@
+#ifndef FDT_H
+#define FDT_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ * Copyright 2012 Kim Phillips, Freescale Semiconductor.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __ASSEMBLY__
+
+struct fdt_header {
+	fdt32_t magic;			 /* magic word FDT_MAGIC */
+	fdt32_t totalsize;		 /* total size of DT block */
+	fdt32_t off_dt_struct;		 /* offset to structure */
+	fdt32_t off_dt_strings;		 /* offset to strings */
+	fdt32_t off_mem_rsvmap;		 /* offset to memory reserve map */
+	fdt32_t version;		 /* format version */
+	fdt32_t last_comp_version;	 /* last compatible version */
+
+	/* version 2 fields below */
+	fdt32_t boot_cpuid_phys;	 /* Which physical CPU id we're
+					    booting on */
+	/* version 3 fields below */
+	fdt32_t size_dt_strings;	 /* size of the strings block */
+
+	/* version 17 fields below */
+	fdt32_t size_dt_struct;		 /* size of the structure block */
+};
+
+struct fdt_reserve_entry {
+	fdt64_t address;
+	fdt64_t size;
+};
+
+struct fdt_node_header {
+	fdt32_t tag;
+	char name[0];
+};
+
+struct fdt_property {
+	fdt32_t tag;
+	fdt32_t len;
+	fdt32_t nameoff;
+	char data[0];
+};
+
+#endif /* !__ASSEMBLY */
+
+#define FDT_MAGIC	0xd00dfeed	/* 4: version, 4: total size */
+#define FDT_TAGSIZE	sizeof(fdt32_t)
+
+#define FDT_BEGIN_NODE	0x1		/* Start node: full name */
+#define FDT_END_NODE	0x2		/* End node */
+#define FDT_PROP	0x3		/* Property: name off,
+					   size, content */
+#define FDT_NOP		0x4		/* nop */
+#define FDT_END		0x9
+
+#define FDT_V1_SIZE	(7*sizeof(fdt32_t))
+#define FDT_V2_SIZE	(FDT_V1_SIZE + sizeof(fdt32_t))
+#define FDT_V3_SIZE	(FDT_V2_SIZE + sizeof(fdt32_t))
+#define FDT_V16_SIZE	FDT_V3_SIZE
+#define FDT_V17_SIZE	(FDT_V16_SIZE + sizeof(fdt32_t))
+
+#endif /* FDT_H */
diff -urN u-boot-1.1.6/common/fdt/fdt_overlay.c u-boot-1.1.6_fdt/common/fdt/fdt_overlay.c
--- u-boot-1.1.6/common/fdt/fdt_overlay.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt_overlay.c	2018-10-22 15:54:19.573640154 +0800
@@ -0,0 +1,912 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2016 Free Electrons
+ * Copyright (C) 2016 NextThing Co.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+/**
+ * overlay_get_target_phandle - retrieves the target phandle of a fragment
+ * @fdto: pointer to the device tree overlay blob
+ * @fragment: node offset of the fragment in the overlay
+ *
+ * overlay_get_target_phandle() retrieves the target phandle of an
+ * overlay fragment when that fragment uses a phandle (target
+ * property) instead of a path (target-path property).
+ *
+ * returns:
+ *      the phandle pointed by the target property
+ *      0, if the phandle was not found
+ *	-1, if the phandle was malformed
+ */
+static uint32_t overlay_get_target_phandle(const void *fdto, int fragment)
+{
+	const fdt32_t *val;
+	int len;
+
+	val = fdt_getprop(fdto, fragment, "target", &len);
+	if (!val)
+		return 0;
+
+	if ((len != sizeof(*val)) || (fdt32_to_cpu(*val) == (uint32_t)-1))
+		return (uint32_t)-1;
+
+	return fdt32_to_cpu(*val);
+}
+
+/**
+ * overlay_get_target - retrieves the offset of a fragment's target
+ * @fdt: Base device tree blob
+ * @fdto: Device tree overlay blob
+ * @fragment: node offset of the fragment in the overlay
+ * @pathp: pointer which receives the path of the target (or NULL)
+ *
+ * overlay_get_target() retrieves the target offset in the base
+ * device tree of a fragment, no matter how the actual targetting is
+ * done (through a phandle or a path)
+ *
+ * returns:
+ *      the targetted node offset in the base device tree
+ *      Negative error code on error
+ */
+static int overlay_get_target(const void *fdt, const void *fdto,
+			      int fragment, char const **pathp)
+{
+	uint32_t phandle;
+	const char *path = NULL;
+	int path_len = 0, ret;
+
+	/* Try first to do a phandle based lookup */
+	phandle = overlay_get_target_phandle(fdto, fragment);
+	if (phandle == (uint32_t)-1)
+		return -FDT_ERR_BADPHANDLE;
+
+	/* no phandle, try path */
+	if (!phandle) {
+		/* And then a path based lookup */
+		path = fdt_getprop(fdto, fragment, "target-path", &path_len);
+		if (path)
+			ret = fdt_path_offset(fdt, path);
+		else
+			ret = path_len;
+	} else
+		ret = fdt_node_offset_by_phandle(fdt, phandle);
+
+	/*
+	* If we haven't found either a target or a
+	* target-path property in a node that contains a
+	* __overlay__ subnode (we wouldn't be called
+	* otherwise), consider it a improperly written
+	* overlay
+	*/
+	if (ret < 0 && path_len == -FDT_ERR_NOTFOUND)
+		ret = -FDT_ERR_BADOVERLAY;
+
+	/* return on error */
+	if (ret < 0)
+		return ret;
+
+	/* return pointer to path (if available) */
+	if (pathp)
+		*pathp = path ? path : NULL;
+
+	return ret;
+}
+
+/**
+ * overlay_phandle_add_offset - Increases a phandle by an offset
+ * @fdt: Base device tree blob
+ * @node: Device tree overlay blob
+ * @name: Name of the property to modify (phandle or linux,phandle)
+ * @delta: offset to apply
+ *
+ * overlay_phandle_add_offset() increments a node phandle by a given
+ * offset.
+ *
+ * returns:
+ *      0 on success.
+ *      Negative error code on error
+ */
+static int overlay_phandle_add_offset(void *fdt, int node,
+				      const char *name, uint32_t delta)
+{
+	const fdt32_t *val;
+	uint32_t adj_val;
+	int len;
+
+	val = fdt_getprop(fdt, node, name, &len);
+	if (!val)
+		return len;
+
+	if (len != sizeof(*val))
+		return -FDT_ERR_BADPHANDLE;
+
+	adj_val = fdt32_to_cpu(*val);
+	if ((adj_val + delta) < adj_val)
+		return -FDT_ERR_NOPHANDLES;
+
+	adj_val += delta;
+	if (adj_val == (uint32_t)-1)
+		return -FDT_ERR_NOPHANDLES;
+
+	return fdt_setprop_inplace_u32(fdt, node, name, adj_val);
+}
+
+/**
+ * overlay_adjust_node_phandles - Offsets the phandles of a node
+ * @fdto: Device tree overlay blob
+ * @node: Offset of the node we want to adjust
+ * @delta: Offset to shift the phandles of
+ *
+ * overlay_adjust_node_phandles() adds a constant to all the phandles
+ * of a given node. This is mainly use as part of the overlay
+ * application process, when we want to update all the overlay
+ * phandles to not conflict with the overlays of the base device tree.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_adjust_node_phandles(void *fdto, int node,
+					uint32_t delta)
+{
+	int child;
+	int ret;
+
+	ret = overlay_phandle_add_offset(fdto, node, "phandle", delta);
+	if (ret && ret != -FDT_ERR_NOTFOUND)
+		return ret;
+
+	ret = overlay_phandle_add_offset(fdto, node, "linux,phandle", delta);
+	if (ret && ret != -FDT_ERR_NOTFOUND)
+		return ret;
+
+	fdt_for_each_subnode(child, fdto, node) {
+		ret = overlay_adjust_node_phandles(fdto, child, delta);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * overlay_adjust_local_phandles - Adjust the phandles of a whole overlay
+ * @fdto: Device tree overlay blob
+ * @delta: Offset to shift the phandles of
+ *
+ * overlay_adjust_local_phandles() adds a constant to all the
+ * phandles of an overlay. This is mainly use as part of the overlay
+ * application process, when we want to update all the overlay
+ * phandles to not conflict with the overlays of the base device tree.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_adjust_local_phandles(void *fdto, uint32_t delta)
+{
+	/*
+	 * Start adjusting the phandles from the overlay root
+	 */
+	return overlay_adjust_node_phandles(fdto, 0, delta);
+}
+
+/**
+ * overlay_update_local_node_references - Adjust the overlay references
+ * @fdto: Device tree overlay blob
+ * @tree_node: Node offset of the node to operate on
+ * @fixup_node: Node offset of the matching local fixups node
+ * @delta: Offset to shift the phandles of
+ *
+ * overlay_update_local_nodes_references() update the phandles
+ * pointing to a node within the device tree overlay by adding a
+ * constant delta.
+ *
+ * This is mainly used as part of a device tree application process,
+ * where you want the device tree overlays phandles to not conflict
+ * with the ones from the base device tree before merging them.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_update_local_node_references(void *fdto,
+						int tree_node,
+						int fixup_node,
+						uint32_t delta)
+{
+	int fixup_prop;
+	int fixup_child;
+	int ret;
+
+	fdt_for_each_property_offset(fixup_prop, fdto, fixup_node) {
+		const fdt32_t *fixup_val;
+		const char *tree_val;
+		const char *name;
+		int fixup_len;
+		int tree_len;
+		int i;
+
+		fixup_val = fdt_getprop_by_offset(fdto, fixup_prop,
+						  &name, &fixup_len);
+		if (!fixup_val)
+			return fixup_len;
+
+		if (fixup_len % sizeof(uint32_t))
+			return -FDT_ERR_BADOVERLAY;
+
+		tree_val = fdt_getprop(fdto, tree_node, name, &tree_len);
+		if (!tree_val) {
+			if (tree_len == -FDT_ERR_NOTFOUND)
+				return -FDT_ERR_BADOVERLAY;
+
+			return tree_len;
+		}
+
+		for (i = 0; i < (fixup_len / sizeof(uint32_t)); i++) {
+			fdt32_t adj_val;
+			uint32_t poffset;
+
+			poffset = fdt32_to_cpu(fixup_val[i]);
+
+			/*
+			 * phandles to fixup can be unaligned.
+			 *
+			 * Use a memcpy for the architectures that do
+			 * not support unaligned accesses.
+			 */
+			memcpy(&adj_val, tree_val + poffset, sizeof(adj_val));
+
+			adj_val = cpu_to_fdt32(fdt32_to_cpu(adj_val) + delta);
+
+			ret = fdt_setprop_inplace_namelen_partial(fdto,
+								  tree_node,
+								  name,
+								  strlen(name),
+								  poffset,
+								  &adj_val,
+								  sizeof(adj_val));
+			if (ret == -FDT_ERR_NOSPACE)
+				return -FDT_ERR_BADOVERLAY;
+
+			if (ret)
+				return ret;
+		}
+	}
+
+	fdt_for_each_subnode(fixup_child, fdto, fixup_node) {
+		const char *fixup_child_name = fdt_get_name(fdto, fixup_child,
+							    NULL);
+		int tree_child;
+
+		tree_child = fdt_subnode_offset(fdto, tree_node,
+						fixup_child_name);
+		if (tree_child == -FDT_ERR_NOTFOUND)
+			return -FDT_ERR_BADOVERLAY;
+		if (tree_child < 0)
+			return tree_child;
+
+		ret = overlay_update_local_node_references(fdto,
+							   tree_child,
+							   fixup_child,
+							   delta);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * overlay_update_local_references - Adjust the overlay references
+ * @fdto: Device tree overlay blob
+ * @delta: Offset to shift the phandles of
+ *
+ * overlay_update_local_references() update all the phandles pointing
+ * to a node within the device tree overlay by adding a constant
+ * delta to not conflict with the base overlay.
+ *
+ * This is mainly used as part of a device tree application process,
+ * where you want the device tree overlays phandles to not conflict
+ * with the ones from the base device tree before merging them.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_update_local_references(void *fdto, uint32_t delta)
+{
+	int fixups;
+
+	fixups = fdt_path_offset(fdto, "/__local_fixups__");
+	if (fixups < 0) {
+		/* There's no local phandles to adjust, bail out */
+		if (fixups == -FDT_ERR_NOTFOUND)
+			return 0;
+
+		return fixups;
+	}
+
+	/*
+	 * Update our local references from the root of the tree
+	 */
+	return overlay_update_local_node_references(fdto, 0, fixups,
+						    delta);
+}
+
+/**
+ * overlay_fixup_one_phandle - Set an overlay phandle to the base one
+ * @fdt: Base Device Tree blob
+ * @fdto: Device tree overlay blob
+ * @symbols_off: Node offset of the symbols node in the base device tree
+ * @path: Path to a node holding a phandle in the overlay
+ * @path_len: number of path characters to consider
+ * @name: Name of the property holding the phandle reference in the overlay
+ * @name_len: number of name characters to consider
+ * @poffset: Offset within the overlay property where the phandle is stored
+ * @label: Label of the node referenced by the phandle
+ *
+ * overlay_fixup_one_phandle() resolves an overlay phandle pointing to
+ * a node in the base device tree.
+ *
+ * This is part of the device tree overlay application process, when
+ * you want all the phandles in the overlay to point to the actual
+ * base dt nodes.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_fixup_one_phandle(void *fdt, void *fdto,
+				     int symbols_off,
+				     const char *path, uint32_t path_len,
+				     const char *name, uint32_t name_len,
+				     int poffset, const char *label)
+{
+	const char *symbol_path;
+	uint32_t phandle;
+	fdt32_t phandle_prop;
+	int symbol_off, fixup_off;
+	int prop_len;
+
+	if (symbols_off < 0)
+		return symbols_off;
+
+	symbol_path = fdt_getprop(fdt, symbols_off, label,
+				  &prop_len);
+	if (!symbol_path)
+		return prop_len;
+
+	symbol_off = fdt_path_offset(fdt, symbol_path);
+	if (symbol_off < 0)
+		return symbol_off;
+
+	phandle = fdt_get_phandle(fdt, symbol_off);
+	if (!phandle)
+		return -FDT_ERR_NOTFOUND;
+
+	fixup_off = fdt_path_offset_namelen(fdto, path, path_len);
+	if (fixup_off == -FDT_ERR_NOTFOUND)
+		return -FDT_ERR_BADOVERLAY;
+	if (fixup_off < 0)
+		return fixup_off;
+
+	phandle_prop = cpu_to_fdt32(phandle);
+	return fdt_setprop_inplace_namelen_partial(fdto, fixup_off,
+						   name, name_len, poffset,
+						   &phandle_prop,
+						   sizeof(phandle_prop));
+};
+
+/**
+ * overlay_fixup_phandle - Set an overlay phandle to the base one
+ * @fdt: Base Device Tree blob
+ * @fdto: Device tree overlay blob
+ * @symbols_off: Node offset of the symbols node in the base device tree
+ * @property: Property offset in the overlay holding the list of fixups
+ *
+ * overlay_fixup_phandle() resolves all the overlay phandles pointed
+ * to in a __fixups__ property, and updates them to match the phandles
+ * in use in the base device tree.
+ *
+ * This is part of the device tree overlay application process, when
+ * you want all the phandles in the overlay to point to the actual
+ * base dt nodes.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_fixup_phandle(void *fdt, void *fdto, int symbols_off,
+				 int property)
+{
+	const char *value;
+	const char *label;
+	int len;
+
+	value = fdt_getprop_by_offset(fdto, property,
+				      &label, &len);
+	if (!value) {
+		if (len == -FDT_ERR_NOTFOUND)
+			return -FDT_ERR_INTERNAL;
+
+		return len;
+	}
+
+	do {
+		const char *path, *name, *fixup_end;
+		const char *fixup_str = value;
+		uint32_t path_len, name_len;
+		uint32_t fixup_len;
+		char *sep, *endptr;
+		int poffset, ret;
+
+		fixup_end = memchr(value, '\0', len);
+		if (!fixup_end)
+			return -FDT_ERR_BADOVERLAY;
+		fixup_len = fixup_end - fixup_str;
+
+		len -= fixup_len + 1;
+		value += fixup_len + 1;
+
+		path = fixup_str;
+		sep = memchr(fixup_str, ':', fixup_len);
+		if (!sep || *sep != ':')
+			return -FDT_ERR_BADOVERLAY;
+
+		path_len = sep - path;
+		if (path_len == (fixup_len - 1))
+			return -FDT_ERR_BADOVERLAY;
+
+		fixup_len -= path_len + 1;
+		name = sep + 1;
+		sep = memchr(name, ':', fixup_len);
+		if (!sep || *sep != ':')
+			return -FDT_ERR_BADOVERLAY;
+
+		name_len = sep - name;
+		if (!name_len)
+			return -FDT_ERR_BADOVERLAY;
+
+		poffset = strtoul(sep + 1, &endptr, 10);
+		if ((*endptr != '\0') || (endptr <= (sep + 1)))
+			return -FDT_ERR_BADOVERLAY;
+
+		ret = overlay_fixup_one_phandle(fdt, fdto, symbols_off,
+						path, path_len, name, name_len,
+						poffset, label);
+		if (ret)
+			return ret;
+	} while (len > 0);
+
+	return 0;
+}
+
+/**
+ * overlay_fixup_phandles - Resolve the overlay phandles to the base
+ *                          device tree
+ * @fdt: Base Device Tree blob
+ * @fdto: Device tree overlay blob
+ *
+ * overlay_fixup_phandles() resolves all the overlay phandles pointing
+ * to nodes in the base device tree.
+ *
+ * This is one of the steps of the device tree overlay application
+ * process, when you want all the phandles in the overlay to point to
+ * the actual base dt nodes.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_fixup_phandles(void *fdt, void *fdto)
+{
+	int fixups_off, symbols_off;
+	int property;
+
+	/* We can have overlays without any fixups */
+	fixups_off = fdt_path_offset(fdto, "/__fixups__");
+	if (fixups_off == -FDT_ERR_NOTFOUND)
+		return 0; /* nothing to do */
+	if (fixups_off < 0)
+		return fixups_off;
+
+	/* And base DTs without symbols */
+	symbols_off = fdt_path_offset(fdt, "/__symbols__");
+	if ((symbols_off < 0 && (symbols_off != -FDT_ERR_NOTFOUND)))
+		return symbols_off;
+
+	fdt_for_each_property_offset(property, fdto, fixups_off) {
+		int ret;
+
+		ret = overlay_fixup_phandle(fdt, fdto, symbols_off, property);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * overlay_apply_node - Merges a node into the base device tree
+ * @fdt: Base Device Tree blob
+ * @target: Node offset in the base device tree to apply the fragment to
+ * @fdto: Device tree overlay blob
+ * @node: Node offset in the overlay holding the changes to merge
+ *
+ * overlay_apply_node() merges a node into a target base device tree
+ * node pointed.
+ *
+ * This is part of the final step in the device tree overlay
+ * application process, when all the phandles have been adjusted and
+ * resolved and you just have to merge overlay into the base device
+ * tree.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_apply_node(void *fdt, int target,
+			      void *fdto, int node)
+{
+	int property;
+	int subnode;
+
+	fdt_for_each_property_offset(property, fdto, node) {
+		const char *name;
+		const void *prop;
+		int prop_len;
+		int ret;
+
+		prop = fdt_getprop_by_offset(fdto, property, &name,
+					     &prop_len);
+		if (prop_len == -FDT_ERR_NOTFOUND)
+			return -FDT_ERR_INTERNAL;
+		if (prop_len < 0)
+			return prop_len;
+
+		ret = fdt_setprop(fdt, target, name, prop, prop_len);
+		if (ret)
+			return ret;
+	}
+
+	fdt_for_each_subnode(subnode, fdto, node) {
+		const char *name = fdt_get_name(fdto, subnode, NULL);
+		int nnode;
+		int ret;
+
+		nnode = fdt_add_subnode(fdt, target, name);
+		if (nnode == -FDT_ERR_EXISTS) {
+			nnode = fdt_subnode_offset(fdt, target, name);
+			if (nnode == -FDT_ERR_NOTFOUND)
+				return -FDT_ERR_INTERNAL;
+		}
+
+		if (nnode < 0)
+			return nnode;
+
+		ret = overlay_apply_node(fdt, nnode, fdto, subnode);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * overlay_merge - Merge an overlay into its base device tree
+ * @fdt: Base Device Tree blob
+ * @fdto: Device tree overlay blob
+ *
+ * overlay_merge() merges an overlay into its base device tree.
+ *
+ * This is the next to last step in the device tree overlay application
+ * process, when all the phandles have been adjusted and resolved and
+ * you just have to merge overlay into the base device tree.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_merge(void *fdt, void *fdto)
+{
+	int fragment;
+
+	fdt_for_each_subnode(fragment, fdto, 0) {
+		int overlay;
+		int target;
+		int ret;
+
+		/*
+		 * Each fragments will have an __overlay__ node. If
+		 * they don't, it's not supposed to be merged
+		 */
+		overlay = fdt_subnode_offset(fdto, fragment, "__overlay__");
+		if (overlay == -FDT_ERR_NOTFOUND)
+			continue;
+
+		if (overlay < 0)
+			return overlay;
+
+		target = overlay_get_target(fdt, fdto, fragment, NULL);
+		if (target < 0)
+			return target;
+
+		ret = overlay_apply_node(fdt, target, fdto, overlay);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int get_path_len(const void *fdt, int nodeoffset)
+{
+	int len = 0, namelen;
+	const char *name;
+
+	FDT_CHECK_HEADER(fdt);
+
+	for (;;) {
+		name = fdt_get_name(fdt, nodeoffset, &namelen);
+		if (!name)
+			return namelen;
+
+		/* root? we're done */
+		if (namelen == 0)
+			break;
+
+		nodeoffset = fdt_parent_offset(fdt, nodeoffset);
+		if (nodeoffset < 0)
+			return nodeoffset;
+		len += namelen + 1;
+	}
+
+	/* in case of root pretend it's "/" */
+	if (len == 0)
+		len++;
+	return len;
+}
+
+/**
+ * overlay_symbol_update - Update the symbols of base tree after a merge
+ * @fdt: Base Device Tree blob
+ * @fdto: Device tree overlay blob
+ *
+ * overlay_symbol_update() updates the symbols of the base tree with the
+ * symbols of the applied overlay
+ *
+ * This is the last step in the device tree overlay application
+ * process, allowing the reference of overlay symbols by subsequent
+ * overlay operations.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_symbol_update(void *fdt, void *fdto)
+{
+	int root_sym, ov_sym, prop, path_len, fragment, target;
+	int len, frag_name_len, ret, rel_path_len;
+	const char *s, *e;
+	const char *path;
+	const char *name;
+	const char *frag_name;
+	const char *rel_path;
+	const char *target_path;
+	char *buf;
+	void *p;
+
+	ov_sym = fdt_subnode_offset(fdto, 0, "__symbols__");
+
+	/* if no overlay symbols exist no problem */
+	if (ov_sym < 0)
+		return 0;
+
+	root_sym = fdt_subnode_offset(fdt, 0, "__symbols__");
+
+	/* it no root symbols exist we should create them */
+	if (root_sym == -FDT_ERR_NOTFOUND)
+		root_sym = fdt_add_subnode(fdt, 0, "__symbols__");
+
+	/* any error is fatal now */
+	if (root_sym < 0)
+		return root_sym;
+
+	/* iterate over each overlay symbol */
+	fdt_for_each_property_offset(prop, fdto, ov_sym) {
+		path = fdt_getprop_by_offset(fdto, prop, &name, &path_len);
+		if (!path)
+			return path_len;
+
+		/* verify it's a string property (terminated by a single \0) */
+		if (path_len < 1 || memchr(path, '\0', path_len) != &path[path_len - 1])
+			return -FDT_ERR_BADVALUE;
+
+		/* keep end marker to avoid strlen() */
+		e = path + path_len;
+
+		/* format: /<fragment-name>/__overlay__/<relative-subnode-path> */
+
+		if (*path != '/')
+			return -FDT_ERR_BADVALUE;
+
+		/* get fragment name first */
+		s = strchr(path + 1, '/');
+		if (!s)
+			return -FDT_ERR_BADOVERLAY;
+
+		frag_name = path + 1;
+		frag_name_len = s - path - 1;
+
+		/* verify format; safe since "s" lies in \0 terminated prop */
+		len = sizeof("/__overlay__/") - 1;
+		if ((e - s) < len || memcmp(s, "/__overlay__/", len))
+			return -FDT_ERR_BADOVERLAY;
+
+		rel_path = s + len;
+		rel_path_len = e - rel_path;
+
+		/* find the fragment index in which the symbol lies */
+		ret = fdt_subnode_offset_namelen(fdto, 0, frag_name,
+					       frag_name_len);
+		/* not found? */
+		if (ret < 0)
+			return -FDT_ERR_BADOVERLAY;
+		fragment = ret;
+
+		/* an __overlay__ subnode must exist */
+		ret = fdt_subnode_offset(fdto, fragment, "__overlay__");
+		if (ret < 0)
+			return -FDT_ERR_BADOVERLAY;
+
+		/* get the target of the fragment */
+		ret = overlay_get_target(fdt, fdto, fragment, &target_path);
+		if (ret < 0)
+			return ret;
+		target = ret;
+
+		/* if we have a target path use */
+		if (!target_path) {
+			ret = get_path_len(fdt, target);
+			if (ret < 0)
+				return ret;
+			len = ret;
+		} else {
+			len = strlen(target_path);
+		}
+
+		ret = fdt_setprop_placeholder(fdt, root_sym, name,
+				len + (len > 1) + rel_path_len + 1, &p);
+		if (ret < 0)
+			return ret;
+
+		if (!target_path) {
+			/* again in case setprop_placeholder changed it */
+			ret = overlay_get_target(fdt, fdto, fragment, &target_path);
+			if (ret < 0)
+				return ret;
+			target = ret;
+		}
+
+		buf = p;
+		if (len > 1) { /* target is not root */
+			if (!target_path) {
+				ret = fdt_get_path(fdt, target, buf, len + 1);
+				if (ret < 0)
+					return ret;
+			} else
+				memcpy(buf, target_path, len + 1);
+
+		} else
+			len--;
+
+		buf[len] = '/';
+		memcpy(buf + len + 1, rel_path, rel_path_len);
+		buf[len + 1 + rel_path_len] = '\0';
+	}
+
+	return 0;
+}
+
+int fdt_overlay_apply(void *fdt, void *fdto)
+{
+	uint32_t delta = fdt_get_max_phandle(fdt);
+	int ret;
+
+	FDT_CHECK_HEADER(fdt);
+	FDT_CHECK_HEADER(fdto);
+
+	ret = overlay_adjust_local_phandles(fdto, delta);
+	if (ret)
+		goto err;
+
+	ret = overlay_update_local_references(fdto, delta);
+	if (ret)
+		goto err;
+
+	ret = overlay_fixup_phandles(fdt, fdto);
+	if (ret)
+		goto err;
+
+	ret = overlay_merge(fdt, fdto);
+	if (ret)
+		goto err;
+
+	ret = overlay_symbol_update(fdt, fdto);
+	if (ret)
+		goto err;
+
+	/*
+	 * The overlay has been damaged, erase its magic.
+	 */
+	fdt_set_magic(fdto, ~0);
+
+	return 0;
+
+err:
+	/*
+	 * The overlay might have been damaged, erase its magic.
+	 */
+	fdt_set_magic(fdto, ~0);
+
+	/*
+	 * The base device tree might have been damaged, erase its
+	 * magic.
+	 */
+	fdt_set_magic(fdt, ~0);
+
+	return ret;
+}
diff -urN u-boot-1.1.6/common/fdt/fdt_region.c u-boot-1.1.6_fdt/common/fdt/fdt_region.c
--- u-boot-1.1.6/common/fdt/fdt_region.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt_region.c	2018-10-22 15:54:19.581640154 +0800
@@ -0,0 +1,653 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-2-Clause
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2013 Google, Inc
+ * Written by Simon Glass <sjg@chromium.org>
+ */
+
+#include <linux/libfdt_env.h>
+
+#ifndef USE_HOSTCC
+#include <fdt.h>
+#include <linux/libfdt.h>
+#else
+#include "fdt_host.h"
+#endif
+
+#define FDT_MAX_DEPTH	32
+
+static int str_in_list(const char *str, char * const list[], int count)
+{
+	int i;
+
+	for (i = 0; i < count; i++)
+		if (!strcmp(list[i], str))
+			return 1;
+
+	return 0;
+}
+
+int fdt_find_regions(const void *fdt, char * const inc[], int inc_count,
+		     char * const exc_prop[], int exc_prop_count,
+		     struct fdt_region region[], int max_regions,
+		     char *path, int path_len, int add_string_tab)
+{
+	int stack[FDT_MAX_DEPTH] = { 0 };
+	char *end;
+	int nextoffset = 0;
+	uint32_t tag;
+	int count = 0;
+	int start = -1;
+	int depth = -1;
+	int want = 0;
+	int base = fdt_off_dt_struct(fdt);
+
+	end = path;
+	*end = '\0';
+	do {
+		const struct fdt_property *prop;
+		const char *name;
+		const char *str;
+		int include = 0;
+		int stop_at = 0;
+		int offset;
+		int len;
+
+		offset = nextoffset;
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+		stop_at = nextoffset;
+
+		switch (tag) {
+		case FDT_PROP:
+			include = want >= 2;
+			stop_at = offset;
+			prop = fdt_get_property_by_offset(fdt, offset, NULL);
+			str = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));
+			if (str_in_list(str, exc_prop, exc_prop_count))
+				include = 0;
+			break;
+
+		case FDT_NOP:
+			include = want >= 2;
+			stop_at = offset;
+			break;
+
+		case FDT_BEGIN_NODE:
+			depth++;
+			if (depth == FDT_MAX_DEPTH)
+				return -FDT_ERR_BADSTRUCTURE;
+			name = fdt_get_name(fdt, offset, &len);
+			if (end - path + 2 + len >= path_len)
+				return -FDT_ERR_NOSPACE;
+			if (end != path + 1)
+				*end++ = '/';
+			strcpy(end, name);
+			end += len;
+			stack[depth] = want;
+			if (want == 1)
+				stop_at = offset;
+			if (str_in_list(path, inc, inc_count))
+				want = 2;
+			else if (want)
+				want--;
+			else
+				stop_at = offset;
+			include = want;
+			break;
+
+		case FDT_END_NODE:
+			include = want;
+			want = stack[depth--];
+			while (end > path && *--end != '/')
+				;
+			*end = '\0';
+			break;
+
+		case FDT_END:
+			include = 1;
+			break;
+		}
+
+		if (include && start == -1) {
+			/* Should we merge with previous? */
+			if (count && count <= max_regions &&
+			    offset == region[count - 1].offset +
+					region[count - 1].size - base)
+				start = region[--count].offset - base;
+			else
+				start = offset;
+		}
+
+		if (!include && start != -1) {
+			if (count < max_regions) {
+				region[count].offset = base + start;
+				region[count].size = stop_at - start;
+			}
+			count++;
+			start = -1;
+		}
+	} while (tag != FDT_END);
+
+	if (nextoffset != fdt_size_dt_struct(fdt))
+		return -FDT_ERR_BADLAYOUT;
+
+	/* Add a region for the END tag and the string table */
+	if (count < max_regions) {
+		region[count].offset = base + start;
+		region[count].size = nextoffset - start;
+		if (add_string_tab)
+			region[count].size += fdt_size_dt_strings(fdt);
+	}
+	count++;
+
+	return count;
+}
+
+/**
+ * fdt_add_region() - Add a new region to our list
+ * @info:	State information
+ * @offset:	Start offset of region
+ * @size:	Size of region
+ *
+ * The region is added if there is space, but in any case we increment the
+ * count. If permitted, and the new region overlaps the last one, we merge
+ * them.
+ */
+static int fdt_add_region(struct fdt_region_state *info, int offset, int size)
+{
+	struct fdt_region *reg;
+
+	reg = info->region ? &info->region[info->count - 1] : NULL;
+	if (info->can_merge && info->count &&
+	    info->count <= info->max_regions &&
+	    reg && offset <= reg->offset + reg->size) {
+		reg->size = offset + size - reg->offset;
+	} else if (info->count++ < info->max_regions) {
+		if (reg) {
+			reg++;
+			reg->offset = offset;
+			reg->size = size;
+		}
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int region_list_contains_offset(struct fdt_region_state *info,
+				       const void *fdt, int target)
+{
+	struct fdt_region *reg;
+	int num;
+
+	target += fdt_off_dt_struct(fdt);
+	for (reg = info->region, num = 0; num < info->count; reg++, num++) {
+		if (target >= reg->offset && target < reg->offset + reg->size)
+			return 1;
+	}
+
+	return 0;
+}
+
+/**
+ * fdt_add_alias_regions() - Add regions covering the aliases that we want
+ *
+ * The /aliases node is not automatically included by fdtgrep unless the
+ * command-line arguments cause to be included (or not excluded). However
+ * aliases are special in that we generally want to include those which
+ * reference a node that fdtgrep includes.
+ *
+ * In fact we want to include only aliases for those nodes still included in
+ * the fdt, and drop the other aliases since they point to nodes that will not
+ * be present.
+ *
+ * This function scans the aliases and adds regions for those which we want
+ * to keep.
+ *
+ * @fdt: Device tree to scan
+ * @region: List of regions
+ * @count: Number of regions in the list so far (i.e. starting point for this
+ *	function)
+ * @max_regions: Maximum number of regions in @region list
+ * @info: Place to put the region state
+ * @return number of regions after processing, or -FDT_ERR_NOSPACE if we did
+ * not have enough room in the regions table for the regions we wanted to add.
+ */
+int fdt_add_alias_regions(const void *fdt, struct fdt_region *region, int count,
+			  int max_regions, struct fdt_region_state *info)
+{
+	int base = fdt_off_dt_struct(fdt);
+	int node, node_end, offset;
+	int did_alias_header;
+
+	node = fdt_subnode_offset(fdt, 0, "aliases");
+	if (node < 0)
+		return -FDT_ERR_NOTFOUND;
+
+	/*
+	 * Find the next node so that we know where the /aliases node ends. We
+	 * need special handling if /aliases is the last node.
+	 */
+	node_end = fdt_next_subnode(fdt, node);
+	if (node_end == -FDT_ERR_NOTFOUND)
+		/* Move back to the FDT_END_NODE tag of '/' */
+		node_end = fdt_size_dt_struct(fdt) - sizeof(fdt32_t) * 2;
+	else if (node_end < 0) /* other error */
+		return node_end;
+	node_end -= sizeof(fdt32_t);  /* Move to FDT_END_NODE tag of /aliases */
+
+	did_alias_header = 0;
+	info->region = region;
+	info->count = count;
+	info->can_merge = 0;
+	info->max_regions = max_regions;
+
+	for (offset = fdt_first_property_offset(fdt, node);
+	     offset >= 0;
+	     offset = fdt_next_property_offset(fdt, offset)) {
+		const struct fdt_property *prop;
+		const char *name;
+		int target, next;
+
+		prop = fdt_get_property_by_offset(fdt, offset, NULL);
+		name = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));
+		target = fdt_path_offset(fdt, name);
+		if (!region_list_contains_offset(info, fdt, target))
+			continue;
+		next = fdt_next_property_offset(fdt, offset);
+		if (next < 0)
+			next = node_end;
+
+		if (!did_alias_header) {
+			fdt_add_region(info, base + node, 12);
+			did_alias_header = 1;
+		}
+		fdt_add_region(info, base + offset, next - offset);
+	}
+
+	/* Add the FDT_END_NODE tag */
+	if (did_alias_header)
+		fdt_add_region(info, base + node_end, sizeof(fdt32_t));
+
+	return info->count < max_regions ? info->count : -FDT_ERR_NOSPACE;
+}
+
+/**
+ * fdt_include_supernodes() - Include supernodes required by this node
+ * @info:	State information
+ * @depth:	Current stack depth
+ *
+ * When we decided to include a node or property which is not at the top
+ * level, this function forces the inclusion of higher level nodes. For
+ * example, given this tree:
+ *
+ * / {
+ *     testing {
+ *     }
+ * }
+ *
+ * If we decide to include testing then we need the root node to have a valid
+ * tree. This function adds those regions.
+ */
+static int fdt_include_supernodes(struct fdt_region_state *info, int depth)
+{
+	int base = fdt_off_dt_struct(info->fdt);
+	int start, stop_at;
+	int i;
+
+	/*
+	 * Work down the stack looking for supernodes that we didn't include.
+	 * The algortihm here is actually pretty simple, since we know that
+	 * no previous subnode had to include these nodes, or if it did, we
+	 * marked them as included (on the stack) already.
+	 */
+	for (i = 0; i <= depth; i++) {
+		if (!info->stack[i].included) {
+			start = info->stack[i].offset;
+
+			/* Add the FDT_BEGIN_NODE tag of this supernode */
+			fdt_next_tag(info->fdt, start, &stop_at);
+			if (fdt_add_region(info, base + start, stop_at - start))
+				return -1;
+
+			/* Remember that this supernode is now included */
+			info->stack[i].included = 1;
+			info->can_merge = 1;
+		}
+
+		/* Force (later) generation of the FDT_END_NODE tag */
+		if (!info->stack[i].want)
+			info->stack[i].want = WANT_NODES_ONLY;
+	}
+
+	return 0;
+}
+
+enum {
+	FDT_DONE_NOTHING,
+	FDT_DONE_MEM_RSVMAP,
+	FDT_DONE_STRUCT,
+	FDT_DONE_END,
+	FDT_DONE_STRINGS,
+	FDT_DONE_ALL,
+};
+
+int fdt_first_region(const void *fdt,
+		int (*h_include)(void *priv, const void *fdt, int offset,
+				 int type, const char *data, int size),
+		void *priv, struct fdt_region *region,
+		char *path, int path_len, int flags,
+		struct fdt_region_state *info)
+{
+	struct fdt_region_ptrs *p = &info->ptrs;
+
+	/* Set up our state */
+	info->fdt = fdt;
+	info->can_merge = 1;
+	info->max_regions = 1;
+	info->start = -1;
+	p->want = WANT_NOTHING;
+	p->end = path;
+	*p->end = '\0';
+	p->nextoffset = 0;
+	p->depth = -1;
+	p->done = FDT_DONE_NOTHING;
+
+	return fdt_next_region(fdt, h_include, priv, region,
+			       path, path_len, flags, info);
+}
+
+/***********************************************************************
+ *
+ *	Theory of operation
+ *
+ * Note: in this description 'included' means that a node (or other part
+ * of the tree) should be included in the region list, i.e. it will have
+ * a region which covers its part of the tree.
+ *
+ * This function maintains some state from the last time it is called.
+ * It checks the next part of the tree that it is supposed to look at
+ * (p.nextoffset) to see if that should be included or not. When it
+ * finds something to include, it sets info->start to its offset. This
+ * marks the start of the region we want to include.
+ *
+ * Once info->start is set to the start (i.e. not -1), we continue
+ * scanning until we find something that we don't want included. This
+ * will be the end of a region. At this point we can close off the
+ * region and add it to the list. So we do so, and reset info->start
+ * to -1.
+ *
+ * One complication here is that we want to merge regions. So when we
+ * come to add another region later, we may in fact merge it with the
+ * previous one if one ends where the other starts.
+ *
+ * The function fdt_add_region() will return -1 if it fails to add the
+ * region, because we already have a region ready to be returned, and
+ * the new one cannot be merged in with it. In this case, we must return
+ * the region we found, and wait for another call to this function.
+ * When it comes, we will repeat the processing of the tag and again
+ * try to add a region. This time it will succeed.
+ *
+ * The current state of the pointers (stack, offset, etc.) is maintained
+ * in a ptrs member. At the start of every loop iteration we make a copy
+ * of it.  The copy is then updated as the tag is processed. Only if we
+ * get to the end of the loop iteration (and successfully call
+ * fdt_add_region() if we need to) can we commit the changes we have
+ * made to these pointers. For example, if we see an FDT_END_NODE tag,
+ * we will decrement the depth value. But if we need to add a region
+ * for this tag (let's say because the previous tag is included and this
+ * FDT_END_NODE tag is not included) then we will only commit the result
+ * if we were able to add the region. That allows us to retry again next
+ * time.
+ *
+ * We keep track of a variable called 'want' which tells us what we want
+ * to include when there is no specific information provided by the
+ * h_include function for a particular property. This basically handles
+ * the inclusion of properties which are pulled in by virtue of the node
+ * they are in. So if you include a node, its properties are also
+ * included.  In this case 'want' will be WANT_NODES_AND_PROPS. The
+ * FDT_REG_DIRECT_SUBNODES feature also makes use of 'want'. While we
+ * are inside the subnode, 'want' will be set to WANT_NODES_ONLY, so
+ * that only the subnode's FDT_BEGIN_NODE and FDT_END_NODE tags will be
+ * included, and properties will be skipped. If WANT_NOTHING is
+ * selected, then we will just rely on what the h_include() function
+ * tells us.
+ *
+ * Using 'want' we work out 'include', which tells us whether this
+ * current tag should be included or not. As you can imagine, if the
+ * value of 'include' changes, that means we are on a boundary between
+ * nodes to include and nodes to exclude. At this point we either close
+ * off a previous region and add it to the list, or mark the start of a
+ * new region.
+ *
+ * Apart from the nodes, we have mem_rsvmap, the FDT_END tag and the
+ * string list. Each of these dealt with as a whole (i.e. we create a
+ * region for each if it is to be included). For mem_rsvmap we don't
+ * allow it to merge with the first struct region. For the stringlist,
+ * we don't allow it to merge with the last struct region (which
+ * contains at minimum the FDT_END tag).
+ *
+ *********************************************************************/
+
+int fdt_next_region(const void *fdt,
+		int (*h_include)(void *priv, const void *fdt, int offset,
+				 int type, const char *data, int size),
+		void *priv, struct fdt_region *region,
+		char *path, int path_len, int flags,
+		struct fdt_region_state *info)
+{
+	int base = fdt_off_dt_struct(fdt);
+	int last_node = 0;
+	const char *str;
+
+	info->region = region;
+	info->count = 0;
+	if (info->ptrs.done < FDT_DONE_MEM_RSVMAP &&
+	    (flags & FDT_REG_ADD_MEM_RSVMAP)) {
+		/* Add the memory reserve map into its own region */
+		if (fdt_add_region(info, fdt_off_mem_rsvmap(fdt),
+				   fdt_off_dt_struct(fdt) -
+				   fdt_off_mem_rsvmap(fdt)))
+			return 0;
+		info->can_merge = 0;	/* Don't allow merging with this */
+		info->ptrs.done = FDT_DONE_MEM_RSVMAP;
+	}
+
+	/*
+	 * Work through the tags one by one, deciding whether each needs to
+	 * be included or not. We set the variable 'include' to indicate our
+	 * decision. 'want' is used to track what we want to include - it
+	 * allows us to pick up all the properties (and/or subnode tags) of
+	 * a node.
+	 */
+	while (info->ptrs.done < FDT_DONE_STRUCT) {
+		const struct fdt_property *prop;
+		struct fdt_region_ptrs p;
+		const char *name;
+		int include = 0;
+		int stop_at = 0;
+		uint32_t tag;
+		int offset;
+		int val;
+		int len;
+
+		/*
+		 * Make a copy of our pointers. If we make it to the end of
+		 * this block then we will commit them back to info->ptrs.
+		 * Otherwise we can try again from the same starting state
+		 * next time we are called.
+		 */
+		p = info->ptrs;
+
+		/*
+		 * Find the tag, and the offset of the next one. If we need to
+		 * stop including tags, then by default we stop *after*
+		 * including the current tag
+		 */
+		offset = p.nextoffset;
+		tag = fdt_next_tag(fdt, offset, &p.nextoffset);
+		stop_at = p.nextoffset;
+
+		switch (tag) {
+		case FDT_PROP:
+			stop_at = offset;
+			prop = fdt_get_property_by_offset(fdt, offset, NULL);
+			str = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));
+			val = h_include(priv, fdt, last_node, FDT_IS_PROP, str,
+					    strlen(str) + 1);
+			if (val == -1) {
+				include = p.want >= WANT_NODES_AND_PROPS;
+			} else {
+				include = val;
+				/*
+				 * Make sure we include the } for this block.
+				 * It might be more correct to have this done
+				 * by the call to fdt_include_supernodes() in
+				 * the case where it adds the node we are
+				 * currently in, but this is equivalent.
+				 */
+				if ((flags & FDT_REG_SUPERNODES) && val &&
+				    !p.want)
+					p.want = WANT_NODES_ONLY;
+			}
+
+			/* Value grepping is not yet supported */
+			break;
+
+		case FDT_NOP:
+			include = p.want >= WANT_NODES_AND_PROPS;
+			stop_at = offset;
+			break;
+
+		case FDT_BEGIN_NODE:
+			last_node = offset;
+			p.depth++;
+			if (p.depth == FDT_MAX_DEPTH)
+				return -FDT_ERR_BADSTRUCTURE;
+			name = fdt_get_name(fdt, offset, &len);
+			if (p.end - path + 2 + len >= path_len)
+				return -FDT_ERR_NOSPACE;
+
+			/* Build the full path of this node */
+			if (p.end != path + 1)
+				*p.end++ = '/';
+			strcpy(p.end, name);
+			p.end += len;
+			info->stack[p.depth].want = p.want;
+			info->stack[p.depth].offset = offset;
+
+			/*
+			 * If we are not intending to include this node unless
+			 * it matches, make sure we stop *before* its tag.
+			 */
+			if (p.want == WANT_NODES_ONLY ||
+			    !(flags & (FDT_REG_DIRECT_SUBNODES |
+				       FDT_REG_ALL_SUBNODES))) {
+				stop_at = offset;
+				p.want = WANT_NOTHING;
+			}
+			val = h_include(priv, fdt, offset, FDT_IS_NODE, path,
+					p.end - path + 1);
+
+			/* Include this if requested */
+			if (val) {
+				p.want = (flags & FDT_REG_ALL_SUBNODES) ?
+					WANT_ALL_NODES_AND_PROPS :
+					WANT_NODES_AND_PROPS;
+			}
+
+			/* If not requested, decay our 'p.want' value */
+			else if (p.want) {
+				if (p.want != WANT_ALL_NODES_AND_PROPS)
+					p.want--;
+
+			/* Not including this tag, so stop now */
+			} else {
+				stop_at = offset;
+			}
+
+			/*
+			 * Decide whether to include this tag, and update our
+			 * stack with the state for this node
+			 */
+			include = p.want;
+			info->stack[p.depth].included = include;
+			break;
+
+		case FDT_END_NODE:
+			include = p.want;
+			if (p.depth < 0)
+				return -FDT_ERR_BADSTRUCTURE;
+
+			/*
+			 * If we don't want this node, stop right away, unless
+			 * we are including subnodes
+			 */
+			if (!p.want && !(flags & FDT_REG_DIRECT_SUBNODES))
+				stop_at = offset;
+			p.want = info->stack[p.depth].want;
+			p.depth--;
+			while (p.end > path && *--p.end != '/')
+				;
+			*p.end = '\0';
+			break;
+
+		case FDT_END:
+			/* We always include the end tag */
+			include = 1;
+			p.done = FDT_DONE_STRUCT;
+			break;
+		}
+
+		/* If this tag is to be included, mark it as region start */
+		if (include && info->start == -1) {
+			/* Include any supernodes required by this one */
+			if (flags & FDT_REG_SUPERNODES) {
+				if (fdt_include_supernodes(info, p.depth))
+					return 0;
+			}
+			info->start = offset;
+		}
+
+		/*
+		 * If this tag is not to be included, finish up the current
+		 * region.
+		 */
+		if (!include && info->start != -1) {
+			if (fdt_add_region(info, base + info->start,
+					   stop_at - info->start))
+				return 0;
+			info->start = -1;
+			info->can_merge = 1;
+		}
+
+		/* If we have made it this far, we can commit our pointers */
+		info->ptrs = p;
+	}
+
+	/* Add a region for the END tag and a separate one for string table */
+	if (info->ptrs.done < FDT_DONE_END) {
+		if (info->ptrs.nextoffset != fdt_size_dt_struct(fdt))
+			return -FDT_ERR_BADSTRUCTURE;
+
+		if (fdt_add_region(info, base + info->start,
+				   info->ptrs.nextoffset - info->start))
+			return 0;
+		info->ptrs.done++;
+	}
+	if (info->ptrs.done < FDT_DONE_STRINGS) {
+		if (flags & FDT_REG_ADD_STRING_TAB) {
+			info->can_merge = 0;
+			if (fdt_off_dt_strings(fdt) <
+			    base + info->ptrs.nextoffset)
+				return -FDT_ERR_BADLAYOUT;
+			if (fdt_add_region(info, fdt_off_dt_strings(fdt),
+					   fdt_size_dt_strings(fdt)))
+				return 0;
+		}
+		info->ptrs.done++;
+	}
+
+	return info->count > 0 ? 0 : -FDT_ERR_NOTFOUND;
+}
diff -urN u-boot-1.1.6/common/fdt/fdt_ro.c u-boot-1.1.6_fdt/common/fdt/fdt_ro.c
--- u-boot-1.1.6/common/fdt/fdt_ro.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt_ro.c	2018-10-22 15:54:19.585640154 +0800
@@ -0,0 +1,682 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-2-Clause
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <linux/libfdt_env.h>
+
+#ifndef USE_HOSTCC
+#include <fdt.h>
+#include <linux/libfdt.h>
+#else
+#include "fdt_host.h"
+#endif
+
+#include "libfdt_internal.h"
+
+static int _fdt_nodename_eq(const void *fdt, int offset,
+			    const char *s, int len)
+{
+	const char *p = fdt_offset_ptr(fdt, offset + FDT_TAGSIZE, len+1);
+
+	if (!p)
+		/* short match */
+		return 0;
+
+	if (memcmp(p, s, len) != 0)
+		return 0;
+
+	if (p[len] == '\0')
+		return 1;
+	else if (!memchr(s, '@', len) && (p[len] == '@'))
+		return 1;
+	else
+		return 0;
+}
+
+const char *fdt_string(const void *fdt, int stroffset)
+{
+	return (const char *)fdt + fdt_off_dt_strings(fdt) + stroffset;
+}
+
+static int _fdt_string_eq(const void *fdt, int stroffset,
+			  const char *s, int len)
+{
+	const char *p = fdt_string(fdt, stroffset);
+
+	return (strnlen(p, len + 1) == len) && (memcmp(p, s, len) == 0);
+}
+
+uint32_t fdt_get_max_phandle(const void *fdt)
+{
+	uint32_t max_phandle = 0;
+	int offset;
+
+	for (offset = fdt_next_node(fdt, -1, NULL);;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		uint32_t phandle;
+
+		if (offset == -FDT_ERR_NOTFOUND)
+			return max_phandle;
+
+		if (offset < 0)
+			return (uint32_t)-1;
+
+		phandle = fdt_get_phandle(fdt, offset);
+		if (phandle == (uint32_t)-1)
+			continue;
+
+		if (phandle > max_phandle)
+			max_phandle = phandle;
+	}
+
+	return 0;
+}
+
+int fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size)
+{
+	FDT_CHECK_HEADER(fdt);
+	*address = fdt64_to_cpu(fdt_mem_rsv_(fdt, n)->address);
+	*size = fdt64_to_cpu(fdt_mem_rsv_(fdt, n)->size);
+	return 0;
+}
+
+int fdt_num_mem_rsv(const void *fdt)
+{
+	int i = 0;
+
+	while (fdt64_to_cpu(fdt_mem_rsv_(fdt, i)->size) != 0)
+		i++;
+	return i;
+}
+
+static int _nextprop(const void *fdt, int offset)
+{
+	uint32_t tag;
+	int nextoffset;
+
+	do {
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+
+		switch (tag) {
+		case FDT_END:
+			if (nextoffset >= 0)
+				return -FDT_ERR_BADSTRUCTURE;
+			else
+				return nextoffset;
+
+		case FDT_PROP:
+			return offset;
+		}
+		offset = nextoffset;
+	} while (tag == FDT_NOP);
+
+	return -FDT_ERR_NOTFOUND;
+}
+
+int fdt_subnode_offset_namelen(const void *fdt, int offset,
+			       const char *name, int namelen)
+{
+	int depth;
+
+	FDT_CHECK_HEADER(fdt);
+
+	for (depth = 0;
+	     (offset >= 0) && (depth >= 0);
+	     offset = fdt_next_node(fdt, offset, &depth))
+		if ((depth == 1)
+		    && _fdt_nodename_eq(fdt, offset, name, namelen))
+			return offset;
+
+	if (depth < 0)
+		return -FDT_ERR_NOTFOUND;
+	return offset; /* error */
+}
+
+int fdt_subnode_offset(const void *fdt, int parentoffset,
+		       const char *name)
+{
+	return fdt_subnode_offset_namelen(fdt, parentoffset, name, strlen(name));
+}
+
+/*
+ * Find the next of path separator, note we need to search for both '/' and ':'
+ * and then take the first one so that we do the right thing for e.g.
+ * "foo/bar:option" and "bar:option/otheroption", both of which happen, so
+ * first searching for either ':' or '/' does not work.
+ */
+static const char *fdt_path_next_separator(const char *path, int len)
+{
+	const void *sep1 = memchr(path, '/', len);
+	const void *sep2 = memchr(path, ':', len);
+
+	if (sep1 && sep2)
+		return (sep1 < sep2) ? sep1 : sep2;
+	else if (sep1)
+		return sep1;
+	else
+		return sep2;
+}
+
+int fdt_path_offset_namelen(const void *fdt, const char *path, int namelen)
+{
+	const char *end = path + namelen;
+	const char *p = path;
+	int offset = 0;
+
+	FDT_CHECK_HEADER(fdt);
+
+	/* see if we have an alias */
+	if (*path != '/') {
+		const char *q = fdt_path_next_separator(path, namelen);
+
+		if (!q)
+			q = end;
+
+		p = fdt_get_alias_namelen(fdt, p, q - p);
+		if (!p)
+			return -FDT_ERR_BADPATH;
+		offset = fdt_path_offset(fdt, p);
+
+		p = q;
+	}
+
+	while (*p && (p < end)) {
+		const char *q;
+
+		while (*p == '/')
+			p++;
+
+		if (*p == '\0' || *p == ':')
+			return offset;
+
+		q = fdt_path_next_separator(p, end - p);
+		if (!q)
+			q = end;
+
+		offset = fdt_subnode_offset_namelen(fdt, offset, p, q-p);
+		if (offset < 0)
+			return offset;
+
+		p = q;
+	}
+
+	return offset;
+}
+
+int fdt_path_offset(const void *fdt, const char *path)
+{
+	return fdt_path_offset_namelen(fdt, path, strlen(path));
+}
+
+const char *fdt_get_name(const void *fdt, int nodeoffset, int *len)
+{
+	const struct fdt_node_header *nh = fdt_offset_ptr_(fdt, nodeoffset);
+	int err;
+
+	if (((err = fdt_check_header(fdt)) != 0)
+	    || ((err = fdt_check_node_offset_(fdt, nodeoffset)) < 0))
+			goto fail;
+
+	if (len)
+		*len = strlen(nh->name);
+
+	return nh->name;
+
+ fail:
+	if (len)
+		*len = err;
+	return NULL;
+}
+
+int fdt_first_property_offset(const void *fdt, int nodeoffset)
+{
+	int offset;
+
+	if ((offset = fdt_check_node_offset_(fdt, nodeoffset)) < 0)
+		return offset;
+
+	return _nextprop(fdt, offset);
+}
+
+int fdt_next_property_offset(const void *fdt, int offset)
+{
+	if ((offset = fdt_check_prop_offset_(fdt, offset)) < 0)
+		return offset;
+
+	return _nextprop(fdt, offset);
+}
+
+const struct fdt_property *fdt_get_property_by_offset(const void *fdt,
+						      int offset,
+						      int *lenp)
+{
+	int err;
+	const struct fdt_property *prop;
+
+	if ((err = fdt_check_prop_offset_(fdt, offset)) < 0) {
+		if (lenp)
+			*lenp = err;
+		return NULL;
+	}
+
+	prop = fdt_offset_ptr_(fdt, offset);
+
+	if (lenp)
+		*lenp = fdt32_to_cpu(prop->len);
+
+	return prop;
+}
+
+const struct fdt_property *fdt_get_property_namelen(const void *fdt,
+						    int offset,
+						    const char *name,
+						    int namelen, int *lenp)
+{
+	for (offset = fdt_first_property_offset(fdt, offset);
+	     (offset >= 0);
+	     (offset = fdt_next_property_offset(fdt, offset))) {
+		const struct fdt_property *prop;
+
+		if (!(prop = fdt_get_property_by_offset(fdt, offset, lenp))) {
+			offset = -FDT_ERR_INTERNAL;
+			break;
+		}
+		if (_fdt_string_eq(fdt, fdt32_to_cpu(prop->nameoff),
+				   name, namelen))
+			return prop;
+	}
+
+	if (lenp)
+		*lenp = offset;
+	return NULL;
+}
+
+const struct fdt_property *fdt_get_property(const void *fdt,
+					    int nodeoffset,
+					    const char *name, int *lenp)
+{
+	return fdt_get_property_namelen(fdt, nodeoffset, name,
+					strlen(name), lenp);
+}
+
+const void *fdt_getprop_namelen(const void *fdt, int nodeoffset,
+				const char *name, int namelen, int *lenp)
+{
+	const struct fdt_property *prop;
+
+	prop = fdt_get_property_namelen(fdt, nodeoffset, name, namelen, lenp);
+	if (!prop)
+		return NULL;
+
+	return prop->data;
+}
+
+const void *fdt_getprop_by_offset(const void *fdt, int offset,
+				  const char **namep, int *lenp)
+{
+	const struct fdt_property *prop;
+
+	prop = fdt_get_property_by_offset(fdt, offset, lenp);
+	if (!prop)
+		return NULL;
+	if (namep)
+		*namep = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));
+	return prop->data;
+}
+
+const void *fdt_getprop(const void *fdt, int nodeoffset,
+			const char *name, int *lenp)
+{
+	return fdt_getprop_namelen(fdt, nodeoffset, name, strlen(name), lenp);
+}
+
+uint32_t fdt_get_phandle(const void *fdt, int nodeoffset)
+{
+	const fdt32_t *php;
+	int len;
+
+	/* FIXME: This is a bit sub-optimal, since we potentially scan
+	 * over all the properties twice. */
+	php = fdt_getprop(fdt, nodeoffset, "phandle", &len);
+	if (!php || (len != sizeof(*php))) {
+		php = fdt_getprop(fdt, nodeoffset, "linux,phandle", &len);
+		if (!php || (len != sizeof(*php)))
+			return 0;
+	}
+
+	return fdt32_to_cpu(*php);
+}
+
+const char *fdt_get_alias_namelen(const void *fdt,
+				  const char *name, int namelen)
+{
+	int aliasoffset;
+
+	aliasoffset = fdt_path_offset(fdt, "/aliases");
+	if (aliasoffset < 0)
+		return NULL;
+
+	return fdt_getprop_namelen(fdt, aliasoffset, name, namelen, NULL);
+}
+
+const char *fdt_get_alias(const void *fdt, const char *name)
+{
+	return fdt_get_alias_namelen(fdt, name, strlen(name));
+}
+
+int fdt_get_path(const void *fdt, int nodeoffset, char *buf, int buflen)
+{
+	int pdepth = 0, p = 0;
+	int offset, depth, namelen;
+	const char *name;
+
+	FDT_CHECK_HEADER(fdt);
+
+	if (buflen < 2)
+		return -FDT_ERR_NOSPACE;
+
+	for (offset = 0, depth = 0;
+	     (offset >= 0) && (offset <= nodeoffset);
+	     offset = fdt_next_node(fdt, offset, &depth)) {
+		while (pdepth > depth) {
+			do {
+				p--;
+			} while (buf[p-1] != '/');
+			pdepth--;
+		}
+
+		if (pdepth >= depth) {
+			name = fdt_get_name(fdt, offset, &namelen);
+			if (!name)
+				return namelen;
+			if ((p + namelen + 1) <= buflen) {
+				memcpy(buf + p, name, namelen);
+				p += namelen;
+				buf[p++] = '/';
+				pdepth++;
+			}
+		}
+
+		if (offset == nodeoffset) {
+			if (pdepth < (depth + 1))
+				return -FDT_ERR_NOSPACE;
+
+			if (p > 1) /* special case so that root path is "/", not "" */
+				p--;
+			buf[p] = '\0';
+			return 0;
+		}
+	}
+
+	if ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))
+		return -FDT_ERR_BADOFFSET;
+	else if (offset == -FDT_ERR_BADOFFSET)
+		return -FDT_ERR_BADSTRUCTURE;
+
+	return offset; /* error from fdt_next_node() */
+}
+
+int fdt_supernode_atdepth_offset(const void *fdt, int nodeoffset,
+				 int supernodedepth, int *nodedepth)
+{
+	int offset, depth;
+	int supernodeoffset = -FDT_ERR_INTERNAL;
+
+	FDT_CHECK_HEADER(fdt);
+
+	if (supernodedepth < 0)
+		return -FDT_ERR_NOTFOUND;
+
+	for (offset = 0, depth = 0;
+	     (offset >= 0) && (offset <= nodeoffset);
+	     offset = fdt_next_node(fdt, offset, &depth)) {
+		if (depth == supernodedepth)
+			supernodeoffset = offset;
+
+		if (offset == nodeoffset) {
+			if (nodedepth)
+				*nodedepth = depth;
+
+			if (supernodedepth > depth)
+				return -FDT_ERR_NOTFOUND;
+			else
+				return supernodeoffset;
+		}
+	}
+
+	if ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))
+		return -FDT_ERR_BADOFFSET;
+	else if (offset == -FDT_ERR_BADOFFSET)
+		return -FDT_ERR_BADSTRUCTURE;
+
+	return offset; /* error from fdt_next_node() */
+}
+
+int fdt_node_depth(const void *fdt, int nodeoffset)
+{
+	int nodedepth;
+	int err;
+
+	err = fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, &nodedepth);
+	if (err)
+		return (err < 0) ? err : -FDT_ERR_INTERNAL;
+	return nodedepth;
+}
+
+int fdt_parent_offset(const void *fdt, int nodeoffset)
+{
+	int nodedepth = fdt_node_depth(fdt, nodeoffset);
+
+	if (nodedepth < 0)
+		return nodedepth;
+	return fdt_supernode_atdepth_offset(fdt, nodeoffset,
+					    nodedepth - 1, NULL);
+}
+
+int fdt_node_offset_by_prop_value(const void *fdt, int startoffset,
+				  const char *propname,
+				  const void *propval, int proplen)
+{
+	int offset;
+	const void *val;
+	int len;
+
+	FDT_CHECK_HEADER(fdt);
+
+	/* FIXME: The algorithm here is pretty horrible: we scan each
+	 * property of a node in fdt_getprop(), then if that didn't
+	 * find what we want, we scan over them again making our way
+	 * to the next node.  Still it's the easiest to implement
+	 * approach; performance can come later. */
+	for (offset = fdt_next_node(fdt, startoffset, NULL);
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		val = fdt_getprop(fdt, offset, propname, &len);
+		if (val && (len == proplen)
+		    && (memcmp(val, propval, len) == 0))
+			return offset;
+	}
+
+	return offset; /* error from fdt_next_node() */
+}
+
+int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle)
+{
+	int offset;
+
+	if ((phandle == 0) || (phandle == -1))
+		return -FDT_ERR_BADPHANDLE;
+
+	FDT_CHECK_HEADER(fdt);
+
+	/* FIXME: The algorithm here is pretty horrible: we
+	 * potentially scan each property of a node in
+	 * fdt_get_phandle(), then if that didn't find what
+	 * we want, we scan over them again making our way to the next
+	 * node.  Still it's the easiest to implement approach;
+	 * performance can come later. */
+	for (offset = fdt_next_node(fdt, -1, NULL);
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		if (fdt_get_phandle(fdt, offset) == phandle)
+			return offset;
+	}
+
+	return offset; /* error from fdt_next_node() */
+}
+
+int fdt_stringlist_contains(const char *strlist, int listlen, const char *str)
+{
+	int len = strlen(str);
+	const char *p;
+
+	while (listlen >= len) {
+		if (memcmp(str, strlist, len+1) == 0)
+			return 1;
+		p = memchr(strlist, '\0', listlen);
+		if (!p)
+			return 0; /* malformed strlist.. */
+		listlen -= (p-strlist) + 1;
+		strlist = p + 1;
+	}
+	return 0;
+}
+
+int fdt_stringlist_count(const void *fdt, int nodeoffset, const char *property)
+{
+	const char *list, *end;
+	int length, count = 0;
+
+	list = fdt_getprop(fdt, nodeoffset, property, &length);
+	if (!list)
+		return length;
+
+	end = list + length;
+
+	while (list < end) {
+		length = strnlen(list, end - list) + 1;
+
+		/* Abort if the last string isn't properly NUL-terminated. */
+		if (list + length > end)
+			return -FDT_ERR_BADVALUE;
+
+		list += length;
+		count++;
+	}
+
+	return count;
+}
+
+int fdt_stringlist_search(const void *fdt, int nodeoffset, const char *property,
+			  const char *string)
+{
+	int length, len, idx = 0;
+	const char *list, *end;
+
+	list = fdt_getprop(fdt, nodeoffset, property, &length);
+	if (!list)
+		return length;
+
+	len = strlen(string) + 1;
+	end = list + length;
+
+	while (list < end) {
+		length = strnlen(list, end - list) + 1;
+
+		/* Abort if the last string isn't properly NUL-terminated. */
+		if (list + length > end)
+			return -FDT_ERR_BADVALUE;
+
+		if (length == len && memcmp(list, string, length) == 0)
+			return idx;
+
+		list += length;
+		idx++;
+	}
+
+	return -FDT_ERR_NOTFOUND;
+}
+
+const char *fdt_stringlist_get(const void *fdt, int nodeoffset,
+			       const char *property, int idx,
+			       int *lenp)
+{
+	const char *list, *end;
+	int length;
+
+	list = fdt_getprop(fdt, nodeoffset, property, &length);
+	if (!list) {
+		if (lenp)
+			*lenp = length;
+
+		return NULL;
+	}
+
+	end = list + length;
+
+	while (list < end) {
+		length = strnlen(list, end - list) + 1;
+
+		/* Abort if the last string isn't properly NUL-terminated. */
+		if (list + length > end) {
+			if (lenp)
+				*lenp = -FDT_ERR_BADVALUE;
+
+			return NULL;
+		}
+
+		if (idx == 0) {
+			if (lenp)
+				*lenp = length - 1;
+
+			return list;
+		}
+
+		list += length;
+		idx--;
+	}
+
+	if (lenp)
+		*lenp = -FDT_ERR_NOTFOUND;
+
+	return NULL;
+}
+
+int fdt_node_check_compatible(const void *fdt, int nodeoffset,
+			      const char *compatible)
+{
+	const void *prop;
+	int len;
+
+	prop = fdt_getprop(fdt, nodeoffset, "compatible", &len);
+	if (!prop)
+		return len;
+
+	return !fdt_stringlist_contains(prop, len, compatible);
+}
+
+int fdt_node_offset_by_compatible(const void *fdt, int startoffset,
+				  const char *compatible)
+{
+	int offset, err;
+
+	FDT_CHECK_HEADER(fdt);
+
+	/* FIXME: The algorithm here is pretty horrible: we scan each
+	 * property of a node in fdt_node_check_compatible(), then if
+	 * that didn't find what we want, we scan over them again
+	 * making our way to the next node.  Still it's the easiest to
+	 * implement approach; performance can come later. */
+	for (offset = fdt_next_node(fdt, startoffset, NULL);
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		err = fdt_node_check_compatible(fdt, offset, compatible);
+		if ((err < 0) && (err != -FDT_ERR_NOTFOUND))
+			return err;
+		else if (err == 0)
+			return offset;
+	}
+
+	return offset; /* error from fdt_next_node() */
+}
diff -urN u-boot-1.1.6/common/fdt/fdt_rw.c u-boot-1.1.6_fdt/common/fdt/fdt_rw.c
--- u-boot-1.1.6/common/fdt/fdt_rw.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt_rw.c	2018-10-22 15:54:19.589640154 +0800
@@ -0,0 +1,505 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+static int fdt_blocks_misordered_(const void *fdt,
+				  int mem_rsv_size, int struct_size)
+{
+	return (fdt_off_mem_rsvmap(fdt) < FDT_ALIGN(sizeof(struct fdt_header), 8))
+		|| (fdt_off_dt_struct(fdt) <
+		    (fdt_off_mem_rsvmap(fdt) + mem_rsv_size))
+		|| (fdt_off_dt_strings(fdt) <
+		    (fdt_off_dt_struct(fdt) + struct_size))
+		|| (fdt_totalsize(fdt) <
+		    (fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));
+}
+
+static int fdt_rw_check_header_(void *fdt)
+{
+	FDT_CHECK_HEADER(fdt);
+
+	if (fdt_version(fdt) < 17)
+		return -FDT_ERR_BADVERSION;
+	if (fdt_blocks_misordered_(fdt, sizeof(struct fdt_reserve_entry),
+				   fdt_size_dt_struct(fdt)))
+		return -FDT_ERR_BADLAYOUT;
+	if (fdt_version(fdt) > 17)
+		fdt_set_version(fdt, 17);
+
+	return 0;
+}
+
+#define FDT_RW_CHECK_HEADER(fdt) \
+	{ \
+		int err_; \
+		if ((err_ = fdt_rw_check_header_(fdt)) != 0) \
+			return err_; \
+	}
+
+static inline int fdt_data_size_(void *fdt)
+{
+	return fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
+}
+
+static int fdt_splice_(void *fdt, void *splicepoint, int oldlen, int newlen)
+{
+	char *p = splicepoint;
+	char *end = (char *)fdt + fdt_data_size_(fdt);
+
+	if (((p + oldlen) < p) || ((p + oldlen) > end))
+		return -FDT_ERR_BADOFFSET;
+	if ((p < (char *)fdt) || ((end - oldlen + newlen) < (char *)fdt))
+		return -FDT_ERR_BADOFFSET;
+	if ((end - oldlen + newlen) > ((char *)fdt + fdt_totalsize(fdt)))
+		return -FDT_ERR_NOSPACE;
+	memmove(p + newlen, p + oldlen, end - p - oldlen);
+	return 0;
+}
+
+static int fdt_splice_mem_rsv_(void *fdt, struct fdt_reserve_entry *p,
+			       int oldn, int newn)
+{
+	int delta = (newn - oldn) * sizeof(*p);
+	int err;
+	err = fdt_splice_(fdt, p, oldn * sizeof(*p), newn * sizeof(*p));
+	if (err)
+		return err;
+	fdt_set_off_dt_struct(fdt, fdt_off_dt_struct(fdt) + delta);
+	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
+	return 0;
+}
+
+static int fdt_splice_struct_(void *fdt, void *p,
+			      int oldlen, int newlen)
+{
+	int delta = newlen - oldlen;
+	int err;
+
+	if ((err = fdt_splice_(fdt, p, oldlen, newlen)))
+		return err;
+
+	fdt_set_size_dt_struct(fdt, fdt_size_dt_struct(fdt) + delta);
+	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
+	return 0;
+}
+
+static int fdt_splice_string_(void *fdt, int newlen)
+{
+	void *p = (char *)fdt
+		+ fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
+	int err;
+
+	if ((err = fdt_splice_(fdt, p, 0, newlen)))
+		return err;
+
+	fdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) + newlen);
+	return 0;
+}
+
+static int fdt_find_add_string_(void *fdt, const char *s)
+{
+	char *strtab = (char *)fdt + fdt_off_dt_strings(fdt);
+	const char *p;
+	char *new;
+	int len = strlen(s) + 1;
+	int err;
+
+	p = fdt_find_string_(strtab, fdt_size_dt_strings(fdt), s);
+	if (p)
+		/* found it */
+		return (p - strtab);
+
+	new = strtab + fdt_size_dt_strings(fdt);
+	err = fdt_splice_string_(fdt, len);
+	if (err)
+		return err;
+
+	memcpy(new, s, len);
+	return (new - strtab);
+}
+
+int fdt_add_mem_rsv(void *fdt, uint64_t address, uint64_t size)
+{
+	struct fdt_reserve_entry *re;
+	int err;
+
+	FDT_RW_CHECK_HEADER(fdt);
+
+	re = fdt_mem_rsv_w_(fdt, fdt_num_mem_rsv(fdt));
+	err = fdt_splice_mem_rsv_(fdt, re, 0, 1);
+	if (err)
+		return err;
+
+	re->address = cpu_to_fdt64(address);
+	re->size = cpu_to_fdt64(size);
+	return 0;
+}
+
+int fdt_del_mem_rsv(void *fdt, int n)
+{
+	struct fdt_reserve_entry *re = fdt_mem_rsv_w_(fdt, n);
+
+	FDT_RW_CHECK_HEADER(fdt);
+
+	if (n >= fdt_num_mem_rsv(fdt))
+		return -FDT_ERR_NOTFOUND;
+
+	return fdt_splice_mem_rsv_(fdt, re, 1, 0);
+}
+
+static int fdt_resize_property_(void *fdt, int nodeoffset, const char *name,
+				int len, struct fdt_property **prop)
+{
+	int oldlen;
+	int err;
+
+	*prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
+	if (!*prop)
+		return oldlen;
+
+	if ((err = fdt_splice_struct_(fdt, (*prop)->data, FDT_TAGALIGN(oldlen),
+				      FDT_TAGALIGN(len))))
+		return err;
+
+	(*prop)->len = cpu_to_fdt32(len);
+	return 0;
+}
+
+static int fdt_add_property_(void *fdt, int nodeoffset, const char *name,
+			     int len, struct fdt_property **prop)
+{
+	int proplen;
+	int nextoffset;
+	int namestroff;
+	int err;
+
+	if ((nextoffset = fdt_check_node_offset_(fdt, nodeoffset)) < 0)
+		return nextoffset;
+
+	namestroff = fdt_find_add_string_(fdt, name);
+	if (namestroff < 0)
+		return namestroff;
+
+	*prop = fdt_offset_ptr_w_(fdt, nextoffset);
+	proplen = sizeof(**prop) + FDT_TAGALIGN(len);
+
+	err = fdt_splice_struct_(fdt, *prop, 0, proplen);
+	if (err)
+		return err;
+
+	(*prop)->tag = cpu_to_fdt32(FDT_PROP);
+	(*prop)->nameoff = cpu_to_fdt32(namestroff);
+	(*prop)->len = cpu_to_fdt32(len);
+	return 0;
+}
+
+int fdt_set_name(void *fdt, int nodeoffset, const char *name)
+{
+	char *namep;
+	int oldlen, newlen;
+	int err;
+
+	FDT_RW_CHECK_HEADER(fdt);
+
+	namep = (char *)(uintptr_t)fdt_get_name(fdt, nodeoffset, &oldlen);
+	if (!namep)
+		return oldlen;
+
+	newlen = strlen(name);
+
+	err = fdt_splice_struct_(fdt, namep, FDT_TAGALIGN(oldlen+1),
+				 FDT_TAGALIGN(newlen+1));
+	if (err)
+		return err;
+
+	memcpy(namep, name, newlen+1);
+	return 0;
+}
+
+int fdt_setprop_placeholder(void *fdt, int nodeoffset, const char *name,
+			    int len, void **prop_data)
+{
+	struct fdt_property *prop;
+	int err;
+
+	FDT_RW_CHECK_HEADER(fdt);
+
+	err = fdt_resize_property_(fdt, nodeoffset, name, len, &prop);
+	if (err == -FDT_ERR_NOTFOUND)
+		err = fdt_add_property_(fdt, nodeoffset, name, len, &prop);
+	if (err)
+		return err;
+
+	*prop_data = prop->data;
+	return 0;
+}
+
+int fdt_setprop(void *fdt, int nodeoffset, const char *name,
+		const void *val, int len)
+{
+	void *prop_data;
+	int err;
+
+	err = fdt_setprop_placeholder(fdt, nodeoffset, name, len, &prop_data);
+	if (err)
+		return err;
+
+	if (len)
+		memcpy(prop_data, val, len);
+	return 0;
+}
+
+int fdt_appendprop(void *fdt, int nodeoffset, const char *name,
+		   const void *val, int len)
+{
+	struct fdt_property *prop;
+	int err, oldlen, newlen;
+
+	FDT_RW_CHECK_HEADER(fdt);
+
+	prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
+	if (prop) {
+		newlen = len + oldlen;
+		err = fdt_splice_struct_(fdt, prop->data,
+					 FDT_TAGALIGN(oldlen),
+					 FDT_TAGALIGN(newlen));
+		if (err)
+			return err;
+		prop->len = cpu_to_fdt32(newlen);
+		memcpy(prop->data + oldlen, val, len);
+	} else {
+		err = fdt_add_property_(fdt, nodeoffset, name, len, &prop);
+		if (err)
+			return err;
+		memcpy(prop->data, val, len);
+	}
+	return 0;
+}
+
+int fdt_delprop(void *fdt, int nodeoffset, const char *name)
+{
+	struct fdt_property *prop;
+	int len, proplen;
+
+	FDT_RW_CHECK_HEADER(fdt);
+
+	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
+	if (!prop)
+		return len;
+
+	proplen = sizeof(*prop) + FDT_TAGALIGN(len);
+	return fdt_splice_struct_(fdt, prop, proplen, 0);
+}
+
+int fdt_add_subnode_namelen(void *fdt, int parentoffset,
+			    const char *name, int namelen)
+{
+	struct fdt_node_header *nh;
+	int offset, nextoffset;
+	int nodelen;
+	int err;
+	uint32_t tag;
+	fdt32_t *endtag;
+
+	FDT_RW_CHECK_HEADER(fdt);
+
+	offset = fdt_subnode_offset_namelen(fdt, parentoffset, name, namelen);
+	if (offset >= 0)
+		return -FDT_ERR_EXISTS;
+	else if (offset != -FDT_ERR_NOTFOUND)
+		return offset;
+
+	/* Try to place the new node after the parent's properties */
+	fdt_next_tag(fdt, parentoffset, &nextoffset); /* skip the BEGIN_NODE */
+	do {
+		offset = nextoffset;
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+	} while ((tag == FDT_PROP) || (tag == FDT_NOP));
+
+	nh = fdt_offset_ptr_w_(fdt, offset);
+	nodelen = sizeof(*nh) + FDT_TAGALIGN(namelen+1) + FDT_TAGSIZE;
+
+	err = fdt_splice_struct_(fdt, nh, 0, nodelen);
+	if (err)
+		return err;
+
+	nh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);
+	memset(nh->name, 0, FDT_TAGALIGN(namelen+1));
+	memcpy(nh->name, name, namelen);
+	endtag = (fdt32_t *)((char *)nh + nodelen - FDT_TAGSIZE);
+	*endtag = cpu_to_fdt32(FDT_END_NODE);
+
+	return offset;
+}
+
+int fdt_add_subnode(void *fdt, int parentoffset, const char *name)
+{
+	return fdt_add_subnode_namelen(fdt, parentoffset, name, strlen(name));
+}
+
+int fdt_del_node(void *fdt, int nodeoffset)
+{
+	int endoffset;
+
+	FDT_RW_CHECK_HEADER(fdt);
+
+	endoffset = fdt_node_end_offset_(fdt, nodeoffset);
+	if (endoffset < 0)
+		return endoffset;
+
+	return fdt_splice_struct_(fdt, fdt_offset_ptr_w_(fdt, nodeoffset),
+				  endoffset - nodeoffset, 0);
+}
+
+static void fdt_packblocks_(const char *old, char *new,
+			    int mem_rsv_size, int struct_size)
+{
+	int mem_rsv_off, struct_off, strings_off;
+
+	mem_rsv_off = FDT_ALIGN(sizeof(struct fdt_header), 8);
+	struct_off = mem_rsv_off + mem_rsv_size;
+	strings_off = struct_off + struct_size;
+
+	memmove(new + mem_rsv_off, old + fdt_off_mem_rsvmap(old), mem_rsv_size);
+	fdt_set_off_mem_rsvmap(new, mem_rsv_off);
+
+	memmove(new + struct_off, old + fdt_off_dt_struct(old), struct_size);
+	fdt_set_off_dt_struct(new, struct_off);
+	fdt_set_size_dt_struct(new, struct_size);
+
+	memmove(new + strings_off, old + fdt_off_dt_strings(old),
+		fdt_size_dt_strings(old));
+	fdt_set_off_dt_strings(new, strings_off);
+	fdt_set_size_dt_strings(new, fdt_size_dt_strings(old));
+}
+
+int fdt_open_into(const void *fdt, void *buf, int bufsize)
+{
+	int err;
+	int mem_rsv_size, struct_size;
+	int newsize;
+	const char *fdtstart = fdt;
+	const char *fdtend = fdtstart + fdt_totalsize(fdt);
+	char *tmp;
+
+	FDT_CHECK_HEADER(fdt);
+
+	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
+		* sizeof(struct fdt_reserve_entry);
+
+	if (fdt_version(fdt) >= 17) {
+		struct_size = fdt_size_dt_struct(fdt);
+	} else {
+		struct_size = 0;
+		while (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)
+			;
+		if (struct_size < 0)
+			return struct_size;
+	}
+
+	if (!fdt_blocks_misordered_(fdt, mem_rsv_size, struct_size)) {
+		/* no further work necessary */
+		err = fdt_move(fdt, buf, bufsize);
+		if (err)
+			return err;
+		fdt_set_version(buf, 17);
+		fdt_set_size_dt_struct(buf, struct_size);
+		fdt_set_totalsize(buf, bufsize);
+		return 0;
+	}
+
+	/* Need to reorder */
+	newsize = FDT_ALIGN(sizeof(struct fdt_header), 8) + mem_rsv_size
+		+ struct_size + fdt_size_dt_strings(fdt);
+
+	if (bufsize < newsize)
+		return -FDT_ERR_NOSPACE;
+
+	/* First attempt to build converted tree at beginning of buffer */
+	tmp = buf;
+	/* But if that overlaps with the old tree... */
+	if (((tmp + newsize) > fdtstart) && (tmp < fdtend)) {
+		/* Try right after the old tree instead */
+		tmp = (char *)(uintptr_t)fdtend;
+		if ((tmp + newsize) > ((char *)buf + bufsize))
+			return -FDT_ERR_NOSPACE;
+	}
+
+	fdt_packblocks_(fdt, tmp, mem_rsv_size, struct_size);
+	memmove(buf, tmp, newsize);
+
+	fdt_set_magic(buf, FDT_MAGIC);
+	fdt_set_totalsize(buf, bufsize);
+	fdt_set_version(buf, 17);
+	fdt_set_last_comp_version(buf, 16);
+	fdt_set_boot_cpuid_phys(buf, fdt_boot_cpuid_phys(fdt));
+
+	return 0;
+}
+
+int fdt_pack(void *fdt)
+{
+	int mem_rsv_size;
+
+	FDT_RW_CHECK_HEADER(fdt);
+
+	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
+		* sizeof(struct fdt_reserve_entry);
+	fdt_packblocks_(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt));
+	fdt_set_totalsize(fdt, fdt_data_size_(fdt));
+
+	return 0;
+}
diff -urN u-boot-1.1.6/common/fdt/fdt_strerror.c u-boot-1.1.6_fdt/common/fdt/fdt_strerror.c
--- u-boot-1.1.6/common/fdt/fdt_strerror.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt_strerror.c	2018-10-22 15:54:19.601640154 +0800
@@ -0,0 +1,102 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+struct fdt_errtabent {
+	const char *str;
+};
+
+#define FDT_ERRTABENT(val) \
+	[(val)] = { .str = #val, }
+
+static struct fdt_errtabent fdt_errtable[] = {
+	FDT_ERRTABENT(FDT_ERR_NOTFOUND),
+	FDT_ERRTABENT(FDT_ERR_EXISTS),
+	FDT_ERRTABENT(FDT_ERR_NOSPACE),
+
+	FDT_ERRTABENT(FDT_ERR_BADOFFSET),
+	FDT_ERRTABENT(FDT_ERR_BADPATH),
+	FDT_ERRTABENT(FDT_ERR_BADPHANDLE),
+	FDT_ERRTABENT(FDT_ERR_BADSTATE),
+
+	FDT_ERRTABENT(FDT_ERR_TRUNCATED),
+	FDT_ERRTABENT(FDT_ERR_BADMAGIC),
+	FDT_ERRTABENT(FDT_ERR_BADVERSION),
+	FDT_ERRTABENT(FDT_ERR_BADSTRUCTURE),
+	FDT_ERRTABENT(FDT_ERR_BADLAYOUT),
+	FDT_ERRTABENT(FDT_ERR_INTERNAL),
+	FDT_ERRTABENT(FDT_ERR_BADNCELLS),
+	FDT_ERRTABENT(FDT_ERR_BADVALUE),
+	FDT_ERRTABENT(FDT_ERR_BADOVERLAY),
+	FDT_ERRTABENT(FDT_ERR_NOPHANDLES),
+};
+#define FDT_ERRTABSIZE	(sizeof(fdt_errtable) / sizeof(fdt_errtable[0]))
+
+const char *fdt_strerror(int errval)
+{
+	if (errval > 0)
+		return "<valid offset/length>";
+	else if (errval == 0)
+		return "<no error>";
+	else if (errval > -FDT_ERRTABSIZE) {
+		const char *s = fdt_errtable[-errval].str;
+
+		if (s)
+			return s;
+	}
+
+	return "<unknown error>";
+}
diff -urN u-boot-1.1.6/common/fdt/fdt_support.c u-boot-1.1.6_fdt/common/fdt/fdt_support.c
--- u-boot-1.1.6/common/fdt/fdt_support.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt_support.c	2018-10-22 17:11:12.129555056 +0800
@@ -0,0 +1,1762 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2007
+ * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
+ *
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <stdio_dev.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <asm/global_data.h>
+#include <linux/libfdt.h>
+#include <fdt_support.h>
+#include <exports.h>
+#include <fdtdec.h>
+
+#define ARP_HLEN 6
+#define ARRAY_SIZE(x)		(sizeof(x) / sizeof((x)[0]))
+
+#define env_get getenv
+#define env_set setenv
+#define ALIGN(x, a)	(((x) + (a) - 1) & ~((a) - 1))
+
+/**
+ * fdt_getprop_u32_default_node - Return a node's property or a default
+ *
+ * @fdt: ptr to device tree
+ * @off: offset of node
+ * @cell: cell offset in property
+ * @prop: property name
+ * @dflt: default value if the property isn't found
+ *
+ * Convenience function to return a node's property or a default value if
+ * the property doesn't exist.
+ */
+u32 fdt_getprop_u32_default_node(const void *fdt, int off, int cell,
+				const char *prop, const u32 dflt)
+{
+	const fdt32_t *val;
+	int len;
+
+	val = fdt_getprop(fdt, off, prop, &len);
+
+	/* Check if property exists */
+	if (!val)
+		return dflt;
+
+	/* Check if property is long enough */
+	if (len < ((cell + 1) * sizeof(uint32_t)))
+		return dflt;
+
+	return fdt32_to_cpu(*val);
+}
+
+/**
+ * fdt_getprop_u32_default - Find a node and return it's property or a default
+ *
+ * @fdt: ptr to device tree
+ * @path: path of node
+ * @prop: property name
+ * @dflt: default value if the property isn't found
+ *
+ * Convenience function to find a node and return it's property or a
+ * default value if it doesn't exist.
+ */
+u32 fdt_getprop_u32_default(const void *fdt, const char *path,
+				const char *prop, const u32 dflt)
+{
+	int off;
+
+	off = fdt_path_offset(fdt, path);
+	if (off < 0)
+		return dflt;
+
+	return fdt_getprop_u32_default_node(fdt, off, 0, prop, dflt);
+}
+
+/**
+ * fdt_find_and_setprop: Find a node and set it's property
+ *
+ * @fdt: ptr to device tree
+ * @node: path of node
+ * @prop: property name
+ * @val: ptr to new value
+ * @len: length of new property value
+ * @create: flag to create the property if it doesn't exist
+ *
+ * Convenience function to directly set a property given the path to the node.
+ */
+int fdt_find_and_setprop(void *fdt, const char *node, const char *prop,
+			 const void *val, int len, int create)
+{
+	int nodeoff = fdt_path_offset(fdt, node);
+
+	if (nodeoff < 0)
+		return nodeoff;
+
+	if ((!create) && (fdt_get_property(fdt, nodeoff, prop, NULL) == NULL))
+		return 0; /* create flag not set; so exit quietly */
+
+	return fdt_setprop(fdt, nodeoff, prop, val, len);
+}
+
+/**
+ * fdt_find_or_add_subnode() - find or possibly add a subnode of a given node
+ *
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ *
+ * fdt_subnode_offset() finds a subnode of the node with a given name.
+ * If the subnode does not exist, it will be created.
+ */
+int fdt_find_or_add_subnode(void *fdt, int parentoffset, const char *name)
+{
+	int offset;
+
+	offset = fdt_subnode_offset(fdt, parentoffset, name);
+
+	if (offset == -FDT_ERR_NOTFOUND)
+		offset = fdt_add_subnode(fdt, parentoffset, name);
+
+	if (offset < 0)
+		printf("%s: %s: %s\n", __func__, name, fdt_strerror(offset));
+
+	return offset;
+}
+
+/* rename to CONFIG_OF_STDOUT_PATH ? */
+#if defined(OF_STDOUT_PATH)
+static int fdt_fixup_stdout(void *fdt, int chosenoff)
+{
+	return fdt_setprop(fdt, chosenoff, "linux,stdout-path",
+			      OF_STDOUT_PATH, strlen(OF_STDOUT_PATH) + 1);
+}
+#elif defined(CONFIG_OF_STDOUT_VIA_ALIAS) && defined(CONFIG_CONS_INDEX)
+static int fdt_fixup_stdout(void *fdt, int chosenoff)
+{
+	int err;
+	int aliasoff;
+	char sername[9] = { 0 };
+	const void *path;
+	int len;
+	char tmp[256]; /* long enough */
+
+	sprintf(sername, "serial%d", CONFIG_CONS_INDEX - 1);
+
+	aliasoff = fdt_path_offset(fdt, "/aliases");
+	if (aliasoff < 0) {
+		err = aliasoff;
+		goto noalias;
+	}
+
+	path = fdt_getprop(fdt, aliasoff, sername, &len);
+	if (!path) {
+		err = len;
+		goto noalias;
+	}
+
+	/* fdt_setprop may break "path" so we copy it to tmp buffer */
+	memcpy(tmp, path, len);
+
+	err = fdt_setprop(fdt, chosenoff, "linux,stdout-path", tmp, len);
+	if (err < 0)
+		printf("WARNING: could not set linux,stdout-path %s.\n",
+		       fdt_strerror(err));
+
+	return err;
+
+noalias:
+	printf("WARNING: %s: could not read %s alias: %s\n",
+	       __func__, sername, fdt_strerror(err));
+
+	return 0;
+}
+#else
+static int fdt_fixup_stdout(void *fdt, int chosenoff)
+{
+	return 0;
+}
+#endif
+
+static inline int fdt_setprop_uxx(void *fdt, int nodeoffset, const char *name,
+				  uint64_t val, int is_u64)
+{
+	if (is_u64)
+		return fdt_setprop_u64(fdt, nodeoffset, name, val);
+	else
+		return fdt_setprop_u32(fdt, nodeoffset, name, (uint32_t)val);
+}
+
+int fdt_root(void *fdt)
+{
+	char *serial;
+	int err;
+
+	err = fdt_check_header(fdt);
+	if (err < 0) {
+		printf("fdt_root: %s\n", fdt_strerror(err));
+		return err;
+	}
+
+	serial = env_get("serial#");
+	if (serial) {
+		err = fdt_setprop(fdt, 0, "serial-number", serial,
+				  strlen(serial) + 1);
+
+		if (err < 0) {
+			printf("WARNING: could not set serial-number %s.\n",
+			       fdt_strerror(err));
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+
+int fdt_initrd(void *fdt, ulong initrd_start, ulong initrd_end)
+{
+	int   nodeoffset;
+	int   err, j, total;
+	int is_u64;
+	uint64_t addr, size;
+
+	/* just return if the size of initrd is zero */
+	if (initrd_start == initrd_end)
+		return 0;
+
+	/* find or create "/chosen" node. */
+	nodeoffset = fdt_find_or_add_subnode(fdt, 0, "chosen");
+	if (nodeoffset < 0)
+		return nodeoffset;
+
+	total = fdt_num_mem_rsv(fdt);
+
+	/*
+	 * Look for an existing entry and update it.  If we don't find
+	 * the entry, we will j be the next available slot.
+	 */
+	for (j = 0; j < total; j++) {
+		err = fdt_get_mem_rsv(fdt, j, &addr, &size);
+		if (addr == initrd_start) {
+			fdt_del_mem_rsv(fdt, j);
+			break;
+		}
+	}
+
+	err = fdt_add_mem_rsv(fdt, initrd_start, initrd_end - initrd_start);
+	if (err < 0) {
+		printf("fdt_initrd: %s\n", fdt_strerror(err));
+		return err;
+	}
+
+	is_u64 = (fdt_address_cells(fdt, 0) == 2);
+
+	err = fdt_setprop_uxx(fdt, nodeoffset, "linux,initrd-start",
+			      (uint64_t)initrd_start, is_u64);
+
+	if (err < 0) {
+		printf("WARNING: could not set linux,initrd-start %s.\n",
+		       fdt_strerror(err));
+		return err;
+	}
+
+	err = fdt_setprop_uxx(fdt, nodeoffset, "linux,initrd-end",
+			      (uint64_t)initrd_end, is_u64);
+
+	if (err < 0) {
+		printf("WARNING: could not set linux,initrd-end %s.\n",
+		       fdt_strerror(err));
+
+		return err;
+	}
+
+	return 0;
+}
+
+int fdt_chosen(void *fdt)
+{
+	int   nodeoffset;
+	int   err;
+	char  *str;		/* used to set string properties */
+
+	err = fdt_check_header(fdt);
+	if (err < 0) {
+		printf("fdt_chosen: %s\n", fdt_strerror(err));
+		return err;
+	}
+
+	/* find or create "/chosen" node. */
+	nodeoffset = fdt_find_or_add_subnode(fdt, 0, "chosen");
+	if (nodeoffset < 0)
+		return nodeoffset;
+
+	str = getenv("bootargs");
+	if (str) {
+		err = fdt_setprop(fdt, nodeoffset, "bootargs", str,
+				  strlen(str) + 1);
+		if (err < 0) {
+			printf("WARNING: could not set bootargs %s.\n",
+			       fdt_strerror(err));
+			return err;
+		}
+	}
+
+	return fdt_fixup_stdout(fdt, nodeoffset);
+}
+
+void do_fixup_by_path(void *fdt, const char *path, const char *prop,
+		      const void *val, int len, int create)
+{
+#if defined(DEBUG)
+	int i;
+	debug("Updating property '%s/%s' = ", path, prop);
+	for (i = 0; i < len; i++)
+		debug(" %.2x", *(u8*)(val+i));
+	debug("\n");
+#endif
+	int rc = fdt_find_and_setprop(fdt, path, prop, val, len, create);
+	if (rc)
+		printf("Unable to update property %s:%s, err=%s\n",
+			path, prop, fdt_strerror(rc));
+}
+
+void do_fixup_by_path_u32(void *fdt, const char *path, const char *prop,
+			  u32 val, int create)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	do_fixup_by_path(fdt, path, prop, &tmp, sizeof(tmp), create);
+}
+
+void do_fixup_by_prop(void *fdt,
+		      const char *pname, const void *pval, int plen,
+		      const char *prop, const void *val, int len,
+		      int create)
+{
+	int off;
+#if defined(DEBUG)
+	int i;
+	debug("Updating property '%s' = ", prop);
+	for (i = 0; i < len; i++)
+		debug(" %.2x", *(u8*)(val+i));
+	debug("\n");
+#endif
+	off = fdt_node_offset_by_prop_value(fdt, -1, pname, pval, plen);
+	while (off != -FDT_ERR_NOTFOUND) {
+		if (create || (fdt_get_property(fdt, off, prop, NULL) != NULL))
+			fdt_setprop(fdt, off, prop, val, len);
+		off = fdt_node_offset_by_prop_value(fdt, off, pname, pval, plen);
+	}
+}
+
+void do_fixup_by_prop_u32(void *fdt,
+			  const char *pname, const void *pval, int plen,
+			  const char *prop, u32 val, int create)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	do_fixup_by_prop(fdt, pname, pval, plen, prop, &tmp, 4, create);
+}
+
+void do_fixup_by_compat(void *fdt, const char *compat,
+			const char *prop, const void *val, int len, int create)
+{
+	int off = -1;
+#if defined(DEBUG)
+	int i;
+	debug("Updating property '%s' = ", prop);
+	for (i = 0; i < len; i++)
+		debug(" %.2x", *(u8*)(val+i));
+	debug("\n");
+#endif
+	off = fdt_node_offset_by_compatible(fdt, -1, compat);
+	while (off != -FDT_ERR_NOTFOUND) {
+		if (create || (fdt_get_property(fdt, off, prop, NULL) != NULL))
+			fdt_setprop(fdt, off, prop, val, len);
+		off = fdt_node_offset_by_compatible(fdt, off, compat);
+	}
+}
+
+void do_fixup_by_compat_u32(void *fdt, const char *compat,
+			    const char *prop, u32 val, int create)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	do_fixup_by_compat(fdt, compat, prop, &tmp, 4, create);
+}
+
+#ifdef CONFIG_ARCH_FIXUP_FDT_MEMORY
+/*
+ * fdt_pack_reg - pack address and size array into the "reg"-suitable stream
+ */
+static int fdt_pack_reg(const void *fdt, void *buf, u64 *address, u64 *size,
+			int n)
+{
+	int i;
+	int address_cells = fdt_address_cells(fdt, 0);
+	int size_cells = fdt_size_cells(fdt, 0);
+	char *p = buf;
+
+	for (i = 0; i < n; i++) {
+		if (address_cells == 2)
+			*(fdt64_t *)p = cpu_to_fdt64(address[i]);
+		else
+			*(fdt32_t *)p = cpu_to_fdt32(address[i]);
+		p += 4 * address_cells;
+
+		if (size_cells == 2)
+			*(fdt64_t *)p = cpu_to_fdt64(size[i]);
+		else
+			*(fdt32_t *)p = cpu_to_fdt32(size[i]);
+		p += 4 * size_cells;
+	}
+
+	return p - (char *)buf;
+}
+
+#if CONFIG_NR_DRAM_BANKS > 4
+#define MEMORY_BANKS_MAX CONFIG_NR_DRAM_BANKS
+#else
+#define MEMORY_BANKS_MAX 4
+#endif
+int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[], int banks)
+{
+	int err, nodeoffset;
+	int len, i;
+	u8 tmp[MEMORY_BANKS_MAX * 16]; /* Up to 64-bit address + 64-bit size */
+
+	if (banks > MEMORY_BANKS_MAX) {
+		printf("%s: num banks %d exceeds hardcoded limit %d."
+		       " Recompile with higher MEMORY_BANKS_MAX?\n",
+		       __FUNCTION__, banks, MEMORY_BANKS_MAX);
+		return -1;
+	}
+
+	err = fdt_check_header(blob);
+	if (err < 0) {
+		printf("%s: %s\n", __FUNCTION__, fdt_strerror(err));
+		return err;
+	}
+
+	/* find or create "/memory" node. */
+	nodeoffset = fdt_find_or_add_subnode(blob, 0, "memory");
+	if (nodeoffset < 0)
+			return nodeoffset;
+
+	err = fdt_setprop(blob, nodeoffset, "device_type", "memory",
+			sizeof("memory"));
+	if (err < 0) {
+		printf("WARNING: could not set %s %s.\n", "device_type",
+				fdt_strerror(err));
+		return err;
+	}
+
+	for (i = 0; i < banks; i++) {
+		if (start[i] == 0 && size[i] == 0)
+			break;
+	}
+
+	banks = i;
+
+	if (!banks)
+		return 0;
+
+	for (i = 0; i < banks; i++)
+		if (start[i] == 0 && size[i] == 0)
+			break;
+
+	banks = i;
+
+	len = fdt_pack_reg(blob, tmp, start, size, banks);
+
+	err = fdt_setprop(blob, nodeoffset, "reg", tmp, len);
+	if (err < 0) {
+		printf("WARNING: could not set %s %s.\n",
+				"reg", fdt_strerror(err));
+		return err;
+	}
+	return 0;
+}
+#endif
+
+int fdt_fixup_memory(void *blob, u64 start, u64 size)
+{
+	return fdt_fixup_memory_banks(blob, &start, &size, 1);
+}
+
+void fdt_fixup_ethernet(void *fdt)
+{
+	int i = 0, j, prop;
+	char *tmp, *end;
+	char mac[16];
+	const char *path;
+	unsigned char mac_addr[ARP_HLEN];
+	int offset;
+#ifdef FDT_SEQ_MACADDR_FROM_ENV
+	int nodeoff;
+	const struct fdt_property *fdt_prop;
+#endif
+
+	if (fdt_path_offset(fdt, "/aliases") < 0)
+		return;
+
+	/* Cycle through all aliases */
+	for (prop = 0; ; prop++) {
+		const char *name;
+
+		/* FDT might have been edited, recompute the offset */
+		offset = fdt_first_property_offset(fdt,
+			fdt_path_offset(fdt, "/aliases"));
+		/* Select property number 'prop' */
+		for (j = 0; j < prop; j++)
+			offset = fdt_next_property_offset(fdt, offset);
+
+		if (offset < 0)
+			break;
+
+		path = fdt_getprop_by_offset(fdt, offset, &name, NULL);
+		if (!strncmp(name, "ethernet", 8)) {
+			/* Treat plain "ethernet" same as "ethernet0". */
+			if (!strcmp(name, "ethernet")
+#ifdef FDT_SEQ_MACADDR_FROM_ENV
+			 || !strcmp(name, "ethernet0")
+#endif
+			)
+				i = 0;
+#ifndef FDT_SEQ_MACADDR_FROM_ENV
+			else
+				i = trailing_strtol(name);
+#endif
+			if (i != -1) {
+				if (i == 0)
+					strcpy(mac, "ethaddr");
+				else
+					sprintf(mac, "eth%daddr", i);
+			} else {
+				continue;
+			}
+#ifdef FDT_SEQ_MACADDR_FROM_ENV
+			nodeoff = fdt_path_offset(fdt, path);
+			fdt_prop = fdt_get_property(fdt, nodeoff, "status",
+						    NULL);
+			if (fdt_prop && !strcmp(fdt_prop->data, "disabled"))
+				continue;
+			i++;
+#endif
+			tmp = env_get(mac);
+			if (!tmp)
+				continue;
+
+			for (j = 0; j < 6; j++) {
+				mac_addr[j] = tmp ?
+					      simple_strtoul(tmp, &end, 16) : 0;
+				if (tmp)
+					tmp = (*end) ? end + 1 : end;
+			}
+
+			do_fixup_by_path(fdt, path, "mac-address",
+					 &mac_addr, 6, 0);
+			do_fixup_by_path(fdt, path, "local-mac-address",
+					 &mac_addr, 6, 1);
+		}
+	}
+}
+
+int fdt_record_loadable(void *blob, u32 index, const char *name,
+			uintptr_t load_addr, u32 size, uintptr_t entry_point,
+			const char *type, const char *os)
+{
+	int err, node;
+
+	err = fdt_check_header(blob);
+	if (err < 0) {
+		printf("%s: %s\n", __func__, fdt_strerror(err));
+		return err;
+	}
+
+	/* find or create "/fit-images" node */
+	node = fdt_find_or_add_subnode(blob, 0, "fit-images");
+	if (node < 0)
+		return node;
+
+	/* find or create "/fit-images/<name>" node */
+	node = fdt_find_or_add_subnode(blob, node, name);
+	if (node < 0)
+		return node;
+
+	/*
+	 * We record these as 32bit entities, possibly truncating addresses.
+	 * However, spl_fit.c is not 64bit safe either: i.e. we should not
+	 * have an issue here.
+	 */
+	fdt_setprop_u32(blob, node, "load-addr", load_addr);
+	if (entry_point != -1)
+		fdt_setprop_u32(blob, node, "entry-point", entry_point);
+	fdt_setprop_u32(blob, node, "size", size);
+	if (type)
+		fdt_setprop_string(blob, node, "type", type);
+	if (os)
+		fdt_setprop_string(blob, node, "os", os);
+
+	return node;
+}
+
+/* Resize the fdt to its actual size + a bit of padding */
+int fdt_shrink_to_minimum(void *blob, uint extrasize)
+{
+	int i;
+	uint64_t addr, size;
+	int total, ret;
+	uint actualsize;
+
+	if (!blob)
+		return 0;
+
+	total = fdt_num_mem_rsv(blob);
+	for (i = 0; i < total; i++) {
+		fdt_get_mem_rsv(blob, i, &addr, &size);
+		if (addr == (uintptr_t)blob) {
+			fdt_del_mem_rsv(blob, i);
+			break;
+		}
+	}
+
+	/*
+	 * Calculate the actual size of the fdt
+	 * plus the size needed for 5 fdt_add_mem_rsv, one
+	 * for the fdt itself and 4 for a possible initrd
+	 * ((initrd-start + initrd-end) * 2 (name & value))
+	 */
+	actualsize = fdt_off_dt_strings(blob) +
+		fdt_size_dt_strings(blob) + 5 * sizeof(struct fdt_reserve_entry);
+
+	actualsize += extrasize;
+	/* Make it so the fdt ends on a page boundary */
+	actualsize = ALIGN(actualsize + ((uintptr_t)blob & 0xfff), 0x1000);
+	actualsize = actualsize - ((uintptr_t)blob & 0xfff);
+
+	/* Change the fdt header to reflect the correct size */
+	fdt_set_totalsize(blob, actualsize);
+
+	/* Add the new reservation */
+	ret = fdt_add_mem_rsv(blob, (uintptr_t)blob, actualsize);
+	if (ret < 0)
+		return ret;
+
+	return actualsize;
+}
+
+#ifdef CONFIG_PCI
+#define CONFIG_SYS_PCI_NR_INBOUND_WIN 4
+
+#define FDT_PCI_PREFETCH	(0x40000000)
+#define FDT_PCI_MEM32		(0x02000000)
+#define FDT_PCI_IO		(0x01000000)
+#define FDT_PCI_MEM64		(0x03000000)
+
+int fdt_pci_dma_ranges(void *blob, int phb_off, struct pci_controller *hose) {
+
+	int addrcell, sizecell, len, r;
+	u32 *dma_range;
+	/* sized based on pci addr cells, size-cells, & address-cells */
+	u32 dma_ranges[(3 + 2 + 2) * CONFIG_SYS_PCI_NR_INBOUND_WIN];
+
+	addrcell = fdt_getprop_u32_default(blob, "/", "#address-cells", 1);
+	sizecell = fdt_getprop_u32_default(blob, "/", "#size-cells", 1);
+
+	dma_range = &dma_ranges[0];
+	for (r = 0; r < hose->region_count; r++) {
+		u64 bus_start, phys_start, size;
+
+		/* skip if !PCI_REGION_SYS_MEMORY */
+		if (!(hose->regions[r].flags & PCI_REGION_SYS_MEMORY))
+			continue;
+
+		bus_start = (u64)hose->regions[r].bus_start;
+		phys_start = (u64)hose->regions[r].phys_start;
+		size = (u64)hose->regions[r].size;
+
+		dma_range[0] = 0;
+		if (size >= 0x100000000ull)
+			dma_range[0] |= FDT_PCI_MEM64;
+		else
+			dma_range[0] |= FDT_PCI_MEM32;
+		if (hose->regions[r].flags & PCI_REGION_PREFETCH)
+			dma_range[0] |= FDT_PCI_PREFETCH;
+#ifdef CONFIG_SYS_PCI_64BIT
+		dma_range[1] = bus_start >> 32;
+#else
+		dma_range[1] = 0;
+#endif
+		dma_range[2] = bus_start & 0xffffffff;
+
+		if (addrcell == 2) {
+			dma_range[3] = phys_start >> 32;
+			dma_range[4] = phys_start & 0xffffffff;
+		} else {
+			dma_range[3] = phys_start & 0xffffffff;
+		}
+
+		if (sizecell == 2) {
+			dma_range[3 + addrcell + 0] = size >> 32;
+			dma_range[3 + addrcell + 1] = size & 0xffffffff;
+		} else {
+			dma_range[3 + addrcell + 0] = size & 0xffffffff;
+		}
+
+		dma_range += (3 + addrcell + sizecell);
+	}
+
+	len = dma_range - &dma_ranges[0];
+	if (len)
+		fdt_setprop(blob, phb_off, "dma-ranges", &dma_ranges[0], len*4);
+
+	return 0;
+}
+#endif
+
+int fdt_increase_size(void *fdt, int add_len)
+{
+	int newlen;
+
+	newlen = fdt_totalsize(fdt) + add_len;
+
+	/* Open in place with a new len */
+	return fdt_open_into(fdt, fdt, newlen);
+}
+
+#ifdef CONFIG_FDT_FIXUP_PARTITIONS
+#include <jffs2/load_kernel.h>
+#include <mtd_node.h>
+
+struct reg_cell {
+	unsigned int r0;
+	unsigned int r1;
+};
+
+static int fdt_del_subnodes(const void *blob, int parent_offset)
+{
+	int off, ndepth;
+	int ret;
+
+	for (ndepth = 0, off = fdt_next_node(blob, parent_offset, &ndepth);
+	     (off >= 0) && (ndepth > 0);
+	     off = fdt_next_node(blob, off, &ndepth)) {
+		if (ndepth == 1) {
+			debug("delete %s: offset: %x\n",
+				fdt_get_name(blob, off, 0), off);
+			ret = fdt_del_node((void *)blob, off);
+			if (ret < 0) {
+				printf("Can't delete node: %s\n",
+					fdt_strerror(ret));
+				return ret;
+			} else {
+				ndepth = 0;
+				off = parent_offset;
+			}
+		}
+	}
+	return 0;
+}
+
+static int fdt_del_partitions(void *blob, int parent_offset)
+{
+	const void *prop;
+	int ndepth = 0;
+	int off;
+	int ret;
+
+	off = fdt_next_node(blob, parent_offset, &ndepth);
+	if (off > 0 && ndepth == 1) {
+		prop = fdt_getprop(blob, off, "label", NULL);
+		if (prop == NULL) {
+			/*
+			 * Could not find label property, nand {}; node?
+			 * Check subnode, delete partitions there if any.
+			 */
+			return fdt_del_partitions(blob, off);
+		} else {
+			ret = fdt_del_subnodes(blob, parent_offset);
+			if (ret < 0) {
+				printf("Can't remove subnodes: %s\n",
+					fdt_strerror(ret));
+				return ret;
+			}
+		}
+	}
+	return 0;
+}
+
+int fdt_node_set_part_info(void *blob, int parent_offset,
+			   struct mtd_device *dev)
+{
+	struct list_head *pentry;
+	struct part_info *part;
+	struct reg_cell cell;
+	int off, ndepth = 0;
+	int part_num, ret;
+	char buf[64];
+
+	ret = fdt_del_partitions(blob, parent_offset);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Check if it is nand {}; subnode, adjust
+	 * the offset in this case
+	 */
+	off = fdt_next_node(blob, parent_offset, &ndepth);
+	if (off > 0 && ndepth == 1)
+		parent_offset = off;
+
+	part_num = 0;
+	list_for_each_prev(pentry, &dev->parts) {
+		int newoff;
+
+		part = list_entry(pentry, struct part_info, link);
+
+		debug("%2d: %-20s0x%08llx\t0x%08llx\t%d\n",
+			part_num, part->name, part->size,
+			part->offset, part->mask_flags);
+
+		sprintf(buf, "partition@%llx", part->offset);
+add_sub:
+		ret = fdt_add_subnode(blob, parent_offset, buf);
+		if (ret == -FDT_ERR_NOSPACE) {
+			ret = fdt_increase_size(blob, 512);
+			if (!ret)
+				goto add_sub;
+			else
+				goto err_size;
+		} else if (ret < 0) {
+			printf("Can't add partition node: %s\n",
+				fdt_strerror(ret));
+			return ret;
+		}
+		newoff = ret;
+
+		/* Check MTD_WRITEABLE_CMD flag */
+		if (part->mask_flags & 1) {
+add_ro:
+			ret = fdt_setprop(blob, newoff, "read_only", NULL, 0);
+			if (ret == -FDT_ERR_NOSPACE) {
+				ret = fdt_increase_size(blob, 512);
+				if (!ret)
+					goto add_ro;
+				else
+					goto err_size;
+			} else if (ret < 0)
+				goto err_prop;
+		}
+
+		cell.r0 = cpu_to_fdt32(part->offset);
+		cell.r1 = cpu_to_fdt32(part->size);
+add_reg:
+		ret = fdt_setprop(blob, newoff, "reg", &cell, sizeof(cell));
+		if (ret == -FDT_ERR_NOSPACE) {
+			ret = fdt_increase_size(blob, 512);
+			if (!ret)
+				goto add_reg;
+			else
+				goto err_size;
+		} else if (ret < 0)
+			goto err_prop;
+
+add_label:
+		ret = fdt_setprop_string(blob, newoff, "label", part->name);
+		if (ret == -FDT_ERR_NOSPACE) {
+			ret = fdt_increase_size(blob, 512);
+			if (!ret)
+				goto add_label;
+			else
+				goto err_size;
+		} else if (ret < 0)
+			goto err_prop;
+
+		part_num++;
+	}
+	return 0;
+err_size:
+	printf("Can't increase blob size: %s\n", fdt_strerror(ret));
+	return ret;
+err_prop:
+	printf("Can't add property: %s\n", fdt_strerror(ret));
+	return ret;
+}
+
+/*
+ * Update partitions in nor/nand nodes using info from
+ * mtdparts environment variable. The nodes to update are
+ * specified by node_info structure which contains mtd device
+ * type and compatible string: E. g. the board code in
+ * ft_board_setup() could use:
+ *
+ *	struct node_info nodes[] = {
+ *		{ "fsl,mpc5121-nfc",    MTD_DEV_TYPE_NAND, },
+ *		{ "cfi-flash",          MTD_DEV_TYPE_NOR,  },
+ *	};
+ *
+ *	fdt_fixup_mtdparts(blob, nodes, ARRAY_SIZE(nodes));
+ */
+void fdt_fixup_mtdparts(void *blob, const struct node_info *node_info,
+			int node_info_size)
+{
+	struct mtd_device *dev;
+	int i, idx;
+	int noff;
+
+	if (mtdparts_init() != 0)
+		return;
+
+	for (i = 0; i < node_info_size; i++) {
+		idx = 0;
+		noff = fdt_node_offset_by_compatible(blob, -1,
+						     node_info[i].compat);
+		while (noff != -FDT_ERR_NOTFOUND) {
+			debug("%s: %s, mtd dev type %d\n",
+				fdt_get_name(blob, noff, 0),
+				node_info[i].compat, node_info[i].type);
+			dev = device_find(node_info[i].type, idx++);
+			if (dev) {
+				if (fdt_node_set_part_info(blob, noff, dev))
+					return; /* return on error */
+			}
+
+			/* Jump to next flash node */
+			noff = fdt_node_offset_by_compatible(blob, noff,
+							     node_info[i].compat);
+		}
+	}
+}
+#endif
+
+void fdt_del_node_and_alias(void *blob, const char *alias)
+{
+	int off = fdt_path_offset(blob, alias);
+
+	if (off < 0)
+		return;
+
+	fdt_del_node(blob, off);
+
+	off = fdt_path_offset(blob, "/aliases");
+	fdt_delprop(blob, off, alias);
+}
+
+/* Max address size we deal with */
+#define OF_MAX_ADDR_CELLS	4
+#define OF_BAD_ADDR	FDT_ADDR_T_NONE
+#define OF_CHECK_COUNTS(na, ns)	((na) > 0 && (na) <= OF_MAX_ADDR_CELLS && \
+			(ns) > 0)
+
+/* Debug utility */
+#ifdef DEBUG
+static void of_dump_addr(const char *s, const fdt32_t *addr, int na)
+{
+	printf("%s", s);
+	while(na--)
+		printf(" %08x", *(addr++));
+	printf("\n");
+}
+#else
+static void of_dump_addr(const char *s, const fdt32_t *addr, int na) { }
+#endif
+
+/**
+ * struct of_bus - Callbacks for bus specific translators
+ * @name:	A string used to identify this bus in debug output.
+ * @addresses:	The name of the DT property from which addresses are
+ *		to be read, typically "reg".
+ * @match:	Return non-zero if the node whose parent is at
+ *		parentoffset in the FDT blob corresponds to a bus
+ *		of this type, otherwise return zero. If NULL a match
+ *		is assumed.
+ * @count_cells:Count how many cells (be32 values) a node whose parent
+ *		is at parentoffset in the FDT blob will require to
+ *		represent its address (written to *addrc) & size
+ *		(written to *sizec).
+ * @map:	Map the address addr from the address space of this
+ *		bus to that of its parent, making use of the ranges
+ *		read from DT to an array at range. na and ns are the
+ *		number of cells (be32 values) used to hold and address
+ *		or size, respectively, for this bus. pna is the number
+ *		of cells used to hold an address for the parent bus.
+ *		Returns the address in the address space of the parent
+ *		bus.
+ * @translate:	Update the value of the address cells at addr within an
+ *		FDT by adding offset to it. na specifies the number of
+ *		cells used to hold the address being translated. Returns
+ *		zero on success, non-zero on error.
+ *
+ * Each bus type will include a struct of_bus in the of_busses array,
+ * providing implementations of some or all of the functions used to
+ * match the bus & handle address translation for its children.
+ */
+struct of_bus {
+	const char	*name;
+	const char	*addresses;
+	int		(*match)(const void *blob, int parentoffset);
+	void		(*count_cells)(const void *blob, int parentoffset,
+				int *addrc, int *sizec);
+	u64		(*map)(fdt32_t *addr, const fdt32_t *range,
+				int na, int ns, int pna);
+	int		(*translate)(fdt32_t *addr, u64 offset, int na);
+};
+
+/* Default translator (generic bus) */
+void fdt_support_default_count_cells(const void *blob, int parentoffset,
+					int *addrc, int *sizec)
+{
+	const fdt32_t *prop;
+
+	if (addrc)
+		*addrc = fdt_address_cells(blob, parentoffset);
+
+	if (sizec) {
+		prop = fdt_getprop(blob, parentoffset, "#size-cells", NULL);
+		if (prop)
+			*sizec = be32_to_cpup(prop);
+		else
+			*sizec = 1;
+	}
+}
+
+static u64 of_bus_default_map(fdt32_t *addr, const fdt32_t *range,
+		int na, int ns, int pna)
+{
+	u64 cp, s, da;
+
+	cp = fdt_read_number(range, na);
+	s  = fdt_read_number(range + na + pna, ns);
+	da = fdt_read_number(addr, na);
+
+	debug("OF: default map, cp=%llu, s=%llu, da=%llu\n", cp, s, da);
+
+	if (da < cp || da >= (cp + s))
+		return OF_BAD_ADDR;
+	return da - cp;
+}
+
+static int of_bus_default_translate(fdt32_t *addr, u64 offset, int na)
+{
+	u64 a = fdt_read_number(addr, na);
+	memset(addr, 0, na * 4);
+	a += offset;
+	if (na > 1)
+		addr[na - 2] = cpu_to_fdt32(a >> 32);
+	addr[na - 1] = cpu_to_fdt32(a & 0xffffffffu);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF_ISA_BUS
+
+/* ISA bus translator */
+static int of_bus_isa_match(const void *blob, int parentoffset)
+{
+	const char *name;
+
+	name = fdt_get_name(blob, parentoffset, NULL);
+	if (!name)
+		return 0;
+
+	return !strcmp(name, "isa");
+}
+
+static void of_bus_isa_count_cells(const void *blob, int parentoffset,
+				   int *addrc, int *sizec)
+{
+	if (addrc)
+		*addrc = 2;
+	if (sizec)
+		*sizec = 1;
+}
+
+static u64 of_bus_isa_map(fdt32_t *addr, const fdt32_t *range,
+			  int na, int ns, int pna)
+{
+	u64 cp, s, da;
+
+	/* Check address type match */
+	if ((addr[0] ^ range[0]) & cpu_to_be32(1))
+		return OF_BAD_ADDR;
+
+	cp = fdt_read_number(range + 1, na - 1);
+	s  = fdt_read_number(range + na + pna, ns);
+	da = fdt_read_number(addr + 1, na - 1);
+
+	debug("OF: ISA map, cp=%llu, s=%llu, da=%llu\n", cp, s, da);
+
+	if (da < cp || da >= (cp + s))
+		return OF_BAD_ADDR;
+	return da - cp;
+}
+
+static int of_bus_isa_translate(fdt32_t *addr, u64 offset, int na)
+{
+	return of_bus_default_translate(addr + 1, offset, na - 1);
+}
+
+#endif /* CONFIG_OF_ISA_BUS */
+
+/* Array of bus specific translators */
+static struct of_bus of_busses[] = {
+#ifdef CONFIG_OF_ISA_BUS
+	/* ISA */
+	{
+		.name = "isa",
+		.addresses = "reg",
+		.match = of_bus_isa_match,
+		.count_cells = of_bus_isa_count_cells,
+		.map = of_bus_isa_map,
+		.translate = of_bus_isa_translate,
+	},
+#endif /* CONFIG_OF_ISA_BUS */
+	/* Default */
+	{
+		.name = "default",
+		.addresses = "reg",
+		.count_cells = fdt_support_default_count_cells,
+		.map = of_bus_default_map,
+		.translate = of_bus_default_translate,
+	},
+};
+
+static struct of_bus *of_match_bus(const void *blob, int parentoffset)
+{
+	struct of_bus *bus;
+
+	if (ARRAY_SIZE(of_busses) == 1)
+		return of_busses;
+
+	for (bus = of_busses; bus; bus++) {
+		if (!bus->match || bus->match(blob, parentoffset))
+			return bus;
+	}
+
+	/*
+	 * We should always have matched the default bus at least, since
+	 * it has a NULL match field. If we didn't then it somehow isn't
+	 * in the of_busses array or something equally catastrophic has
+	 * gone wrong.
+	 */
+	//assert(0);
+	return NULL;
+}
+
+static int of_translate_one(const void *blob, int parent, struct of_bus *bus,
+			    struct of_bus *pbus, fdt32_t *addr,
+			    int na, int ns, int pna, const char *rprop)
+{
+	const fdt32_t *ranges;
+	int rlen;
+	int rone;
+	u64 offset = OF_BAD_ADDR;
+
+	/* Normally, an absence of a "ranges" property means we are
+	 * crossing a non-translatable boundary, and thus the addresses
+	 * below the current not cannot be converted to CPU physical ones.
+	 * Unfortunately, while this is very clear in the spec, it's not
+	 * what Apple understood, and they do have things like /uni-n or
+	 * /ht nodes with no "ranges" property and a lot of perfectly
+	 * useable mapped devices below them. Thus we treat the absence of
+	 * "ranges" as equivalent to an empty "ranges" property which means
+	 * a 1:1 translation at that level. It's up to the caller not to try
+	 * to translate addresses that aren't supposed to be translated in
+	 * the first place. --BenH.
+	 */
+	ranges = fdt_getprop(blob, parent, rprop, &rlen);
+	if (ranges == NULL || rlen == 0) {
+		offset = fdt_read_number(addr, na);
+		memset(addr, 0, pna * 4);
+		debug("OF: no ranges, 1:1 translation\n");
+		goto finish;
+	}
+
+	debug("OF: walking ranges...\n");
+
+	/* Now walk through the ranges */
+	rlen /= 4;
+	rone = na + pna + ns;
+	for (; rlen >= rone; rlen -= rone, ranges += rone) {
+		offset = bus->map(addr, ranges, na, ns, pna);
+		if (offset != OF_BAD_ADDR)
+			break;
+	}
+	if (offset == OF_BAD_ADDR) {
+		debug("OF: not found !\n");
+		return 1;
+	}
+	memcpy(addr, ranges + na, 4 * pna);
+
+ finish:
+	of_dump_addr("OF: parent translation for:", addr, pna);
+	debug("OF: with offset: %llu\n", offset);
+
+	/* Translate it into parent bus space */
+	return pbus->translate(addr, offset, pna);
+}
+
+/*
+ * Translate an address from the device-tree into a CPU physical address,
+ * this walks up the tree and applies the various bus mappings on the
+ * way.
+ *
+ * Note: We consider that crossing any level with #size-cells == 0 to mean
+ * that translation is impossible (that is we are not dealing with a value
+ * that can be mapped to a cpu physical address). This is not really specified
+ * that way, but this is traditionally the way IBM at least do things
+ */
+static u64 __of_translate_address(const void *blob, int node_offset,
+				  const fdt32_t *in_addr, const char *rprop)
+{
+	int parent;
+	struct of_bus *bus, *pbus;
+	fdt32_t addr[OF_MAX_ADDR_CELLS];
+	int na, ns, pna, pns;
+	u64 result = OF_BAD_ADDR;
+
+	debug("OF: ** translation for device %s **\n",
+		fdt_get_name(blob, node_offset, NULL));
+
+	/* Get parent & match bus type */
+	parent = fdt_parent_offset(blob, node_offset);
+	if (parent < 0)
+		goto bail;
+	bus = of_match_bus(blob, parent);
+
+	/* Cound address cells & copy address locally */
+	bus->count_cells(blob, parent, &na, &ns);
+	if (!OF_CHECK_COUNTS(na, ns)) {
+		printf("%s: Bad cell count for %s\n", __FUNCTION__,
+		       fdt_get_name(blob, node_offset, NULL));
+		goto bail;
+	}
+	memcpy(addr, in_addr, na * 4);
+
+	debug("OF: bus is %s (na=%d, ns=%d) on %s\n",
+	    bus->name, na, ns, fdt_get_name(blob, parent, NULL));
+	of_dump_addr("OF: translating address:", addr, na);
+
+	/* Translate */
+	for (;;) {
+		/* Switch to parent bus */
+		node_offset = parent;
+		parent = fdt_parent_offset(blob, node_offset);
+
+		/* If root, we have finished */
+		if (parent < 0) {
+			debug("OF: reached root node\n");
+			result = fdt_read_number(addr, na);
+			break;
+		}
+
+		/* Get new parent bus and counts */
+		pbus = of_match_bus(blob, parent);
+		pbus->count_cells(blob, parent, &pna, &pns);
+		if (!OF_CHECK_COUNTS(pna, pns)) {
+			printf("%s: Bad cell count for %s\n", __FUNCTION__,
+				fdt_get_name(blob, node_offset, NULL));
+			break;
+		}
+
+		debug("OF: parent bus is %s (na=%d, ns=%d) on %s\n",
+		    pbus->name, pna, pns, fdt_get_name(blob, parent, NULL));
+
+		/* Apply bus translation */
+		if (of_translate_one(blob, node_offset, bus, pbus,
+					addr, na, ns, pna, rprop))
+			break;
+
+		/* Complete the move up one level */
+		na = pna;
+		ns = pns;
+		bus = pbus;
+
+		of_dump_addr("OF: one level translation:", addr, na);
+	}
+ bail:
+
+	return result;
+}
+
+u64 fdt_translate_address(const void *blob, int node_offset,
+			  const fdt32_t *in_addr)
+{
+	return __of_translate_address(blob, node_offset, in_addr, "ranges");
+}
+
+/**
+ * fdt_node_offset_by_compat_reg: Find a node that matches compatiable and
+ * who's reg property matches a physical cpu address
+ *
+ * @blob: ptr to device tree
+ * @compat: compatiable string to match
+ * @compat_off: property name
+ *
+ */
+int fdt_node_offset_by_compat_reg(void *blob, const char *compat,
+					phys_addr_t compat_off)
+{
+	int len, off = fdt_node_offset_by_compatible(blob, -1, compat);
+	while (off != -FDT_ERR_NOTFOUND) {
+		const fdt32_t *reg = fdt_getprop(blob, off, "reg", &len);
+		if (reg) {
+			if (compat_off == fdt_translate_address(blob, off, reg))
+				return off;
+		}
+		off = fdt_node_offset_by_compatible(blob, off, compat);
+	}
+
+	return -FDT_ERR_NOTFOUND;
+}
+
+/**
+ * fdt_alloc_phandle: Return next free phandle value
+ *
+ * @blob: ptr to device tree
+ */
+int fdt_alloc_phandle(void *blob)
+{
+	int offset;
+	uint32_t phandle = 0;
+
+	for (offset = fdt_next_node(blob, -1, NULL); offset >= 0;
+	     offset = fdt_next_node(blob, offset, NULL)) {
+		phandle = max(phandle, fdt_get_phandle(blob, offset));
+	}
+
+	return phandle + 1;
+}
+
+/*
+ * fdt_set_phandle: Create a phandle property for the given node
+ *
+ * @fdt: ptr to device tree
+ * @nodeoffset: node to update
+ * @phandle: phandle value to set (must be unique)
+ */
+int fdt_set_phandle(void *fdt, int nodeoffset, uint32_t phandle)
+{
+	int ret;
+
+#ifdef DEBUG
+	int off = fdt_node_offset_by_phandle(fdt, phandle);
+
+	if ((off >= 0) && (off != nodeoffset)) {
+		char buf[64];
+
+		fdt_get_path(fdt, nodeoffset, buf, sizeof(buf));
+		printf("Trying to update node %s with phandle %u ",
+		       buf, phandle);
+
+		fdt_get_path(fdt, off, buf, sizeof(buf));
+		printf("that already exists in node %s.\n", buf);
+		return -FDT_ERR_BADPHANDLE;
+	}
+#endif
+
+	ret = fdt_setprop_cell(fdt, nodeoffset, "phandle", phandle);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * For now, also set the deprecated "linux,phandle" property, so that we
+	 * don't break older kernels.
+	 */
+	ret = fdt_setprop_cell(fdt, nodeoffset, "linux,phandle", phandle);
+
+	return ret;
+}
+
+/*
+ * fdt_create_phandle: Create a phandle property for the given node
+ *
+ * @fdt: ptr to device tree
+ * @nodeoffset: node to update
+ */
+unsigned int fdt_create_phandle(void *fdt, int nodeoffset)
+{
+	/* see if there is a phandle already */
+	int phandle = fdt_get_phandle(fdt, nodeoffset);
+
+	/* if we got 0, means no phandle so create one */
+	if (phandle == 0) {
+		int ret;
+
+		phandle = fdt_alloc_phandle(fdt);
+		ret = fdt_set_phandle(fdt, nodeoffset, phandle);
+		if (ret < 0) {
+			printf("Can't set phandle %u: %s\n", phandle,
+			       fdt_strerror(ret));
+			return 0;
+		}
+	}
+
+	return phandle;
+}
+
+/*
+ * fdt_set_node_status: Set status for the given node
+ *
+ * @fdt: ptr to device tree
+ * @nodeoffset: node to update
+ * @status: FDT_STATUS_OKAY, FDT_STATUS_DISABLED,
+ *	    FDT_STATUS_FAIL, FDT_STATUS_FAIL_ERROR_CODE
+ * @error_code: optional, only used if status is FDT_STATUS_FAIL_ERROR_CODE
+ */
+int fdt_set_node_status(void *fdt, int nodeoffset,
+			enum fdt_status status, unsigned int error_code)
+{
+	char buf[16];
+	int ret = 0;
+
+	if (nodeoffset < 0)
+		return nodeoffset;
+
+	switch (status) {
+	case FDT_STATUS_OKAY:
+		ret = fdt_setprop_string(fdt, nodeoffset, "status", "okay");
+		break;
+	case FDT_STATUS_DISABLED:
+		ret = fdt_setprop_string(fdt, nodeoffset, "status", "disabled");
+		break;
+	case FDT_STATUS_FAIL:
+		ret = fdt_setprop_string(fdt, nodeoffset, "status", "fail");
+		break;
+	case FDT_STATUS_FAIL_ERROR_CODE:
+		sprintf(buf, "fail-%d", error_code);
+		ret = fdt_setprop_string(fdt, nodeoffset, "status", buf);
+		break;
+	default:
+		printf("Invalid fdt status: %x\n", status);
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * fdt_set_status_by_alias: Set status for the given node given an alias
+ *
+ * @fdt: ptr to device tree
+ * @alias: alias of node to update
+ * @status: FDT_STATUS_OKAY, FDT_STATUS_DISABLED,
+ *	    FDT_STATUS_FAIL, FDT_STATUS_FAIL_ERROR_CODE
+ * @error_code: optional, only used if status is FDT_STATUS_FAIL_ERROR_CODE
+ */
+int fdt_set_status_by_alias(void *fdt, const char* alias,
+			    enum fdt_status status, unsigned int error_code)
+{
+	int offset = fdt_path_offset(fdt, alias);
+
+	return fdt_set_node_status(fdt, offset, status, error_code);
+}
+
+#if defined(CONFIG_VIDEO) || defined(CONFIG_LCD)
+int fdt_add_edid(void *blob, const char *compat, unsigned char *edid_buf)
+{
+	int noff;
+	int ret;
+
+	noff = fdt_node_offset_by_compatible(blob, -1, compat);
+	if (noff != -FDT_ERR_NOTFOUND) {
+		debug("%s: %s\n", fdt_get_name(blob, noff, 0), compat);
+add_edid:
+		ret = fdt_setprop(blob, noff, "edid", edid_buf, 128);
+		if (ret == -FDT_ERR_NOSPACE) {
+			ret = fdt_increase_size(blob, 512);
+			if (!ret)
+				goto add_edid;
+			else
+				goto err_size;
+		} else if (ret < 0) {
+			printf("Can't add property: %s\n", fdt_strerror(ret));
+			return ret;
+		}
+	}
+	return 0;
+err_size:
+	printf("Can't increase blob size: %s\n", fdt_strerror(ret));
+	return ret;
+}
+#endif
+
+/*
+ * Verify the physical address of device tree node for a given alias
+ *
+ * This function locates the device tree node of a given alias, and then
+ * verifies that the physical address of that device matches the given
+ * parameter.  It displays a message if there is a mismatch.
+ *
+ * Returns 1 on success, 0 on failure
+ */
+int fdt_verify_alias_address(void *fdt, int anode, const char *alias, u64 addr)
+{
+	const char *path;
+	const fdt32_t *reg;
+	int node, len;
+	u64 dt_addr;
+
+	path = fdt_getprop(fdt, anode, alias, NULL);
+	if (!path) {
+		/* If there's no such alias, then it's not a failure */
+		return 1;
+	}
+
+	node = fdt_path_offset(fdt, path);
+	if (node < 0) {
+		printf("Warning: device tree alias '%s' points to invalid "
+		       "node %s.\n", alias, path);
+		return 0;
+	}
+
+	reg = fdt_getprop(fdt, node, "reg", &len);
+	if (!reg) {
+		printf("Warning: device tree node '%s' has no address.\n",
+		       path);
+		return 0;
+	}
+
+	dt_addr = fdt_translate_address(fdt, node, reg);
+	if (addr != dt_addr) {
+		printf("Warning: U-Boot configured device %s at address %llu,\n"
+		       "but the device tree has it address %llx.\n",
+		       alias, addr, dt_addr);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * Returns the base address of an SOC or PCI node
+ */
+u64 fdt_get_base_address(const void *fdt, int node)
+{
+	int size;
+	const fdt32_t *prop;
+
+	prop = fdt_getprop(fdt, node, "reg", &size);
+
+	return prop ? fdt_translate_address(fdt, node, prop) : 0;
+}
+
+/*
+ * Read a property of size <prop_len>. Currently only supports 1 or 2 cells.
+ */
+static int fdt_read_prop(const fdt32_t *prop, int prop_len, int cell_off,
+			 uint64_t *val, int cells)
+{
+	const fdt32_t *prop32 = &prop[cell_off];
+	const fdt64_t *prop64 = (const fdt64_t *)&prop[cell_off];
+
+	if ((cell_off + cells) > prop_len)
+		return -FDT_ERR_NOSPACE;
+
+	switch (cells) {
+	case 1:
+		*val = fdt32_to_cpu(*prop32);
+		break;
+	case 2:
+		*val = fdt64_to_cpu(*prop64);
+		break;
+	default:
+		return -FDT_ERR_NOSPACE;
+	}
+
+	return 0;
+}
+
+/**
+ * fdt_read_range - Read a node's n'th range property
+ *
+ * @fdt: ptr to device tree
+ * @node: offset of node
+ * @n: range index
+ * @child_addr: pointer to storage for the "child address" field
+ * @addr: pointer to storage for the CPU view translated physical start
+ * @len: pointer to storage for the range length
+ *
+ * Convenience function that reads and interprets a specific range out of
+ * a number of the "ranges" property array.
+ */
+int fdt_read_range(void *fdt, int node, int n, uint64_t *child_addr,
+		   uint64_t *addr, uint64_t *len)
+{
+	int pnode = fdt_parent_offset(fdt, node);
+	const fdt32_t *ranges;
+	int pacells;
+	int acells;
+	int scells;
+	int ranges_len;
+	int cell = 0;
+	int r = 0;
+
+	/*
+	 * The "ranges" property is an array of
+	 * { <child address> <parent address> <size in child address space> }
+	 *
+	 * All 3 elements can span a diffent number of cells. Fetch their size.
+	 */
+	pacells = fdt_getprop_u32_default_node(fdt, pnode, 0, "#address-cells", 1);
+	acells = fdt_getprop_u32_default_node(fdt, node, 0, "#address-cells", 1);
+	scells = fdt_getprop_u32_default_node(fdt, node, 0, "#size-cells", 1);
+
+	/* Now try to get the ranges property */
+	ranges = fdt_getprop(fdt, node, "ranges", &ranges_len);
+	if (!ranges)
+		return -FDT_ERR_NOTFOUND;
+	ranges_len /= sizeof(uint32_t);
+
+	/* Jump to the n'th entry */
+	cell = n * (pacells + acells + scells);
+
+	/* Read <child address> */
+	if (child_addr) {
+		r = fdt_read_prop(ranges, ranges_len, cell, child_addr,
+				  acells);
+		if (r)
+			return r;
+	}
+	cell += acells;
+
+	/* Read <parent address> */
+	if (addr)
+		*addr = fdt_translate_address(fdt, node, ranges + cell);
+	cell += pacells;
+
+	/* Read <size in child address space> */
+	if (len) {
+		r = fdt_read_prop(ranges, ranges_len, cell, len, scells);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+/**
+ * fdt_setup_simplefb_node - Fill and enable a simplefb node
+ *
+ * @fdt: ptr to device tree
+ * @node: offset of the simplefb node
+ * @base_address: framebuffer base address
+ * @width: width in pixels
+ * @height: height in pixels
+ * @stride: bytes per line
+ * @format: pixel format string
+ *
+ * Convenience function to fill and enable a simplefb node.
+ */
+int fdt_setup_simplefb_node(void *fdt, int node, u64 base_address, u32 width,
+			    u32 height, u32 stride, const char *format)
+{
+	char name[32];
+	fdt32_t cells[4];
+	int i, addrc, sizec, ret;
+
+	fdt_support_default_count_cells(fdt, fdt_parent_offset(fdt, node),
+					&addrc, &sizec);
+	i = 0;
+	if (addrc == 2)
+		cells[i++] = cpu_to_fdt32(base_address >> 32);
+	cells[i++] = cpu_to_fdt32(base_address);
+	if (sizec == 2)
+		cells[i++] = 0;
+	cells[i++] = cpu_to_fdt32(height * stride);
+
+	ret = fdt_setprop(fdt, node, "reg", cells, sizeof(cells[0]) * i);
+	if (ret < 0)
+		return ret;
+
+	sprintf(name, "framebuffer@%llx", base_address);
+	ret = fdt_set_name(fdt, node, name);
+	if (ret < 0)
+		return ret;
+
+	ret = fdt_setprop_u32(fdt, node, "width", width);
+	if (ret < 0)
+		return ret;
+
+	ret = fdt_setprop_u32(fdt, node, "height", height);
+	if (ret < 0)
+		return ret;
+
+	ret = fdt_setprop_u32(fdt, node, "stride", stride);
+	if (ret < 0)
+		return ret;
+
+	ret = fdt_setprop_string(fdt, node, "format", format);
+	if (ret < 0)
+		return ret;
+
+	ret = fdt_setprop_string(fdt, node, "status", "okay");
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+/*
+ * Update native-mode in display-timings from display environment variable.
+ * The node to update are specified by path.
+ */
+int fdt_fixup_display(void *blob, const char *path, const char *display)
+{
+	int off, toff;
+
+	if (!display || !path)
+		return -FDT_ERR_NOTFOUND;
+
+	toff = fdt_path_offset(blob, path);
+	if (toff >= 0)
+		toff = fdt_subnode_offset(blob, toff, "display-timings");
+	if (toff < 0)
+		return toff;
+
+	for (off = fdt_first_subnode(blob, toff);
+	     off >= 0;
+	     off = fdt_next_subnode(blob, off)) {
+		uint32_t h = fdt_get_phandle(blob, off);
+		debug("%s:0x%x\n", fdt_get_name(blob, off, NULL),
+		      fdt32_to_cpu(h));
+		if (strcasecmp(fdt_get_name(blob, off, NULL), display) == 0)
+			return fdt_setprop_u32(blob, toff, "native-mode", h);
+	}
+	return toff;
+}
+
+#ifdef CONFIG_OF_LIBFDT_OVERLAY
+/**
+ * fdt_overlay_apply_verbose - Apply an overlay with verbose error reporting
+ *
+ * @fdt: ptr to device tree
+ * @fdto: ptr to device tree overlay
+ *
+ * Convenience function to apply an overlay and display helpful messages
+ * in the case of an error
+ */
+int fdt_overlay_apply_verbose(void *fdt, void *fdto)
+{
+	int err;
+	bool has_symbols;
+
+	err = fdt_path_offset(fdt, "/__symbols__");
+	has_symbols = err >= 0;
+
+	err = fdt_overlay_apply(fdt, fdto);
+	if (err < 0) {
+		printf("failed on fdt_overlay_apply(): %s\n",
+				fdt_strerror(err));
+		if (!has_symbols) {
+			printf("base fdt does did not have a /__symbols__ node\n");
+			printf("make sure you've compiled with -@\n");
+		}
+	}
+	return err;
+}
+#endif
diff -urN u-boot-1.1.6/common/fdt/fdt_sw.c u-boot-1.1.6_fdt/common/fdt/fdt_sw.c
--- u-boot-1.1.6/common/fdt/fdt_sw.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt_sw.c	2018-10-22 15:54:19.601640154 +0800
@@ -0,0 +1,300 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+static int fdt_sw_check_header_(void *fdt)
+{
+	if (fdt_magic(fdt) != FDT_SW_MAGIC)
+		return -FDT_ERR_BADMAGIC;
+	/* FIXME: should check more details about the header state */
+	return 0;
+}
+
+#define FDT_SW_CHECK_HEADER(fdt) \
+	{ \
+		int err; \
+		if ((err = fdt_sw_check_header_(fdt)) != 0) \
+			return err; \
+	}
+
+static void *fdt_grab_space_(void *fdt, size_t len)
+{
+	int offset = fdt_size_dt_struct(fdt);
+	int spaceleft;
+
+	spaceleft = fdt_totalsize(fdt) - fdt_off_dt_struct(fdt)
+		- fdt_size_dt_strings(fdt);
+
+	if ((offset + len < offset) || (offset + len > spaceleft))
+		return NULL;
+
+	fdt_set_size_dt_struct(fdt, offset + len);
+	return fdt_offset_ptr_w_(fdt, offset);
+}
+
+int fdt_create(void *buf, int bufsize)
+{
+	void *fdt = buf;
+
+	if (bufsize < sizeof(struct fdt_header))
+		return -FDT_ERR_NOSPACE;
+
+	memset(buf, 0, bufsize);
+
+	fdt_set_magic(fdt, FDT_SW_MAGIC);
+	fdt_set_version(fdt, FDT_LAST_SUPPORTED_VERSION);
+	fdt_set_last_comp_version(fdt, FDT_FIRST_SUPPORTED_VERSION);
+	fdt_set_totalsize(fdt,  bufsize);
+
+	fdt_set_off_mem_rsvmap(fdt, FDT_ALIGN(sizeof(struct fdt_header),
+					      sizeof(struct fdt_reserve_entry)));
+	fdt_set_off_dt_struct(fdt, fdt_off_mem_rsvmap(fdt));
+	fdt_set_off_dt_strings(fdt, bufsize);
+
+	return 0;
+}
+
+int fdt_resize(void *fdt, void *buf, int bufsize)
+{
+	size_t headsize, tailsize;
+	char *oldtail, *newtail;
+
+	FDT_SW_CHECK_HEADER(fdt);
+
+	headsize = fdt_off_dt_struct(fdt);
+	tailsize = fdt_size_dt_strings(fdt);
+
+	if ((headsize + tailsize) > bufsize)
+		return -FDT_ERR_NOSPACE;
+
+	oldtail = (char *)fdt + fdt_totalsize(fdt) - tailsize;
+	newtail = (char *)buf + bufsize - tailsize;
+
+	/* Two cases to avoid clobbering data if the old and new
+	 * buffers partially overlap */
+	if (buf <= fdt) {
+		memmove(buf, fdt, headsize);
+		memmove(newtail, oldtail, tailsize);
+	} else {
+		memmove(newtail, oldtail, tailsize);
+		memmove(buf, fdt, headsize);
+	}
+
+	fdt_set_off_dt_strings(buf, bufsize);
+	fdt_set_totalsize(buf, bufsize);
+
+	return 0;
+}
+
+int fdt_add_reservemap_entry(void *fdt, uint64_t addr, uint64_t size)
+{
+	struct fdt_reserve_entry *re;
+	int offset;
+
+	FDT_SW_CHECK_HEADER(fdt);
+
+	if (fdt_size_dt_struct(fdt))
+		return -FDT_ERR_BADSTATE;
+
+	offset = fdt_off_dt_struct(fdt);
+	if ((offset + sizeof(*re)) > fdt_totalsize(fdt))
+		return -FDT_ERR_NOSPACE;
+
+	re = (struct fdt_reserve_entry *)((char *)fdt + offset);
+	re->address = cpu_to_fdt64(addr);
+	re->size = cpu_to_fdt64(size);
+
+	fdt_set_off_dt_struct(fdt, offset + sizeof(*re));
+
+	return 0;
+}
+
+int fdt_finish_reservemap(void *fdt)
+{
+	return fdt_add_reservemap_entry(fdt, 0, 0);
+}
+
+int fdt_begin_node(void *fdt, const char *name)
+{
+	struct fdt_node_header *nh;
+	int namelen = strlen(name) + 1;
+
+	FDT_SW_CHECK_HEADER(fdt);
+
+	nh = fdt_grab_space_(fdt, sizeof(*nh) + FDT_TAGALIGN(namelen));
+	if (! nh)
+		return -FDT_ERR_NOSPACE;
+
+	nh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);
+	memcpy(nh->name, name, namelen);
+	return 0;
+}
+
+int fdt_end_node(void *fdt)
+{
+	fdt32_t *en;
+
+	FDT_SW_CHECK_HEADER(fdt);
+
+	en = fdt_grab_space_(fdt, FDT_TAGSIZE);
+	if (! en)
+		return -FDT_ERR_NOSPACE;
+
+	*en = cpu_to_fdt32(FDT_END_NODE);
+	return 0;
+}
+
+static int fdt_find_add_string_(void *fdt, const char *s)
+{
+	char *strtab = (char *)fdt + fdt_totalsize(fdt);
+	const char *p;
+	int strtabsize = fdt_size_dt_strings(fdt);
+	int len = strlen(s) + 1;
+	int struct_top, offset;
+
+	p = fdt_find_string_(strtab - strtabsize, strtabsize, s);
+	if (p)
+		return p - strtab;
+
+	/* Add it */
+	offset = -strtabsize - len;
+	struct_top = fdt_off_dt_struct(fdt) + fdt_size_dt_struct(fdt);
+	if (fdt_totalsize(fdt) + offset < struct_top)
+		return 0; /* no more room :( */
+
+	memcpy(strtab + offset, s, len);
+	fdt_set_size_dt_strings(fdt, strtabsize + len);
+	return offset;
+}
+
+int fdt_property_placeholder(void *fdt, const char *name, int len, void **valp)
+{
+	struct fdt_property *prop;
+	int nameoff;
+
+	FDT_SW_CHECK_HEADER(fdt);
+
+	nameoff = fdt_find_add_string_(fdt, name);
+	if (nameoff == 0)
+		return -FDT_ERR_NOSPACE;
+
+	prop = fdt_grab_space_(fdt, sizeof(*prop) + FDT_TAGALIGN(len));
+	if (! prop)
+		return -FDT_ERR_NOSPACE;
+
+	prop->tag = cpu_to_fdt32(FDT_PROP);
+	prop->nameoff = cpu_to_fdt32(nameoff);
+	prop->len = cpu_to_fdt32(len);
+	*valp = prop->data;
+	return 0;
+}
+
+int fdt_property(void *fdt, const char *name, const void *val, int len)
+{
+	void *ptr;
+	int ret;
+
+	ret = fdt_property_placeholder(fdt, name, len, &ptr);
+	if (ret)
+		return ret;
+	memcpy(ptr, val, len);
+	return 0;
+}
+
+int fdt_finish(void *fdt)
+{
+	char *p = (char *)fdt;
+	fdt32_t *end;
+	int oldstroffset, newstroffset;
+	uint32_t tag;
+	int offset, nextoffset;
+
+	FDT_SW_CHECK_HEADER(fdt);
+
+	/* Add terminator */
+	end = fdt_grab_space_(fdt, sizeof(*end));
+	if (! end)
+		return -FDT_ERR_NOSPACE;
+	*end = cpu_to_fdt32(FDT_END);
+
+	/* Relocate the string table */
+	oldstroffset = fdt_totalsize(fdt) - fdt_size_dt_strings(fdt);
+	newstroffset = fdt_off_dt_struct(fdt) + fdt_size_dt_struct(fdt);
+	memmove(p + newstroffset, p + oldstroffset, fdt_size_dt_strings(fdt));
+	fdt_set_off_dt_strings(fdt, newstroffset);
+
+	/* Walk the structure, correcting string offsets */
+	offset = 0;
+	while ((tag = fdt_next_tag(fdt, offset, &nextoffset)) != FDT_END) {
+		if (tag == FDT_PROP) {
+			struct fdt_property *prop =
+				fdt_offset_ptr_w_(fdt, offset);
+			int nameoff;
+
+			nameoff = fdt32_to_cpu(prop->nameoff);
+			nameoff += fdt_size_dt_strings(fdt);
+			prop->nameoff = cpu_to_fdt32(nameoff);
+		}
+		offset = nextoffset;
+	}
+	if (nextoffset < 0)
+		return nextoffset;
+
+	/* Finally, adjust the header */
+	fdt_set_totalsize(fdt, newstroffset + fdt_size_dt_strings(fdt));
+	fdt_set_magic(fdt, FDT_MAGIC);
+	return 0;
+}
diff -urN u-boot-1.1.6/common/fdt/fdt_wip.c u-boot-1.1.6_fdt/common/fdt/fdt_wip.c
--- u-boot-1.1.6/common/fdt/fdt_wip.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/fdt_wip.c	2018-10-22 15:54:19.601640154 +0800
@@ -0,0 +1,139 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+int fdt_setprop_inplace_namelen_partial(void *fdt, int nodeoffset,
+					const char *name, int namelen,
+					uint32_t idx, const void *val,
+					int len)
+{
+	void *propval;
+	int proplen;
+
+	propval = fdt_getprop_namelen_w(fdt, nodeoffset, name, namelen,
+					&proplen);
+	if (!propval)
+		return proplen;
+
+	if (proplen < (len + idx))
+		return -FDT_ERR_NOSPACE;
+
+	memcpy((char *)propval + idx, val, len);
+	return 0;
+}
+
+int fdt_setprop_inplace(void *fdt, int nodeoffset, const char *name,
+			const void *val, int len)
+{
+	const void *propval;
+	int proplen;
+
+	propval = fdt_getprop(fdt, nodeoffset, name, &proplen);
+	if (!propval)
+		return proplen;
+
+	if (proplen != len)
+		return -FDT_ERR_NOSPACE;
+
+	return fdt_setprop_inplace_namelen_partial(fdt, nodeoffset, name,
+						   strlen(name), 0,
+						   val, len);
+}
+
+static void fdt_nop_region_(void *start, int len)
+{
+	fdt32_t *p;
+
+	for (p = start; (char *)p < ((char *)start + len); p++)
+		*p = cpu_to_fdt32(FDT_NOP);
+}
+
+int fdt_nop_property(void *fdt, int nodeoffset, const char *name)
+{
+	struct fdt_property *prop;
+	int len;
+
+	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
+	if (!prop)
+		return len;
+
+	fdt_nop_region_(prop, len + sizeof(*prop));
+
+	return 0;
+}
+
+int fdt_node_end_offset_(void *fdt, int offset)
+{
+	int depth = 0;
+
+	while ((offset >= 0) && (depth >= 0))
+		offset = fdt_next_node(fdt, offset, &depth);
+
+	return offset;
+}
+
+int fdt_nop_node(void *fdt, int nodeoffset)
+{
+	int endoffset;
+
+	endoffset = fdt_node_end_offset_(fdt, nodeoffset);
+	if (endoffset < 0)
+		return endoffset;
+
+	fdt_nop_region_(fdt_offset_ptr_w(fdt, nodeoffset, 0),
+			endoffset - nodeoffset);
+	return 0;
+}
diff -urN u-boot-1.1.6/common/fdt/libfdt_env.h u-boot-1.1.6_fdt/common/fdt/libfdt_env.h
--- u-boot-1.1.6/common/fdt/libfdt_env.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/libfdt_env.h	2018-10-22 16:32:51.241597506 +0800
@@ -0,0 +1,139 @@
+#ifndef LIBFDT_ENV_H
+#define LIBFDT_ENV_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ * Copyright 2012 Kim Phillips, Freescale Semiconductor.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stddef.h>
+#include <stdint.h>
+//#include <stdlib.h>
+//#include <string.h>
+
+#ifdef __CHECKER__
+#define FDT_FORCE __attribute__((force))
+#define FDT_BITWISE __attribute__((bitwise))
+#else
+#define FDT_FORCE
+#define FDT_BITWISE
+#endif
+
+typedef uint16_t FDT_BITWISE fdt16_t;
+typedef uint32_t FDT_BITWISE fdt32_t;
+typedef uint64_t FDT_BITWISE fdt64_t;
+
+#define EXTRACT_BYTE(x, n)	((unsigned long long)((uint8_t *)&x)[n])
+#define CPU_TO_FDT16(x) ((EXTRACT_BYTE(x, 0) << 8) | EXTRACT_BYTE(x, 1))
+#define CPU_TO_FDT32(x) ((EXTRACT_BYTE(x, 0) << 24) | (EXTRACT_BYTE(x, 1) << 16) | \
+			 (EXTRACT_BYTE(x, 2) << 8) | EXTRACT_BYTE(x, 3))
+#define CPU_TO_FDT64(x) ((EXTRACT_BYTE(x, 0) << 56) | (EXTRACT_BYTE(x, 1) << 48) | \
+			 (EXTRACT_BYTE(x, 2) << 40) | (EXTRACT_BYTE(x, 3) << 32) | \
+			 (EXTRACT_BYTE(x, 4) << 24) | (EXTRACT_BYTE(x, 5) << 16) | \
+			 (EXTRACT_BYTE(x, 6) << 8) | EXTRACT_BYTE(x, 7))
+
+static inline uint16_t fdt16_to_cpu(fdt16_t x)
+{
+	return (FDT_FORCE uint16_t)CPU_TO_FDT16(x);
+}
+static inline fdt16_t cpu_to_fdt16(uint16_t x)
+{
+	return (FDT_FORCE fdt16_t)CPU_TO_FDT16(x);
+}
+
+static inline uint32_t fdt32_to_cpu(fdt32_t x)
+{
+	return (FDT_FORCE uint32_t)CPU_TO_FDT32(x);
+}
+static inline fdt32_t cpu_to_fdt32(uint32_t x)
+{
+	return (FDT_FORCE fdt32_t)CPU_TO_FDT32(x);
+}
+
+static inline uint64_t fdt64_to_cpu(fdt64_t x)
+{
+	return (FDT_FORCE uint64_t)CPU_TO_FDT64(x);
+}
+static inline fdt64_t cpu_to_fdt64(uint64_t x)
+{
+	return (FDT_FORCE fdt64_t)CPU_TO_FDT64(x);
+}
+#undef CPU_TO_FDT64
+#undef CPU_TO_FDT32
+#undef CPU_TO_FDT16
+#undef EXTRACT_BYTE
+
+#ifdef __APPLE__
+#include <AvailabilityMacros.h>
+
+/* strnlen() is not available on Mac OS < 10.7 */
+# if !defined(MAC_OS_X_VERSION_10_7) || (MAC_OS_X_VERSION_MAX_ALLOWED < \
+                                         MAC_OS_X_VERSION_10_7)
+
+#define strnlen fdt_strnlen
+
+/*
+ * fdt_strnlen: returns the length of a string or max_count - which ever is
+ * smallest.
+ * Input 1 string: the string whose size is to be determined
+ * Input 2 max_count: the maximum value returned by this function
+ * Output: length of the string or max_count (the smallest of the two)
+ */
+static inline size_t fdt_strnlen(const char *string, size_t max_count)
+{
+    const char *p = memchr(string, 0, max_count);
+    return p ? p - string : max_count;
+}
+
+#endif /* !defined(MAC_OS_X_VERSION_10_7) || (MAC_OS_X_VERSION_MAX_ALLOWED <
+          MAC_OS_X_VERSION_10_7) */
+
+#endif /* __APPLE__ */
+
+#endif /* LIBFDT_ENV_H */
diff -urN u-boot-1.1.6/common/fdt/libfdt.h u-boot-1.1.6_fdt/common/fdt/libfdt.h
--- u-boot-1.1.6/common/fdt/libfdt.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/libfdt.h	2018-10-22 16:21:54.825609616 +0800
@@ -0,0 +1,1918 @@
+#ifndef LIBFDT_H
+#define LIBFDT_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "libfdt_env.h"
+#include "fdt.h"
+
+#define int8_t		char
+#define int16_t		short
+#define int32_t		long
+#define int64_t		long long
+#define uint8_t		u_char
+#define uint16_t	u_short
+#define uint32_t	u_long
+#define uint64_t	unsigned long long
+#define t_scalar_t	int
+#define t_uscalar_t	unsigned int
+#define uintptr_t	unsigned long
+
+
+#define FDT_FIRST_SUPPORTED_VERSION	0x02
+#define FDT_LAST_SUPPORTED_VERSION	0x11
+
+/* Error codes: informative error codes */
+#define FDT_ERR_NOTFOUND	1
+	/* FDT_ERR_NOTFOUND: The requested node or property does not exist */
+#define FDT_ERR_EXISTS		2
+	/* FDT_ERR_EXISTS: Attempted to create a node or property which
+	 * already exists */
+#define FDT_ERR_NOSPACE		3
+	/* FDT_ERR_NOSPACE: Operation needed to expand the device
+	 * tree, but its buffer did not have sufficient space to
+	 * contain the expanded tree. Use fdt_open_into() to move the
+	 * device tree to a buffer with more space. */
+
+/* Error codes: codes for bad parameters */
+#define FDT_ERR_BADOFFSET	4
+	/* FDT_ERR_BADOFFSET: Function was passed a structure block
+	 * offset which is out-of-bounds, or which points to an
+	 * unsuitable part of the structure for the operation. */
+#define FDT_ERR_BADPATH		5
+	/* FDT_ERR_BADPATH: Function was passed a badly formatted path
+	 * (e.g. missing a leading / for a function which requires an
+	 * absolute path) */
+#define FDT_ERR_BADPHANDLE	6
+	/* FDT_ERR_BADPHANDLE: Function was passed an invalid phandle.
+	 * This can be caused either by an invalid phandle property
+	 * length, or the phandle value was either 0 or -1, which are
+	 * not permitted. */
+#define FDT_ERR_BADSTATE	7
+	/* FDT_ERR_BADSTATE: Function was passed an incomplete device
+	 * tree created by the sequential-write functions, which is
+	 * not sufficiently complete for the requested operation. */
+
+/* Error codes: codes for bad device tree blobs */
+#define FDT_ERR_TRUNCATED	8
+	/* FDT_ERR_TRUNCATED: Structure block of the given device tree
+	 * ends without an FDT_END tag. */
+#define FDT_ERR_BADMAGIC	9
+	/* FDT_ERR_BADMAGIC: Given "device tree" appears not to be a
+	 * device tree at all - it is missing the flattened device
+	 * tree magic number. */
+#define FDT_ERR_BADVERSION	10
+	/* FDT_ERR_BADVERSION: Given device tree has a version which
+	 * can't be handled by the requested operation.  For
+	 * read-write functions, this may mean that fdt_open_into() is
+	 * required to convert the tree to the expected version. */
+#define FDT_ERR_BADSTRUCTURE	11
+	/* FDT_ERR_BADSTRUCTURE: Given device tree has a corrupt
+	 * structure block or other serious error (e.g. misnested
+	 * nodes, or subnodes preceding properties). */
+#define FDT_ERR_BADLAYOUT	12
+	/* FDT_ERR_BADLAYOUT: For read-write functions, the given
+	 * device tree has it's sub-blocks in an order that the
+	 * function can't handle (memory reserve map, then structure,
+	 * then strings).  Use fdt_open_into() to reorganize the tree
+	 * into a form suitable for the read-write operations. */
+
+/* "Can't happen" error indicating a bug in libfdt */
+#define FDT_ERR_INTERNAL	13
+	/* FDT_ERR_INTERNAL: libfdt has failed an internal assertion.
+	 * Should never be returned, if it is, it indicates a bug in
+	 * libfdt itself. */
+
+/* Errors in device tree content */
+#define FDT_ERR_BADNCELLS	14
+	/* FDT_ERR_BADNCELLS: Device tree has a #address-cells, #size-cells
+	 * or similar property with a bad format or value */
+
+#define FDT_ERR_BADVALUE	15
+	/* FDT_ERR_BADVALUE: Device tree has a property with an unexpected
+	 * value. For example: a property expected to contain a string list
+	 * is not NUL-terminated within the length of its value. */
+
+#define FDT_ERR_BADOVERLAY	16
+	/* FDT_ERR_BADOVERLAY: The device tree overlay, while
+	 * correctly structured, cannot be applied due to some
+	 * unexpected or missing value, property or node. */
+
+#define FDT_ERR_NOPHANDLES	17
+	/* FDT_ERR_NOPHANDLES: The device tree doesn't have any
+	 * phandle available anymore without causing an overflow */
+
+#define FDT_ERR_MAX		17
+
+/**********************************************************************/
+/* Low-level functions (you probably don't need these)                */
+/**********************************************************************/
+
+#ifndef SWIG /* This function is not useful in Python */
+const void *fdt_offset_ptr(const void *fdt, int offset, unsigned int checklen);
+#endif
+static inline void *fdt_offset_ptr_w(void *fdt, int offset, int checklen)
+{
+	return (void *)(uintptr_t)fdt_offset_ptr(fdt, offset, checklen);
+}
+
+uint32_t fdt_next_tag(const void *fdt, int offset, int *nextoffset);
+
+/**********************************************************************/
+/* Traversal functions                                                */
+/**********************************************************************/
+
+int fdt_next_node(const void *fdt, int offset, int *depth);
+
+/**
+ * fdt_first_subnode() - get offset of first direct subnode
+ *
+ * @fdt:	FDT blob
+ * @offset:	Offset of node to check
+ * @return offset of first subnode, or -FDT_ERR_NOTFOUND if there is none
+ */
+int fdt_first_subnode(const void *fdt, int offset);
+
+/**
+ * fdt_next_subnode() - get offset of next direct subnode
+ *
+ * After first calling fdt_first_subnode(), call this function repeatedly to
+ * get direct subnodes of a parent node.
+ *
+ * @fdt:	FDT blob
+ * @offset:	Offset of previous subnode
+ * @return offset of next subnode, or -FDT_ERR_NOTFOUND if there are no more
+ * subnodes
+ */
+int fdt_next_subnode(const void *fdt, int offset);
+
+/**
+ * fdt_for_each_subnode - iterate over all subnodes of a parent
+ *
+ * @node:	child node (int, lvalue)
+ * @fdt:	FDT blob (const void *)
+ * @parent:	parent node (int)
+ *
+ * This is actually a wrapper around a for loop and would be used like so:
+ *
+ *	fdt_for_each_subnode(node, fdt, parent) {
+ *		Use node
+ *		...
+ *	}
+ *
+ *	if ((node < 0) && (node != -FDT_ERR_NOT_FOUND)) {
+ *		Error handling
+ *	}
+ *
+ * Note that this is implemented as a macro and @node is used as
+ * iterator in the loop. The parent variable be constant or even a
+ * literal.
+ *
+ */
+#define fdt_for_each_subnode(node, fdt, parent)		\
+	for (node = fdt_first_subnode(fdt, parent);	\
+	     node >= 0;					\
+	     node = fdt_next_subnode(fdt, node))
+
+/**********************************************************************/
+/* General functions                                                  */
+/**********************************************************************/
+#define fdt_get_header(fdt, field) \
+	(fdt32_to_cpu(((const struct fdt_header *)(fdt))->field))
+#define fdt_magic(fdt)			(fdt_get_header(fdt, magic))
+#define fdt_totalsize(fdt)		(fdt_get_header(fdt, totalsize))
+#define fdt_off_dt_struct(fdt)		(fdt_get_header(fdt, off_dt_struct))
+#define fdt_off_dt_strings(fdt)		(fdt_get_header(fdt, off_dt_strings))
+#define fdt_off_mem_rsvmap(fdt)		(fdt_get_header(fdt, off_mem_rsvmap))
+#define fdt_version(fdt)		(fdt_get_header(fdt, version))
+#define fdt_last_comp_version(fdt)	(fdt_get_header(fdt, last_comp_version))
+#define fdt_boot_cpuid_phys(fdt)	(fdt_get_header(fdt, boot_cpuid_phys))
+#define fdt_size_dt_strings(fdt)	(fdt_get_header(fdt, size_dt_strings))
+#define fdt_size_dt_struct(fdt)		(fdt_get_header(fdt, size_dt_struct))
+
+#define fdt_set_hdr_(name) \
+	static inline void fdt_set_##name(void *fdt, uint32_t val) \
+	{ \
+		struct fdt_header *fdth = (struct fdt_header *)fdt; \
+		fdth->name = cpu_to_fdt32(val); \
+	}
+fdt_set_hdr_(magic);
+fdt_set_hdr_(totalsize);
+fdt_set_hdr_(off_dt_struct);
+fdt_set_hdr_(off_dt_strings);
+fdt_set_hdr_(off_mem_rsvmap);
+fdt_set_hdr_(version);
+fdt_set_hdr_(last_comp_version);
+fdt_set_hdr_(boot_cpuid_phys);
+fdt_set_hdr_(size_dt_strings);
+fdt_set_hdr_(size_dt_struct);
+#undef fdt_set_hdr_
+
+/**
+ * fdt_check_header - sanity check a device tree or possible device tree
+ * @fdt: pointer to data which might be a flattened device tree
+ *
+ * fdt_check_header() checks that the given buffer contains what
+ * appears to be a flattened device tree with sane information in its
+ * header.
+ *
+ * returns:
+ *     0, if the buffer appears to contain a valid device tree
+ *     -FDT_ERR_BADMAGIC,
+ *     -FDT_ERR_BADVERSION,
+ *     -FDT_ERR_BADSTATE, standard meanings, as above
+ */
+int fdt_check_header(const void *fdt);
+
+/**
+ * fdt_move - move a device tree around in memory
+ * @fdt: pointer to the device tree to move
+ * @buf: pointer to memory where the device is to be moved
+ * @bufsize: size of the memory space at buf
+ *
+ * fdt_move() relocates, if possible, the device tree blob located at
+ * fdt to the buffer at buf of size bufsize.  The buffer may overlap
+ * with the existing device tree blob at fdt.  Therefore,
+ *     fdt_move(fdt, fdt, fdt_totalsize(fdt))
+ * should always succeed.
+ *
+ * returns:
+ *     0, on success
+ *     -FDT_ERR_NOSPACE, bufsize is insufficient to contain the device tree
+ *     -FDT_ERR_BADMAGIC,
+ *     -FDT_ERR_BADVERSION,
+ *     -FDT_ERR_BADSTATE, standard meanings
+ */
+int fdt_move(const void *fdt, void *buf, int bufsize);
+
+/**********************************************************************/
+/* Read-only functions                                                */
+/**********************************************************************/
+
+/**
+ * fdt_string - retrieve a string from the strings block of a device tree
+ * @fdt: pointer to the device tree blob
+ * @stroffset: offset of the string within the strings block (native endian)
+ *
+ * fdt_string() retrieves a pointer to a single string from the
+ * strings block of the device tree blob at fdt.
+ *
+ * returns:
+ *     a pointer to the string, on success
+ *     NULL, if stroffset is out of bounds
+ */
+const char *fdt_string(const void *fdt, int stroffset);
+
+/**
+ * fdt_get_max_phandle - retrieves the highest phandle in a tree
+ * @fdt: pointer to the device tree blob
+ *
+ * fdt_get_max_phandle retrieves the highest phandle in the given
+ * device tree. This will ignore badly formatted phandles, or phandles
+ * with a value of 0 or -1.
+ *
+ * returns:
+ *      the highest phandle on success
+ *      0, if no phandle was found in the device tree
+ *      -1, if an error occurred
+ */
+uint32_t fdt_get_max_phandle(const void *fdt);
+
+/**
+ * fdt_num_mem_rsv - retrieve the number of memory reserve map entries
+ * @fdt: pointer to the device tree blob
+ *
+ * Returns the number of entries in the device tree blob's memory
+ * reservation map.  This does not include the terminating 0,0 entry
+ * or any other (0,0) entries reserved for expansion.
+ *
+ * returns:
+ *     the number of entries
+ */
+int fdt_num_mem_rsv(const void *fdt);
+
+/**
+ * fdt_get_mem_rsv - retrieve one memory reserve map entry
+ * @fdt: pointer to the device tree blob
+ * @address, @size: pointers to 64-bit variables
+ *
+ * On success, *address and *size will contain the address and size of
+ * the n-th reserve map entry from the device tree blob, in
+ * native-endian format.
+ *
+ * returns:
+ *     0, on success
+ *     -FDT_ERR_BADMAGIC,
+ *     -FDT_ERR_BADVERSION,
+ *     -FDT_ERR_BADSTATE, standard meanings
+ */
+int fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size);
+
+/**
+ * fdt_subnode_offset_namelen - find a subnode based on substring
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ * @namelen: number of characters of name to consider
+ *
+ * Identical to fdt_subnode_offset(), but only examine the first
+ * namelen characters of name for matching the subnode name.  This is
+ * useful for finding subnodes based on a portion of a larger string,
+ * such as a full path.
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_subnode_offset_namelen(const void *fdt, int parentoffset,
+			       const char *name, int namelen);
+#endif
+/**
+ * fdt_subnode_offset - find a subnode of a given node
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ *
+ * fdt_subnode_offset() finds a subnode of the node at structure block
+ * offset parentoffset with the given name.  name may include a unit
+ * address, in which case fdt_subnode_offset() will find the subnode
+ * with that unit address, or the unit address may be omitted, in
+ * which case fdt_subnode_offset() will find an arbitrary subnode
+ * whose name excluding unit address matches the given name.
+ *
+ * returns:
+ *	structure block offset of the requested subnode (>=0), on success
+ *	-FDT_ERR_NOTFOUND, if the requested subnode does not exist
+ *	-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE
+ *		tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_subnode_offset(const void *fdt, int parentoffset, const char *name);
+
+/**
+ * fdt_path_offset_namelen - find a tree node by its full path
+ * @fdt: pointer to the device tree blob
+ * @path: full path of the node to locate
+ * @namelen: number of characters of path to consider
+ *
+ * Identical to fdt_path_offset(), but only consider the first namelen
+ * characters of path as the path name.
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_path_offset_namelen(const void *fdt, const char *path, int namelen);
+#endif
+
+/**
+ * fdt_path_offset - find a tree node by its full path
+ * @fdt: pointer to the device tree blob
+ * @path: full path of the node to locate
+ *
+ * fdt_path_offset() finds a node of a given path in the device tree.
+ * Each path component may omit the unit address portion, but the
+ * results of this are undefined if any such path component is
+ * ambiguous (that is if there are multiple nodes at the relevant
+ * level matching the given component, differentiated only by unit
+ * address).
+ *
+ * returns:
+ *	structure block offset of the node with the requested path (>=0), on
+ *		success
+ *	-FDT_ERR_BADPATH, given path does not begin with '/' or is invalid
+ *	-FDT_ERR_NOTFOUND, if the requested node does not exist
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_path_offset(const void *fdt, const char *path);
+
+/**
+ * fdt_get_name - retrieve the name of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of the starting node
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_get_name() retrieves the name (including unit address) of the
+ * device tree node at structure block offset nodeoffset.  If lenp is
+ * non-NULL, the length of this name is also returned, in the integer
+ * pointed to by lenp.
+ *
+ * returns:
+ *	pointer to the node's name, on success
+ *		If lenp is non-NULL, *lenp contains the length of that name
+ *			(>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL *lenp contains an error code (<0):
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE
+ *			tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE, standard meanings
+ */
+const char *fdt_get_name(const void *fdt, int nodeoffset, int *lenp);
+
+/**
+ * fdt_first_property_offset - find the offset of a node's first property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of a node
+ *
+ * fdt_first_property_offset() finds the first property of the node at
+ * the given structure block offset.
+ *
+ * returns:
+ *	structure block offset of the property (>=0), on success
+ *	-FDT_ERR_NOTFOUND, if the requested node has no properties
+ *	-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_BEGIN_NODE tag
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_first_property_offset(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_next_property_offset - step through a node's properties
+ * @fdt: pointer to the device tree blob
+ * @offset: structure block offset of a property
+ *
+ * fdt_next_property_offset() finds the property immediately after the
+ * one at the given structure block offset.  This will be a property
+ * of the same node as the given property.
+ *
+ * returns:
+ *	structure block offset of the next property (>=0), on success
+ *	-FDT_ERR_NOTFOUND, if the given property is the last in its node
+ *	-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_PROP tag
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_next_property_offset(const void *fdt, int offset);
+
+/**
+ * fdt_for_each_property_offset - iterate over all properties of a node
+ *
+ * @property_offset:	property offset (int, lvalue)
+ * @fdt:		FDT blob (const void *)
+ * @node:		node offset (int)
+ *
+ * This is actually a wrapper around a for loop and would be used like so:
+ *
+ *	fdt_for_each_property_offset(property, fdt, node) {
+ *		Use property
+ *		...
+ *	}
+ *
+ *	if ((property < 0) && (property != -FDT_ERR_NOT_FOUND)) {
+ *		Error handling
+ *	}
+ *
+ * Note that this is implemented as a macro and property is used as
+ * iterator in the loop. The node variable can be constant or even a
+ * literal.
+ */
+#define fdt_for_each_property_offset(property, fdt, node)	\
+	for (property = fdt_first_property_offset(fdt, node);	\
+	     property >= 0;					\
+	     property = fdt_next_property_offset(fdt, property))
+
+/**
+ * fdt_get_property_by_offset - retrieve the property at a given offset
+ * @fdt: pointer to the device tree blob
+ * @offset: offset of the property to retrieve
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_get_property_by_offset() retrieves a pointer to the
+ * fdt_property structure within the device tree blob at the given
+ * offset.  If lenp is non-NULL, the length of the property value is
+ * also returned, in the integer pointed to by lenp.
+ *
+ * Note that this code only works on device tree versions >= 16. fdt_getprop()
+ * works on all versions.
+ *
+ * returns:
+ *	pointer to the structure representing the property
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+const struct fdt_property *fdt_get_property_by_offset(const void *fdt,
+						      int offset,
+						      int *lenp);
+
+/**
+ * fdt_get_property_namelen - find a property based on substring
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @namelen: number of characters of name to consider
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * Identical to fdt_get_property(), but only examine the first namelen
+ * characters of name for matching the property name.
+ */
+#ifndef SWIG /* Not available in Python */
+const struct fdt_property *fdt_get_property_namelen(const void *fdt,
+						    int nodeoffset,
+						    const char *name,
+						    int namelen, int *lenp);
+#endif
+
+/**
+ * fdt_get_property - find a given property in a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_get_property() retrieves a pointer to the fdt_property
+ * structure within the device tree blob corresponding to the property
+ * named 'name' of the node at offset nodeoffset.  If lenp is
+ * non-NULL, the length of the property value is also returned, in the
+ * integer pointed to by lenp.
+ *
+ * returns:
+ *	pointer to the structure representing the property
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_NOTFOUND, node does not have named property
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE
+ *			tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+const struct fdt_property *fdt_get_property(const void *fdt, int nodeoffset,
+					    const char *name, int *lenp);
+static inline struct fdt_property *fdt_get_property_w(void *fdt, int nodeoffset,
+						      const char *name,
+						      int *lenp)
+{
+	return (struct fdt_property *)(uintptr_t)
+		fdt_get_property(fdt, nodeoffset, name, lenp);
+}
+
+/**
+ * fdt_getprop_by_offset - retrieve the value of a property at a given offset
+ * @fdt: pointer to the device tree blob
+ * @ffset: offset of the property to read
+ * @namep: pointer to a string variable (will be overwritten) or NULL
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_getprop_by_offset() retrieves a pointer to the value of the
+ * property at structure block offset 'offset' (this will be a pointer
+ * to within the device blob itself, not a copy of the value).  If
+ * lenp is non-NULL, the length of the property value is also
+ * returned, in the integer pointed to by lenp.  If namep is non-NULL,
+ * the property's namne will also be returned in the char * pointed to
+ * by namep (this will be a pointer to within the device tree's string
+ * block, not a new copy of the name).
+ *
+ * returns:
+ *	pointer to the property's value
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *		if namep is non-NULL *namep contiains a pointer to the property
+ *		name.
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+#ifndef SWIG /* This function is not useful in Python */
+const void *fdt_getprop_by_offset(const void *fdt, int offset,
+				  const char **namep, int *lenp);
+#endif
+
+/**
+ * fdt_getprop_namelen - get property value based on substring
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @namelen: number of characters of name to consider
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * Identical to fdt_getprop(), but only examine the first namelen
+ * characters of name for matching the property name.
+ */
+#ifndef SWIG /* Not available in Python */
+const void *fdt_getprop_namelen(const void *fdt, int nodeoffset,
+				const char *name, int namelen, int *lenp);
+static inline void *fdt_getprop_namelen_w(void *fdt, int nodeoffset,
+					  const char *name, int namelen,
+					  int *lenp)
+{
+	return (void *)(uintptr_t)fdt_getprop_namelen(fdt, nodeoffset, name,
+						      namelen, lenp);
+}
+#endif
+
+/**
+ * fdt_getprop - retrieve the value of a given property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_getprop() retrieves a pointer to the value of the property
+ * named 'name' of the node at offset nodeoffset (this will be a
+ * pointer to within the device blob itself, not a copy of the value).
+ * If lenp is non-NULL, the length of the property value is also
+ * returned, in the integer pointed to by lenp.
+ *
+ * returns:
+ *	pointer to the property's value
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_NOTFOUND, node does not have named property
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE
+ *			tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+const void *fdt_getprop(const void *fdt, int nodeoffset,
+			const char *name, int *lenp);
+static inline void *fdt_getprop_w(void *fdt, int nodeoffset,
+				  const char *name, int *lenp)
+{
+	return (void *)(uintptr_t)fdt_getprop(fdt, nodeoffset, name, lenp);
+}
+
+/**
+ * fdt_get_phandle - retrieve the phandle of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of the node
+ *
+ * fdt_get_phandle() retrieves the phandle of the device tree node at
+ * structure block offset nodeoffset.
+ *
+ * returns:
+ *	the phandle of the node at nodeoffset, on success (!= 0, != -1)
+ *	0, if the node has no phandle, or another error occurs
+ */
+uint32_t fdt_get_phandle(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_get_alias_namelen - get alias based on substring
+ * @fdt: pointer to the device tree blob
+ * @name: name of the alias th look up
+ * @namelen: number of characters of name to consider
+ *
+ * Identical to fdt_get_alias(), but only examine the first namelen
+ * characters of name for matching the alias name.
+ */
+#ifndef SWIG /* Not available in Python */
+const char *fdt_get_alias_namelen(const void *fdt,
+				  const char *name, int namelen);
+#endif
+
+/**
+ * fdt_get_alias - retrieve the path referenced by a given alias
+ * @fdt: pointer to the device tree blob
+ * @name: name of the alias th look up
+ *
+ * fdt_get_alias() retrieves the value of a given alias.  That is, the
+ * value of the property named 'name' in the node /aliases.
+ *
+ * returns:
+ *	a pointer to the expansion of the alias named 'name', if it exists
+ *	NULL, if the given alias or the /aliases node does not exist
+ */
+const char *fdt_get_alias(const void *fdt, const char *name);
+
+/**
+ * fdt_get_path - determine the full path of a node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose path to find
+ * @buf: character buffer to contain the returned path (will be overwritten)
+ * @buflen: size of the character buffer at buf
+ *
+ * fdt_get_path() computes the full path of the node at offset
+ * nodeoffset, and records that path in the buffer at buf.
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset.
+ *
+ * returns:
+ *	0, on success
+ *		buf contains the absolute path of the node at
+ *		nodeoffset, as a NUL-terminated string.
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_NOSPACE, the path of the given node is longer than (bufsize-1)
+ *		characters and will not fit in the given buffer.
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_get_path(const void *fdt, int nodeoffset, char *buf, int buflen);
+
+/**
+ * fdt_supernode_atdepth_offset - find a specific ancestor of a node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose parent to find
+ * @supernodedepth: depth of the ancestor to find
+ * @nodedepth: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_supernode_atdepth_offset() finds an ancestor of the given node
+ * at a specific depth from the root (where the root itself has depth
+ * 0, its immediate subnodes depth 1 and so forth).  So
+ *	fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, NULL);
+ * will always return 0, the offset of the root node.  If the node at
+ * nodeoffset has depth D, then:
+ *	fdt_supernode_atdepth_offset(fdt, nodeoffset, D, NULL);
+ * will return nodeoffset itself.
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset.
+ *
+ * returns:
+ *	structure block offset of the node at node offset's ancestor
+ *		of depth supernodedepth (>=0), on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_NOTFOUND, supernodedepth was greater than the depth of
+ *		nodeoffset
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_supernode_atdepth_offset(const void *fdt, int nodeoffset,
+				 int supernodedepth, int *nodedepth);
+
+/**
+ * fdt_node_depth - find the depth of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose parent to find
+ *
+ * fdt_node_depth() finds the depth of a given node.  The root node
+ * has depth 0, its immediate subnodes depth 1 and so forth.
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset.
+ *
+ * returns:
+ *	depth of the node at nodeoffset (>=0), on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_depth(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_parent_offset - find the parent of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose parent to find
+ *
+ * fdt_parent_offset() locates the parent node of a given node (that
+ * is, it finds the offset of the node which contains the node at
+ * nodeoffset as a subnode).
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset, *twice*.
+ *
+ * returns:
+ *	structure block offset of the parent of the node at nodeoffset
+ *		(>=0), on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_parent_offset(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_node_offset_by_prop_value - find nodes with a given property value
+ * @fdt: pointer to the device tree blob
+ * @startoffset: only find nodes after this offset
+ * @propname: property name to check
+ * @propval: property value to search for
+ * @proplen: length of the value in propval
+ *
+ * fdt_node_offset_by_prop_value() returns the offset of the first
+ * node after startoffset, which has a property named propname whose
+ * value is of length proplen and has value equal to propval; or if
+ * startoffset is -1, the very first such node in the tree.
+ *
+ * To iterate through all nodes matching the criterion, the following
+ * idiom can be used:
+ *	offset = fdt_node_offset_by_prop_value(fdt, -1, propname,
+ *					       propval, proplen);
+ *	while (offset != -FDT_ERR_NOTFOUND) {
+ *		// other code here
+ *		offset = fdt_node_offset_by_prop_value(fdt, offset, propname,
+ *						       propval, proplen);
+ *	}
+ *
+ * Note the -1 in the first call to the function, if 0 is used here
+ * instead, the function will never locate the root node, even if it
+ * matches the criterion.
+ *
+ * returns:
+ *	structure block offset of the located node (>= 0, >startoffset),
+ *		 on success
+ *	-FDT_ERR_NOTFOUND, no node matching the criterion exists in the
+ *		tree after startoffset
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_offset_by_prop_value(const void *fdt, int startoffset,
+				  const char *propname,
+				  const void *propval, int proplen);
+
+/**
+ * fdt_node_offset_by_phandle - find the node with a given phandle
+ * @fdt: pointer to the device tree blob
+ * @phandle: phandle value
+ *
+ * fdt_node_offset_by_phandle() returns the offset of the node
+ * which has the given phandle value.  If there is more than one node
+ * in the tree with the given phandle (an invalid tree), results are
+ * undefined.
+ *
+ * returns:
+ *	structure block offset of the located node (>= 0), on success
+ *	-FDT_ERR_NOTFOUND, no node with that phandle exists
+ *	-FDT_ERR_BADPHANDLE, given phandle value was invalid (0 or -1)
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle);
+
+/**
+ * fdt_node_check_compatible: check a node's compatible property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @compatible: string to match against
+ *
+ *
+ * fdt_node_check_compatible() returns 0 if the given node contains a
+ * 'compatible' property with the given string as one of its elements,
+ * it returns non-zero otherwise, or on error.
+ *
+ * returns:
+ *	0, if the node has a 'compatible' property listing the given string
+ *	1, if the node has a 'compatible' property, but it does not list
+ *		the given string
+ *	-FDT_ERR_NOTFOUND, if the given node has no 'compatible' property
+ *	-FDT_ERR_BADOFFSET, if nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_check_compatible(const void *fdt, int nodeoffset,
+			      const char *compatible);
+
+/**
+ * fdt_node_offset_by_compatible - find nodes with a given 'compatible' value
+ * @fdt: pointer to the device tree blob
+ * @startoffset: only find nodes after this offset
+ * @compatible: 'compatible' string to match against
+ *
+ * fdt_node_offset_by_compatible() returns the offset of the first
+ * node after startoffset, which has a 'compatible' property which
+ * lists the given compatible string; or if startoffset is -1, the
+ * very first such node in the tree.
+ *
+ * To iterate through all nodes matching the criterion, the following
+ * idiom can be used:
+ *	offset = fdt_node_offset_by_compatible(fdt, -1, compatible);
+ *	while (offset != -FDT_ERR_NOTFOUND) {
+ *		// other code here
+ *		offset = fdt_node_offset_by_compatible(fdt, offset, compatible);
+ *	}
+ *
+ * Note the -1 in the first call to the function, if 0 is used here
+ * instead, the function will never locate the root node, even if it
+ * matches the criterion.
+ *
+ * returns:
+ *	structure block offset of the located node (>= 0, >startoffset),
+ *		 on success
+ *	-FDT_ERR_NOTFOUND, no node matching the criterion exists in the
+ *		tree after startoffset
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_offset_by_compatible(const void *fdt, int startoffset,
+				  const char *compatible);
+
+/**
+ * fdt_stringlist_contains - check a string list property for a string
+ * @strlist: Property containing a list of strings to check
+ * @listlen: Length of property
+ * @str: String to search for
+ *
+ * This is a utility function provided for convenience. The list contains
+ * one or more strings, each terminated by \0, as is found in a device tree
+ * "compatible" property.
+ *
+ * @return: 1 if the string is found in the list, 0 not found, or invalid list
+ */
+int fdt_stringlist_contains(const char *strlist, int listlen, const char *str);
+
+/**
+ * fdt_stringlist_count - count the number of strings in a string list
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @property: name of the property containing the string list
+ * @return:
+ *   the number of strings in the given property
+ *   -FDT_ERR_BADVALUE if the property value is not NUL-terminated
+ *   -FDT_ERR_NOTFOUND if the property does not exist
+ */
+int fdt_stringlist_count(const void *fdt, int nodeoffset, const char *property);
+
+/**
+ * fdt_stringlist_search - find a string in a string list and return its index
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @property: name of the property containing the string list
+ * @string: string to look up in the string list
+ *
+ * Note that it is possible for this function to succeed on property values
+ * that are not NUL-terminated. That's because the function will stop after
+ * finding the first occurrence of @string. This can for example happen with
+ * small-valued cell properties, such as #address-cells, when searching for
+ * the empty string.
+ *
+ * @return:
+ *   the index of the string in the list of strings
+ *   -FDT_ERR_BADVALUE if the property value is not NUL-terminated
+ *   -FDT_ERR_NOTFOUND if the property does not exist or does not contain
+ *                     the given string
+ */
+int fdt_stringlist_search(const void *fdt, int nodeoffset, const char *property,
+			  const char *string);
+
+/**
+ * fdt_stringlist_get() - obtain the string at a given index in a string list
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @property: name of the property containing the string list
+ * @index: index of the string to return
+ * @lenp: return location for the string length or an error code on failure
+ *
+ * Note that this will successfully extract strings from properties with
+ * non-NUL-terminated values. For example on small-valued cell properties
+ * this function will return the empty string.
+ *
+ * If non-NULL, the length of the string (on success) or a negative error-code
+ * (on failure) will be stored in the integer pointer to by lenp.
+ *
+ * @return:
+ *   A pointer to the string at the given index in the string list or NULL on
+ *   failure. On success the length of the string will be stored in the memory
+ *   location pointed to by the lenp parameter, if non-NULL. On failure one of
+ *   the following negative error codes will be returned in the lenp parameter
+ *   (if non-NULL):
+ *     -FDT_ERR_BADVALUE if the property value is not NUL-terminated
+ *     -FDT_ERR_NOTFOUND if the property does not exist
+ */
+const char *fdt_stringlist_get(const void *fdt, int nodeoffset,
+			       const char *property, int index,
+			       int *lenp);
+
+/**********************************************************************/
+/* Read-only functions (addressing related)                           */
+/**********************************************************************/
+
+/**
+ * FDT_MAX_NCELLS - maximum value for #address-cells and #size-cells
+ *
+ * This is the maximum value for #address-cells, #size-cells and
+ * similar properties that will be processed by libfdt.  IEE1275
+ * requires that OF implementations handle values up to 4.
+ * Implementations may support larger values, but in practice higher
+ * values aren't used.
+ */
+#define FDT_MAX_NCELLS		4
+
+/**
+ * fdt_address_cells - retrieve address size for a bus represented in the tree
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to find the address size for
+ *
+ * When the node has a valid #address-cells property, returns its value.
+ *
+ * returns:
+ *	0 <= n < FDT_MAX_NCELLS, on success
+ *      2, if the node has no #address-cells property
+ *      -FDT_ERR_BADNCELLS, if the node has a badly formatted or invalid
+ *		#address-cells property
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_address_cells(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_size_cells - retrieve address range size for a bus represented in the
+ *                  tree
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to find the address range size for
+ *
+ * When the node has a valid #size-cells property, returns its value.
+ *
+ * returns:
+ *	0 <= n < FDT_MAX_NCELLS, on success
+ *      2, if the node has no #address-cells property
+ *      -FDT_ERR_BADNCELLS, if the node has a badly formatted or invalid
+ *		#size-cells property
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_size_cells(const void *fdt, int nodeoffset);
+
+
+/**********************************************************************/
+/* Write-in-place functions                                           */
+/**********************************************************************/
+
+/**
+ * fdt_setprop_inplace_namelen_partial - change a property's value,
+ *                                       but not its size
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @namelen: number of characters of name to consider
+ * @idx: index of the property to change in the array
+ * @val: pointer to data to replace the property value with
+ * @len: length of the property value
+ *
+ * Identical to fdt_setprop_inplace(), but modifies the given property
+ * starting from the given index, and using only the first characters
+ * of the name. It is useful when you want to manipulate only one value of
+ * an array and you have a string that doesn't end with \0.
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_setprop_inplace_namelen_partial(void *fdt, int nodeoffset,
+					const char *name, int namelen,
+					uint32_t idx, const void *val,
+					int len);
+#endif
+
+/**
+ * fdt_setprop_inplace - change a property's value, but not its size
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: pointer to data to replace the property value with
+ * @len: length of the property value
+ *
+ * fdt_setprop_inplace() replaces the value of a given property with
+ * the data in val, of length len.  This function cannot change the
+ * size of a property, and so will only work if len is equal to the
+ * current length of the property.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the given property value, and will not alter or move any other part
+ * of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, if len is not equal to the property's current length
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_setprop_inplace(void *fdt, int nodeoffset, const char *name,
+			const void *val, int len);
+#endif
+
+/**
+ * fdt_setprop_inplace_u32 - change the value of a 32-bit integer property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 32-bit integer value to replace the property with
+ *
+ * fdt_setprop_inplace_u32() replaces the value of a given property
+ * with the 32-bit integer value in val, converting val to big-endian
+ * if necessary.  This function cannot change the size of a property,
+ * and so will only work if the property already exists and has length
+ * 4.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the given property value, and will not alter or move any other part
+ * of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, if the property's length is not equal to 4
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_inplace_u32(void *fdt, int nodeoffset,
+					  const char *name, uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_setprop_inplace(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_inplace_u64 - change the value of a 64-bit integer property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 64-bit integer value to replace the property with
+ *
+ * fdt_setprop_inplace_u64() replaces the value of a given property
+ * with the 64-bit integer value in val, converting val to big-endian
+ * if necessary.  This function cannot change the size of a property,
+ * and so will only work if the property already exists and has length
+ * 8.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the given property value, and will not alter or move any other part
+ * of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, if the property's length is not equal to 8
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_inplace_u64(void *fdt, int nodeoffset,
+					  const char *name, uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_setprop_inplace(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_inplace_cell - change the value of a single-cell property
+ *
+ * This is an alternative name for fdt_setprop_inplace_u32()
+ */
+static inline int fdt_setprop_inplace_cell(void *fdt, int nodeoffset,
+					   const char *name, uint32_t val)
+{
+	return fdt_setprop_inplace_u32(fdt, nodeoffset, name, val);
+}
+
+/**
+ * fdt_nop_property - replace a property with nop tags
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to nop
+ * @name: name of the property to nop
+ *
+ * fdt_nop_property() will replace a given property's representation
+ * in the blob with FDT_NOP tags, effectively removing it from the
+ * tree.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the property, and will not alter or move any other part of the
+ * tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_nop_property(void *fdt, int nodeoffset, const char *name);
+
+/**
+ * fdt_nop_node - replace a node (subtree) with nop tags
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to nop
+ *
+ * fdt_nop_node() will replace a given node's representation in the
+ * blob, including all its subnodes, if any, with FDT_NOP tags,
+ * effectively removing it from the tree.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the node and its properties and subnodes, and will not alter or
+ * move any other part of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_nop_node(void *fdt, int nodeoffset);
+
+/**********************************************************************/
+/* Sequential write functions                                         */
+/**********************************************************************/
+
+int fdt_create(void *buf, int bufsize);
+int fdt_resize(void *fdt, void *buf, int bufsize);
+int fdt_add_reservemap_entry(void *fdt, uint64_t addr, uint64_t size);
+int fdt_finish_reservemap(void *fdt);
+int fdt_begin_node(void *fdt, const char *name);
+int fdt_property(void *fdt, const char *name, const void *val, int len);
+static inline int fdt_property_u32(void *fdt, const char *name, uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_property(fdt, name, &tmp, sizeof(tmp));
+}
+static inline int fdt_property_u64(void *fdt, const char *name, uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_property(fdt, name, &tmp, sizeof(tmp));
+}
+
+#ifndef SWIG /* Not available in Python */
+static inline int fdt_property_cell(void *fdt, const char *name, uint32_t val)
+{
+	return fdt_property_u32(fdt, name, val);
+}
+#endif
+
+/**
+ * fdt_property_placeholder - add a new property and return a ptr to its value
+ *
+ * @fdt: pointer to the device tree blob
+ * @name: name of property to add
+ * @len: length of property value in bytes
+ * @valp: returns a pointer to where where the value should be placed
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_NOSPACE, standard meanings
+ */
+int fdt_property_placeholder(void *fdt, const char *name, int len, void **valp);
+
+#define fdt_property_string(fdt, name, str) \
+	fdt_property(fdt, name, str, strlen(str)+1)
+int fdt_end_node(void *fdt);
+int fdt_finish(void *fdt);
+
+/**********************************************************************/
+/* Read-write functions                                               */
+/**********************************************************************/
+
+int fdt_create_empty_tree(void *buf, int bufsize);
+int fdt_open_into(const void *fdt, void *buf, int bufsize);
+int fdt_pack(void *fdt);
+
+/**
+ * fdt_add_mem_rsv - add one memory reserve map entry
+ * @fdt: pointer to the device tree blob
+ * @address, @size: 64-bit values (native endian)
+ *
+ * Adds a reserve map entry to the given blob reserving a region at
+ * address address of length size.
+ *
+ * This function will insert data into the reserve map and will
+ * therefore change the indexes of some entries in the table.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new reservation entry
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_add_mem_rsv(void *fdt, uint64_t address, uint64_t size);
+
+/**
+ * fdt_del_mem_rsv - remove a memory reserve map entry
+ * @fdt: pointer to the device tree blob
+ * @n: entry to remove
+ *
+ * fdt_del_mem_rsv() removes the n-th memory reserve map entry from
+ * the blob.
+ *
+ * This function will delete data from the reservation table and will
+ * therefore change the indexes of some entries in the table.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOTFOUND, there is no entry of the given index (i.e. there
+ *		are less than n+1 reserve map entries)
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_del_mem_rsv(void *fdt, int n);
+
+/**
+ * fdt_set_name - change the name of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of a node
+ * @name: name to give the node
+ *
+ * fdt_set_name() replaces the name (including unit address, if any)
+ * of the given node with the given string.  NOTE: this function can't
+ * efficiently check if the new name is unique amongst the given
+ * node's siblings; results are undefined if this function is invoked
+ * with a name equal to one of the given node's siblings.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob
+ *		to contain the new name
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE, standard meanings
+ */
+int fdt_set_name(void *fdt, int nodeoffset, const char *name);
+
+/**
+ * fdt_setprop - create or change a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: pointer to data to set the property value to
+ * @len: length of the property value
+ *
+ * fdt_setprop() sets the value of the named property in the given
+ * node to the given value and length, creating the property if it
+ * does not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_setprop(void *fdt, int nodeoffset, const char *name,
+		const void *val, int len);
+
+/**
+ * fdt_setprop_placeholder - allocate space for a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @len: length of the property value
+ * @prop_data: return pointer to property data
+ *
+ * fdt_setprop_placeholer() allocates the named property in the given node.
+ * If the property exists it is resized. In either case a pointer to the
+ * property data is returned.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_setprop_placeholder(void *fdt, int nodeoffset, const char *name,
+			    int len, void **prop_data);
+
+/**
+ * fdt_setprop_u32 - set a property to a 32-bit integer
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 32-bit integer value for the property (native endian)
+ *
+ * fdt_setprop_u32() sets the value of the named property in the given
+ * node to the given 32-bit integer value (converting to big-endian if
+ * necessary), or creates a new property with that value if it does
+ * not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_u32(void *fdt, int nodeoffset, const char *name,
+				  uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_setprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_u64 - set a property to a 64-bit integer
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 64-bit integer value for the property (native endian)
+ *
+ * fdt_setprop_u64() sets the value of the named property in the given
+ * node to the given 64-bit integer value (converting to big-endian if
+ * necessary), or creates a new property with that value if it does
+ * not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_u64(void *fdt, int nodeoffset, const char *name,
+				  uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_setprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_cell - set a property to a single cell value
+ *
+ * This is an alternative name for fdt_setprop_u32()
+ */
+static inline int fdt_setprop_cell(void *fdt, int nodeoffset, const char *name,
+				   uint32_t val)
+{
+	return fdt_setprop_u32(fdt, nodeoffset, name, val);
+}
+
+/**
+ * fdt_setprop_string - set a property to a string value
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @str: string value for the property
+ *
+ * fdt_setprop_string() sets the value of the named property in the
+ * given node to the given string value (using the length of the
+ * string to determine the new length of the property), or creates a
+ * new property with that value if it does not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#define fdt_setprop_string(fdt, nodeoffset, name, str) \
+	fdt_setprop((fdt), (nodeoffset), (name), (str), strlen(str)+1)
+
+
+/**
+ * fdt_setprop_empty - set a property to an empty value
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ *
+ * fdt_setprop_empty() sets the value of the named property in the
+ * given node to an empty (zero length) value, or creates a new empty
+ * property if it does not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#define fdt_setprop_empty(fdt, nodeoffset, name) \
+	fdt_setprop((fdt), (nodeoffset), (name), NULL, 0)
+
+/**
+ * fdt_appendprop - append to or create a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to append to
+ * @val: pointer to data to append to the property value
+ * @len: length of the data to append to the property value
+ *
+ * fdt_appendprop() appends the value to the named property in the
+ * given node, creating the property if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_appendprop(void *fdt, int nodeoffset, const char *name,
+		   const void *val, int len);
+
+/**
+ * fdt_appendprop_u32 - append a 32-bit integer value to a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 32-bit integer value to append to the property (native endian)
+ *
+ * fdt_appendprop_u32() appends the given 32-bit integer value
+ * (converting to big-endian if necessary) to the value of the named
+ * property in the given node, or creates a new property with that
+ * value if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_appendprop_u32(void *fdt, int nodeoffset,
+				     const char *name, uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_appendprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_appendprop_u64 - append a 64-bit integer value to a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 64-bit integer value to append to the property (native endian)
+ *
+ * fdt_appendprop_u64() appends the given 64-bit integer value
+ * (converting to big-endian if necessary) to the value of the named
+ * property in the given node, or creates a new property with that
+ * value if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_appendprop_u64(void *fdt, int nodeoffset,
+				     const char *name, uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_appendprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_appendprop_cell - append a single cell value to a property
+ *
+ * This is an alternative name for fdt_appendprop_u32()
+ */
+static inline int fdt_appendprop_cell(void *fdt, int nodeoffset,
+				      const char *name, uint32_t val)
+{
+	return fdt_appendprop_u32(fdt, nodeoffset, name, val);
+}
+
+/**
+ * fdt_appendprop_string - append a string to a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @str: string value to append to the property
+ *
+ * fdt_appendprop_string() appends the given string to the value of
+ * the named property in the given node, or creates a new property
+ * with that value if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#define fdt_appendprop_string(fdt, nodeoffset, name, str) \
+	fdt_appendprop((fdt), (nodeoffset), (name), (str), strlen(str)+1)
+
+/**
+ * fdt_delprop - delete a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to nop
+ * @name: name of the property to nop
+ *
+ * fdt_del_property() will delete the given property.
+ *
+ * This function will delete data from the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_delprop(void *fdt, int nodeoffset, const char *name);
+
+/**
+ * fdt_add_subnode_namelen - creates a new node based on substring
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ * @namelen: number of characters of name to consider
+ *
+ * Identical to fdt_add_subnode(), but use only the first namelen
+ * characters of name as the name of the new node.  This is useful for
+ * creating subnodes based on a portion of a larger string, such as a
+ * full path.
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_add_subnode_namelen(void *fdt, int parentoffset,
+			    const char *name, int namelen);
+#endif
+
+/**
+ * fdt_add_subnode - creates a new node
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ *
+ * fdt_add_subnode() creates a new node as a subnode of the node at
+ * structure block offset parentoffset, with the given name (which
+ * should include the unit address, if any).
+ *
+ * This function will insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+
+ * returns:
+ *	structure block offset of the created nodeequested subnode (>=0), on
+ *		success
+ *	-FDT_ERR_NOTFOUND, if the requested subnode does not exist
+ *	-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE
+ *		tag
+ *	-FDT_ERR_EXISTS, if the node at parentoffset already has a subnode of
+ *		the given name
+ *	-FDT_ERR_NOSPACE, if there is insufficient free space in the
+ *		blob to contain the new node
+ *	-FDT_ERR_NOSPACE
+ *	-FDT_ERR_BADLAYOUT
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_add_subnode(void *fdt, int parentoffset, const char *name);
+
+/**
+ * fdt_del_node - delete a node (subtree)
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to nop
+ *
+ * fdt_del_node() will remove the given node, including all its
+ * subnodes if any, from the blob.
+ *
+ * This function will delete data from the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_del_node(void *fdt, int nodeoffset);
+
+/**
+ * fdt_overlay_apply - Applies a DT overlay on a base DT
+ * @fdt: pointer to the base device tree blob
+ * @fdto: pointer to the device tree overlay blob
+ *
+ * fdt_overlay_apply() will apply the given device tree overlay on the
+ * given base device tree.
+ *
+ * Expect the base device tree to be modified, even if the function
+ * returns an error.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there's not enough space in the base device tree
+ *	-FDT_ERR_NOTFOUND, the overlay points to some inexistant nodes or
+ *		properties in the base DT
+ *	-FDT_ERR_BADPHANDLE,
+ *	-FDT_ERR_BADOVERLAY,
+ *	-FDT_ERR_NOPHANDLES,
+ *	-FDT_ERR_INTERNAL,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADOFFSET,
+ *	-FDT_ERR_BADPATH,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_overlay_apply(void *fdt, void *fdto);
+
+/**********************************************************************/
+/* Debugging / informational functions                                */
+/**********************************************************************/
+
+const char *fdt_strerror(int errval);
+
+#endif /* LIBFDT_H */
diff -urN u-boot-1.1.6/common/fdt/libfdt_internal.h u-boot-1.1.6_fdt/common/fdt/libfdt_internal.h
--- u-boot-1.1.6/common/fdt/libfdt_internal.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/libfdt_internal.h	2018-10-22 15:54:19.613640153 +0800
@@ -0,0 +1,95 @@
+#ifndef LIBFDT_INTERNAL_H
+#define LIBFDT_INTERNAL_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <fdt.h>
+
+#define FDT_ALIGN(x, a)		(((x) + (a) - 1) & ~((a) - 1))
+#define FDT_TAGALIGN(x)		(FDT_ALIGN((x), FDT_TAGSIZE))
+
+#define FDT_CHECK_HEADER(fdt) \
+	{ \
+		int err_; \
+		if ((err_ = fdt_check_header(fdt)) != 0) \
+			return err_; \
+	}
+
+int fdt_check_node_offset_(const void *fdt, int offset);
+int fdt_check_prop_offset_(const void *fdt, int offset);
+const char *fdt_find_string_(const char *strtab, int tabsize, const char *s);
+int fdt_node_end_offset_(void *fdt, int nodeoffset);
+
+static inline const void *fdt_offset_ptr_(const void *fdt, int offset)
+{
+	return (const char *)fdt + fdt_off_dt_struct(fdt) + offset;
+}
+
+static inline void *fdt_offset_ptr_w_(void *fdt, int offset)
+{
+	return (void *)(uintptr_t)fdt_offset_ptr_(fdt, offset);
+}
+
+static inline const struct fdt_reserve_entry *fdt_mem_rsv_(const void *fdt, int n)
+{
+	const struct fdt_reserve_entry *rsv_table =
+		(const struct fdt_reserve_entry *)
+		((const char *)fdt + fdt_off_mem_rsvmap(fdt));
+
+	return rsv_table + n;
+}
+static inline struct fdt_reserve_entry *fdt_mem_rsv_w_(void *fdt, int n)
+{
+	return (void *)(uintptr_t)fdt_mem_rsv_(fdt, n);
+}
+
+#define FDT_SW_MAGIC		(~FDT_MAGIC)
+
+#endif /* LIBFDT_INTERNAL_H */
diff -urN u-boot-1.1.6/common/fdt/Makefile u-boot-1.1.6_fdt/common/fdt/Makefile
--- u-boot-1.1.6/common/fdt/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/common/fdt/Makefile	2018-10-22 16:49:00.577579622 +0800
@@ -0,0 +1,55 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB 	:= $(obj)libfdt.a
+
+COBJS 	:= cmd_fdt.o \
+			fdt.o \
+			fdt_addresses.o \
+			fdt_empty_tree.o \
+			fdt_overlay.o \
+			fdt_region.o \
+			fdt_ro.o \
+			fdt_rw.o \
+			fdt_strerror.o \
+			fdt_sw.o \
+			fdt_wip.o fdt_support.o
+
+SRCS 	:= $(COBJS:.o=.c)
+OBJS 	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-1.1.6/common/main.c u-boot-1.1.6_fdt/common/main.c
--- u-boot-1.1.6/common/main.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/common/main.c	2018-10-22 15:53:21.541641225 +0800
@@ -40,9 +40,9 @@
 
 #include <post.h>
 
-#ifdef CONFIG_SILENT_CONSOLE
+//#ifdef CONFIG_SILENT_CONSOLE
 DECLARE_GLOBAL_DATA_PTR;
-#endif
+//#endif
 
 #if defined(CONFIG_BOOT_RETRY_TIME) && defined(CONFIG_RESET_TO_RETRY)
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);		/* for do_reset() prototype */
@@ -257,14 +257,20 @@
 		/* delay 100 * 10ms */
 		for (i=0; !abort && i<100; ++i) {
 			if (tstc()) {	/* we got a key press	*/
+# ifdef CONFIG_MENUKEY
 				abort  = 1;	/* don't auto boot	*/
 				bootdelay = 0;	/* no more delay	*/
-# ifdef CONFIG_MENUKEY
 				menukey = getc();
+				break;
 # else
-				(void) getc();  /* consume input	*/
+				/* consume input	*/
+				if (getc() == ' ') {
+					abort  = 1; /* don't auto boot	*/
+					bootdelay = 0;	/* no more delay	*/
+					break;
+				}
 # endif
-				break;
+
 			}
 			udelay (10000);
 		}
@@ -363,6 +369,18 @@
 	install_auto_complete();
 #endif
 
+#ifdef CONFIG_JFFS2_CMDLINE
+    extern int mtdparts_init(void);
+    if (!getenv("mtdparts"))
+    {
+        run_command("mtdparts default", 0);
+    }
+    else
+    {
+        mtdparts_init();
+    }
+#endif
+
 #ifdef CONFIG_PREBOOT
 	if ((p = getenv ("preboot")) != NULL) {
 # ifdef CONFIG_AUTOBOOT_KEYED
@@ -392,6 +410,17 @@
 	init_cmd_timeout ();
 # endif	/* CONFIG_BOOT_RETRY_TIME */
 
+	if (PreLoadedONRAM)	{
+		printf("Use these steps to program the image to flash:\n");
+		printf("1. In OpenOCD\n");
+		printf("   Run the 'halt' command to halt u-boot\n");
+		printf("   Run the 'load_image <file> <address>' command to load file to SDRAM\n");
+		printf("   Run the 'resume' command to resume u-boot\n");
+		printf("2. In u-boot, use the flash commands to program the image to flash\n");
+		printf("Or, use the tftp or nfs command to download file, and then program the flash.\n");
+		goto PROMPT;
+	}
+
 #ifdef CONFIG_BOOTCOUNT_LIMIT
 	if (bootlimit && (bootcount > bootlimit)) {
 		printf ("Warning: Bootlimit (%u) exceeded. Using altbootcmd.\n",
@@ -410,7 +439,10 @@
 # endif
 
 # ifndef CFG_HUSH_PARSER
-		run_command (s, 0);
+        {
+            printf("Booting Linux ...\n");            
+    	    run_command (s, 0);
+        }
 # else
 		parse_string_outer(s, FLAG_PARSE_SEMICOLON |
 				    FLAG_EXIT_FROM_LOOP);
@@ -442,10 +474,12 @@
 	    video_banner();
 	}
 #endif
-
+    eth_init(gd->bd);
+    run_command("menu", 0);
 	/*
 	 * Main Loop for Monitor Command Processing
 	 */
+PROMPT:
 #ifdef CFG_HUSH_PARSER
 	parse_file_outer();
 	/* This point is never reached */
diff -urN u-boot-1.1.6/common/Makefile u-boot-1.1.6_fdt/common/Makefile
--- u-boot-1.1.6/common/Makefile	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/common/Makefile	2018-10-22 15:53:21.541641225 +0800
@@ -40,7 +40,7 @@
 	  cmd_nand.o cmd_net.o cmd_nvedit.o \
 	  cmd_pci.o cmd_pcmcia.o cmd_portio.o \
 	  cmd_reginfo.o cmd_reiser.o cmd_scsi.o cmd_spi.o cmd_universe.o \
-	  cmd_usb.o cmd_vfd.o \
+	  cmd_usb.o cmd_usbslave.o cmd_menu.o cmd_vfd.o \
 	  command.o console.o devices.o dlmalloc.o docecc.o \
 	  environment.o env_common.o \
 	  env_nand.o env_dataflash.o env_flash.o env_eeprom.o \
@@ -51,7 +51,7 @@
 	  memsize.o miiphybb.o miiphyutil.o \
 	  s_record.o serial.o soft_i2c.o soft_spi.o spartan2.o spartan3.o \
 	  usb.o usb_kbd.o usb_storage.o \
-	  virtex2.o xilinx.o crc16.o xyzModem.o cmd_mac.o
+	  virtex2.o xilinx.o crc16.o xyzModem.o cmd_mac.o cmd_suspend.o
 
 SRCS	:= $(AOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(AOBJS) $(COBJS))
diff -urN u-boot-1.1.6/cpu/arm920t/cpu.c u-boot-1.1.6_fdt/cpu/arm920t/cpu.c
--- u-boot-1.1.6/cpu/arm920t/cpu.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/cpu/arm920t/cpu.c	2018-10-22 15:53:21.541641225 +0800
@@ -88,7 +88,6 @@
 #define C1_IC		(1<<12)		/* icache off/on */
 #define C1_HIGH_VECTORS	(1<<13)		/* location of vectors: low/high addresses */
 
-
 int cpu_init (void)
 {
 	/*
@@ -97,6 +96,11 @@
 #ifdef CONFIG_USE_IRQ
 	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
 	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
+    FREE_RAM_END = FIQ_STACK_START - CONFIG_STACKSIZE_FIQ - CONFIG_STACKSIZE;
+    FREE_RAM_SIZE = FREE_RAM_END - PHYS_SDRAM_1;
+#else    
+    FREE_RAM_END = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4 - CONFIG_STACKSIZE;
+    FREE_RAM_SIZE = FREE_RAM_END - PHYS_SDRAM_1;
 #endif
 	return 0;
 }
diff -urN u-boot-1.1.6/cpu/arm920t/Makefile u-boot-1.1.6_fdt/cpu/arm920t/Makefile
--- u-boot-1.1.6/cpu/arm920t/Makefile	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/cpu/arm920t/Makefile	2018-10-22 15:53:21.545641225 +0800
@@ -27,6 +27,7 @@
 
 START	= start.o
 COBJS	= cpu.o interrupts.o
+SOBJS   = suspend.o
 
 SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/interrupts.c u-boot-1.1.6_fdt/cpu/arm920t/s3c24x0/interrupts.c
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/interrupts.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/cpu/arm920t/s3c24x0/interrupts.c	2018-10-22 15:53:21.545641225 +0800
@@ -216,4 +216,125 @@
 	/*NOTREACHED*/
 }
 
+/* Start : add by www.100ask.net */
+void (*isr_handle_array[50])(void);
+S3C24X0_INTERRUPT * intregs;
+    
+extern void IsrUsbd(void);
+extern void IsrDma2(void);
+
+/************************* Timer ********************************/
+static int intCount;
+
+void IsrWatchdog(void);
+
+void ClearPending(int bit) 
+{
+    intregs->SRCPND = bit;
+    intregs->INTPND = bit;
+}
+
+void Timer_InitEx(void)
+{
+	intCount=0;	
+	intregs->SUBSRCPND	= (1<<13);
+	ClearPending(BIT_WDT_AC97/*BIT_WDT*/);
+	intregs->INTMSK&=~(BIT_WDT_AC97 /*BIT_WDT*/);
+	intregs->INTSUBMSK &= ~(1<<13);
+}
+
+
+void Timer_StartEx(void)
+{
+    S3C24X0_WATCHDOG * const wdtregs = S3C24X0_GetBase_WATCHDOG();
+    
+	wdtregs->WTCON=((get_PCLK()/1000000-1)<<8)|(0<<3)|(1<<2);	// 16us
+	wdtregs->WTDAT=0xffff;
+	wdtregs->WTCNT=0xffff;   
+
+	// 1/16/(65+1),interrupt enable,reset disable,watchdog enable
+	wdtregs->WTCON=((get_PCLK()/1000000-1)<<8)|(0<<3)|(1<<2)|(0<<0)|(1<<5);   
+}
+
+unsigned int Timer_StopEx(void)
+{
+	int count;
+    S3C24X0_WATCHDOG * const wdtregs = S3C24X0_GetBase_WATCHDOG();
+
+	wdtregs->WTCON=((get_PCLK()/1000000-1)<<8);
+	intregs->INTMSK|=BIT_WDT_AC97; //BIT_WDT;
+	intregs->INTSUBMSK |= (1<<13);
+	
+	count=(0xffff-wdtregs->WTCNT)+(intCount*0xffff);
+	return ((unsigned int)count*16/1000000);
+}
+
+
+void  IsrWatchdog(void)
+{
+	intregs->SUBSRCPND	= (1<<13);
+	ClearPending(BIT_WDT_AC97 /* BIT_WDT */);
+	intCount++;   	
+}
+
+int g_TimerIntHappen;
+void  IsrTimer4(void)
+{
+	ClearPending(BIT_TIMER4);
+	*(volatile int *)&g_TimerIntHappen = 1;
+}
+
+
+void Dummy_isr(void)
+{
+    printf("Dummy_isr error, interrupt number: %d, INTMSK = 0x%x\n", intregs->INTOFFSET, intregs->INTMSK);
+    while(1);
+}
+
+void Isr_Init(void)
+{
+    int i = 0;
+    intregs = S3C24X0_GetBase_INTERRUPT();
+    
+    for (i = 0; i < sizeof(isr_handle_array) / sizeof(isr_handle_array[0]); i++ )
+    {
+        isr_handle_array[i] = Dummy_isr;
+    }
+
+    intregs->INTMOD=0x0;	      // All=IRQ mode
+    intregs->INTMSK=BIT_ALLMSK;	  // All interrupt is masked.
+
+    //pISR_URXD0=(unsigned)Uart0_RxInt;	
+    //rINTMSK=~(BIT_URXD0);   //enable UART0 RX Default value=0xffffffff
+
+	isr_handle_array[ISR_TIMER4_OFT] = IsrTimer4;
+	isr_handle_array[ISR_WDT_OFT]  = IsrWatchdog;
+
+#ifdef CONFIG_USB_DEVICE
+    isr_handle_array[ISR_USBD_OFT] = IsrUsbd;
+    isr_handle_array[ISR_DMA2_OFT] = IsrDma2;
+    ClearPending(BIT_DMA2);
+    ClearPending(BIT_USBD);
+#endif    
+}
+
+
+void IRQ_Handle()
+{
+	unsigned long oft = intregs->INTOFFSET;
+    S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+    
+//    printk("IRQ_Handle: %d\n", oft);
+    
+	//清中断
+	if( oft == 4 ) gpio->EINTPEND = 1<<7;		//EINT4-7合用IRQ4，注意EINTPEND[3:0]保留未用，向这些位写入1可能导致未知结果
+	intregs->SRCPND = 1<<oft;	
+	intregs->INTPND	= intregs->INTPND;	 
+
+    /* run the isr */
+    isr_handle_array[oft]();
+}
+
+/* End : add by www.100ask.net */
+
 #endif /* defined(CONFIG_S3C2400) || defined (CONFIG_S3C2410) || defined (CONFIG_TRAB) */
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/Makefile u-boot-1.1.6_fdt/cpu/arm920t/s3c24x0/Makefile
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/Makefile	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/cpu/arm920t/s3c24x0/Makefile	2018-10-22 15:53:21.545641225 +0800
@@ -26,7 +26,7 @@
 LIB	= $(obj)lib$(SOC).a
 
 COBJS	= i2c.o interrupts.o serial.o speed.o \
-	  usb_ohci.o
+	  usb_ohci.o nand_flash.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/nand_flash.c u-boot-1.1.6_fdt/cpu/arm920t/s3c24x0/nand_flash.c
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/nand_flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/cpu/arm920t/s3c24x0/nand_flash.c	2018-10-22 15:53:21.545641225 +0800
@@ -0,0 +1,186 @@
+/*
+ * Nand flash interface of s3c2410/s3c2440, by www.100ask.net
+ * Changed from drivers/mtd/nand/s3c2410.c of kernel 2.6.13
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) && !defined(CFG_NAND_LEGACY)
+#include <s3c2410.h>
+#include <nand.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define S3C2410_NFSTAT_READY    (1<<0)
+#define S3C2410_NFCONF_nFCE     (1<<11)
+
+#define S3C2440_NFSTAT_READY    (1<<0)
+#define S3C2440_NFCONT_nFCE     (1<<1)
+
+
+/* select chip, for s3c2410 */
+static void s3c2410_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+
+    if (chip == -1) {
+        s3c2410nand->NFCONF |= S3C2410_NFCONF_nFCE;
+    } else {
+        s3c2410nand->NFCONF &= ~S3C2410_NFCONF_nFCE;
+    }
+}
+
+/* command and control functions, for s3c2410 
+ *
+ * Note, these all use tglx's method of changing the IO_ADDR_W field
+ * to make the code simpler, and use the nand layer's code to issue the
+ * command and address sequences via the proper IO ports.
+ *
+*/
+static void s3c2410_nand_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+    struct nand_chip *chip = mtd->priv;
+
+    switch (cmd) {
+    case NAND_CTL_SETNCE:
+    case NAND_CTL_CLRNCE:
+        printf("%s: called for NCE\n", __FUNCTION__);
+        break;
+
+    case NAND_CTL_SETCLE:
+        chip->IO_ADDR_W = (void *)&s3c2410nand->NFCMD;
+        break;
+
+    case NAND_CTL_SETALE:
+        chip->IO_ADDR_W = (void *)&s3c2410nand->NFADDR;
+        break;
+
+        /* NAND_CTL_CLRCLE: */
+        /* NAND_CTL_CLRALE: */
+    default:
+        chip->IO_ADDR_W = (void *)&s3c2410nand->NFDATA;
+        break;
+    }
+}
+
+/* s3c2410_nand_devready()
+ *
+ * returns 0 if the nand is busy, 1 if it is ready
+ */
+static int s3c2410_nand_devready(struct mtd_info *mtd)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+
+    return (s3c2410nand->NFSTAT & S3C2410_NFSTAT_READY);
+}
+
+
+/* select chip, for s3c2440 */
+static void s3c2440_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (chip == -1) {
+        s3c2440nand->NFCONT |= S3C2440_NFCONT_nFCE;
+    } else {
+        s3c2440nand->NFCONT &= ~S3C2440_NFCONT_nFCE;
+    }
+}
+
+/* command and control functions */
+static void s3c2440_nand_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+    struct nand_chip *chip = mtd->priv;
+
+    switch (cmd) {
+    case NAND_CTL_SETNCE:
+    case NAND_CTL_CLRNCE:
+        printf("%s: called for NCE\n", __FUNCTION__);
+        break;
+
+    case NAND_CTL_SETCLE:
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFCMD;
+        break;
+
+    case NAND_CTL_SETALE:
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFADDR;
+        break;
+
+        /* NAND_CTL_CLRCLE: */
+        /* NAND_CTL_CLRALE: */
+    default:
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFDATA;
+        break;
+    }
+}
+
+/* s3c2440_nand_devready()
+ *
+ * returns 0 if the nand is busy, 1 if it is ready
+ */
+static int s3c2440_nand_devready(struct mtd_info *mtd)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    return (s3c2440nand->NFSTAT & S3C2440_NFSTAT_READY);
+}
+
+/*
+ * Nand flash hardware initialization:
+ * Set the timing, enable NAND flash controller
+ */
+static void s3c24x0_nand_inithw(void)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+#define TACLS   0
+#define TWRPH0  4
+#define TWRPH1  2
+
+    if (isS3C2410)
+    {
+        /* Enable NAND flash controller, Initialize ECC, enable chip select, Set flash memory timing */
+        s3c2410nand->NFCONF = (1<<15)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0);
+    }
+    else
+    {
+        /* Set flash memory timing */
+        s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
+        /* Initialize ECC, enable chip select, NAND flash controller enable */
+        s3c2440nand->NFCONT = (1<<4)|(0<<1)|(1<<0);
+    }
+}
+
+/*
+ * Called by drivers/nand/nand.c, initialize the interface of nand flash
+ */
+void board_nand_init(struct nand_chip *chip)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    s3c24x0_nand_inithw();
+
+    if (isS3C2410) {
+        chip->IO_ADDR_R    = (void *)&s3c2410nand->NFDATA;
+        chip->IO_ADDR_W    = (void *)&s3c2410nand->NFDATA;
+        chip->hwcontrol    = s3c2410_nand_hwcontrol;
+        chip->dev_ready    = s3c2410_nand_devready;
+        chip->select_chip  = s3c2410_nand_select_chip;
+        chip->options      = 0;
+    } else {
+        chip->IO_ADDR_R    = (void *)&s3c2440nand->NFDATA;
+        chip->IO_ADDR_W    = (void *)&s3c2440nand->NFDATA;
+        chip->hwcontrol    = s3c2440_nand_hwcontrol;
+        chip->dev_ready    = s3c2440_nand_devready;
+        chip->select_chip  = s3c2440_nand_select_chip;
+        chip->options      = 0;
+    }
+
+    chip->eccmode       = NAND_ECC_SOFT;
+}
+
+#endif
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/nand_flash_legacy.c u-boot-1.1.6_fdt/cpu/arm920t/s3c24x0/nand_flash_legacy.c
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/nand_flash_legacy.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/cpu/arm920t/s3c24x0/nand_flash_legacy.c	2018-10-22 15:53:21.545641225 +0800
@@ -0,0 +1,222 @@
+/* add by www.100ask.net */
+/*-----------------------------------------------------------------------
+ * NAND flash settings
+ */
+#include <common.h>
+#include <s3c2410.h>
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* only has two value: NFCE_LOW, NFCE_HIGH */
+#define NFCE_STATE  int 
+
+void NF_Conf(u16 conf)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFCONF = conf;
+    else
+        s3c2440nand->NFCONF = conf;
+}
+
+/* only for s3c2440 */
+void NF_Cont(u16 cont)
+{
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number != MACH_TYPE_SMDK2410)
+        s3c2440nand->NFCONT = cont;
+}
+
+void NF_Cmd(u8 cmd)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFCMD = cmd;
+    else
+    	s3c2440nand->NFCMD = cmd;
+}
+
+void NF_CmdW(u8 cmd)
+{
+	NF_Cmd(cmd);
+    udelay(1);
+}
+
+void NF_Addr(u8 addr)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFADDR = addr;
+    else
+    	s3c2440nand->NFADDR = addr;
+    udelay(15);
+}
+
+void NF_SetCE(NFCE_STATE s)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+	switch (s) {
+		case NFCE_LOW:
+            if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+		    	s3c2410nand->NFCONF &= ~(1<<11);
+            else
+		    	s3c2440nand->NFCONT &= ~(1<<1);                
+			break;
+
+		case NFCE_HIGH:
+            if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    			s3c2410nand->NFCONF |= (1<<11);
+            else
+		    	s3c2440nand->NFCONT |= (1<<1);
+			break;
+	}
+}
+
+/* only for s3c2440 */
+void NF_ClrRB(void)
+{
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number != MACH_TYPE_SMDK2410)
+    {
+        s3c2440nand->NFSTAT |= (1<<2);
+    }
+}
+
+void NF_WaitRB(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    {
+    	while (!(s3c2410nand->NFSTAT & (1<<0)));
+    }
+    else
+    {
+    	while (!(s3c2440nand->NFSTAT & (1<<0)));
+        s3c2440nand->NFSTAT |= (1<<2);
+    }
+}
+
+void NF_Write(u8 data)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+    volatile unsigned char *puc = (volatile unsigned char *)&s3c2440nand->NFDATA;
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFDATA = data;
+    else
+    	*puc = data;    /* s3c2440's NFDATA must be accessed by 'u8*', www.100ask.net */
+    
+}
+
+u8 NF_Read(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+    volatile unsigned char *puc = (volatile unsigned char *)&s3c2440nand->NFDATA;
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	return(s3c2410nand->NFDATA);
+    else
+    	return(*puc);   /* s3c2440's NFDATA must be accessed by 'u8*', www.100ask.net */
+}
+
+void NF_Init_ECC(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFCONF |= (1<<12);
+    else
+    {
+        s3c2440nand->NFCONT |= (1<<4);   // Reset ECC
+        s3c2440nand->NFCONT &= ~(1<<5);  // UnLock MECC
+    }
+}
+
+u32 NF_Read_ECC(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	return(s3c2410nand->NFECC);
+    else
+    {
+        s3c2440nand->NFCONT |= (1<<5);  // Lock MECC
+        return(s3c2440nand->NFMECC0);   // Read MECC
+    }
+}
+
+extern ulong
+nand_probe(ulong physadr);
+
+
+static inline void NF_Reset(void)
+{
+    int i;
+
+    NF_Cont((1<<4)|(0<<1)|(1<<0));  /* only for s3c2440, Initialize ECC, enable chip select, NAND flash controller enable */
+    NF_SetCE(NFCE_LOW); /* enable chip select */
+    NF_ClrRB();         /* only for s3c2440 */
+    NF_Cmd(0xFF);		/* reset command */
+    for(i = 0; i < 10; i++);	/* tWB = 100ns. */
+    NF_WaitRB();		/* wait 200~500us; */
+    NF_SetCE(NFCE_HIGH);
+}
+
+static inline void NF_Init(void)
+{
+#if 0 /* a little bit too optimistic */
+#define TACLS   0
+#define TWRPH0  3
+#define TWRPH1  0
+#else
+#define TACLS   0
+#define TWRPH0  4
+#define TWRPH1  2
+#endif
+
+    /* Set flash memory timing */
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    {
+        NF_Conf((1<<15)|(0<<14)|(0<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0));
+        /*nand->NFCONF = (1<<15)|(1<<14)|(1<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0); */
+        /* 1  1    1     1,   1      xxx,  r xxx,   r xxx */
+        /* En 512B 4step ECCR nFCE=H tACLS   tWRPH0   tWRPH1 */
+    }
+    else
+    {
+        NF_Conf((3<<12)|(7<<8)|(7<<4));
+    }
+
+    NF_Reset();
+}
+
+void
+nand_init(void)
+{
+	S3C2410_NAND * const nand = S3C2410_GetBase_NAND();
+
+	NF_Init();
+#ifdef DEBUG
+	printf("NAND flash probing at 0x%.8lX\n", (ulong)nand);
+#endif
+	printf ("%4lu MB\n", nand_probe((ulong)nand) >> 20);
+}
+#endif	/* CONFIG_COMMANDS & CFG_CMD_NAND */
+
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/speed.c u-boot-1.1.6_fdt/cpu/arm920t/s3c24x0/speed.c
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/speed.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/cpu/arm920t/s3c24x0/speed.c	2018-10-22 15:53:21.545641225 +0800
@@ -38,6 +38,8 @@
 #include <s3c2410.h>
 #endif
 
+DECLARE_GLOBAL_DATA_PTR;
+
 #define MPLL 0
 #define UPLL 1
 
@@ -57,17 +59,21 @@
     ulong r, m, p, s;
 
     if (pllreg == MPLL)
-	r = clk_power->MPLLCON;
+    r = clk_power->MPLLCON;
     else if (pllreg == UPLL)
-	r = clk_power->UPLLCON;
+    r = clk_power->UPLLCON;
     else
-	hang();
+    hang();
 
     m = ((r & 0xFF000) >> 12) + 8;
     p = ((r & 0x003F0) >> 4) + 2;
     s = r & 0x3;
 
-    return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+        return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
+    else
+        return((CONFIG_SYS_CLK_FREQ * m * 2) / (p << s));   /* S3C2440 */
 }
 
 /* return FCLK frequency */
@@ -76,20 +82,99 @@
     return(get_PLLCLK(MPLL));
 }
 
+/* for s3c2440 */
+#define S3C2440_CLKDIVN_PDIVN        (1<<0)
+#define S3C2440_CLKDIVN_HDIVN_MASK   (3<<1)
+#define S3C2440_CLKDIVN_HDIVN_1      (0<<1)
+#define S3C2440_CLKDIVN_HDIVN_2      (1<<1)
+#define S3C2440_CLKDIVN_HDIVN_4_8    (2<<1)
+#define S3C2440_CLKDIVN_HDIVN_3_6    (3<<1)
+#define S3C2440_CLKDIVN_UCLK         (1<<3)
+
+#define S3C2440_CAMDIVN_CAMCLK_MASK  (0xf<<0)
+#define S3C2440_CAMDIVN_CAMCLK_SEL   (1<<4)
+#define S3C2440_CAMDIVN_HCLK3_HALF   (1<<8)
+#define S3C2440_CAMDIVN_HCLK4_HALF   (1<<9)
+#define S3C2440_CAMDIVN_DVSEN        (1<<12)
+
 /* return HCLK frequency */
 ulong get_HCLK(void)
 {
     S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+    unsigned long clkdiv;
+    unsigned long camdiv;
+    int hdiv = 1;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+        return((clk_power->CLKDIVN & 0x2) ? get_FCLK()/2 : get_FCLK());
+    else
+    {
+        clkdiv = clk_power->CLKDIVN;
+        camdiv = clk_power->CAMDIVN;
+
+        /* work out clock scalings */
+
+        switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
+        case S3C2440_CLKDIVN_HDIVN_1:
+            hdiv = 1;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_2:
+            hdiv = 2;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_4_8:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK4_HALF) ? 8 : 4;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_3_6:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK3_HALF) ? 6 : 3;
+            break;
+        }
 
-    return((clk_power->CLKDIVN & 0x2) ? get_FCLK()/2 : get_FCLK());
+        return get_FCLK() / hdiv;
+    }
 }
 
 /* return PCLK frequency */
 ulong get_PCLK(void)
 {
     S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+    unsigned long clkdiv;
+    unsigned long camdiv;
+    int hdiv = 1;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+        return((clk_power->CLKDIVN & 0x1) ? get_HCLK()/2 : get_HCLK());
+    else
+    {   
+        clkdiv = clk_power->CLKDIVN;
+        camdiv = clk_power->CAMDIVN;
+
+        /* work out clock scalings */
+
+        switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
+        case S3C2440_CLKDIVN_HDIVN_1:
+            hdiv = 1;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_2:
+            hdiv = 2;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_4_8:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK4_HALF) ? 8 : 4;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_3_6:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK3_HALF) ? 6 : 3;
+            break;
+        }
 
-    return((clk_power->CLKDIVN & 0x1) ? get_HCLK()/2 : get_HCLK());
+        return get_FCLK() / hdiv / ((clkdiv & S3C2440_CLKDIVN_PDIVN)? 2:1);
+    }        
 }
 
 /* return UCLK frequency */
diff -urN u-boot-1.1.6/cpu/arm920t/start.S u-boot-1.1.6_fdt/cpu/arm920t/start.S
--- u-boot-1.1.6/cpu/arm920t/start.S	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/cpu/arm920t/start.S	2018-10-22 15:53:21.545641225 +0800
@@ -36,6 +36,19 @@
  *
  *************************************************************************
  */
+#define GSTATUS2       (0x560000B4)
+#define GSTATUS3       (0x560000B8)
+#define GSTATUS4       (0x560000BC)
+
+#define REFRESH        (0x48000024)
+#define MISCCR         (0x56000080)
+
+#define LOCKTIME	0x4C000000	/* R/W, PLL lock time count register */
+#define MPLLCON		0x4C000004	/* R/W, MPLL configuration register */
+#define UPLLCON		0x4C000008	/* R/W, UPLL configuration register */
+#define CLKCON		0x4C00000C	/* R/W, Clock generator control reg. */
+#define CLKSLOW		0x4C000010	/* R/W, Slow clock control register */
+#define CLKDIVN		0x4C000014	/* R/W, Clock divider control */
 
 
 .globl _start
@@ -90,6 +103,18 @@
 _bss_end:
 	.word _end
 
+.globl FREE_RAM_END
+FREE_RAM_END:
+	.word	0x0badc0de
+
+.globl FREE_RAM_SIZE
+FREE_RAM_SIZE:
+	.word	0x0badc0de
+
+.globl PreLoadedONRAM
+PreLoadedONRAM:
+	.word	0
+
 #ifdef CONFIG_USE_IRQ
 /* IRQ stack memory (calculated at run-time) */
 .globl IRQ_STACK_START
@@ -123,6 +148,7 @@
 # define CLKDIVN	0x14800014	/* clock divisor register */
 #elif defined(CONFIG_S3C2410)
 # define pWTCON		0x53000000
+# define INTMOD     0X4A000004
 # define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
 # define INTSUBMSK	0x4A00001C
 # define CLKDIVN	0x4C000014	/* clock divisor register */
@@ -145,31 +171,113 @@
 	str	r1, [r0]
 # endif
 
+#if 0
 	/* FCLK:HCLK:PCLK = 1:2:4 */
 	/* default FCLK is 120 MHz ! */
 	ldr	r0, =CLKDIVN
 	mov	r1, #3
 	str	r1, [r0]
+#endif
 #endif	/* CONFIG_S3C2400 || CONFIG_S3C2410 */
 
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+#if 0
+		/* 这些代码会使用SP,在NAND启动时会破坏片内内存的部分代码
+         * 导致NAND启动时无法使用休眠-唤醒功能
+         */
+		/* 设置SP指向片内内存 */
+		ldr sp, =4092
+		ldr r0, =0x12345678
+		str r0, [sp]
+		ldr r1, [sp]
+		cmp r0, r1
+		ldrne sp, =0x40000000+4096
+		bl clock_init
+#else
+	/* 设置时钟, 使用汇编 */
+#define S3C2440_MPLL_400MHZ     ((0x5c<<12)|(0x01<<4)|(0x01))
+#define S3C2440_UPLL_48MHZ      ((0x38<<12)|(0x02<<4)|(0x02))
+#define S3C2440_CLKDIV          (0x05) // | (1<<3))    /* FCLK:HCLK:PCLK = 1:4:8, UCLK = UPLL/2 */
+
+	ldr r1, =CLKDIVN
+	mov r2, #S3C2440_CLKDIV
+	str r2, [r1]
+
+	mrc p15, 0, r1, c1, c0, 0		// read ctrl register 
+	orr r1, r1, #0xc0000000 		// Asynchronous	
+	mcr p15, 0, r1, c1, c0, 0		// write ctrl register
+
+    ldr r0,=LOCKTIME
+    ldr r1,=0xffffff
+    str r1,[r0]
+    // delay
+    mov     r0, #0x200
+1:  subs    r0, r0, #1
+    bne     1b
+
+    // Configure MPLL
+    ldr r0,=MPLLCON          
+    ldr r1,=S3C2440_MPLL_400MHZ
+    str r1,[r0]
+    // delay
+    mov     r0, #0x200
+1:  subs    r0, r0, #1
+    bne     1b
+
+    //Configure UPLL
+    ldr     r0, =UPLLCON          
+    ldr     r1, =S3C2440_UPLL_48MHZ
+    str     r1, [r0]
+    // delay
+    mov     r0, #0x200
+1:  subs    r0, r0, #1
+    bne     1b
+
+
+#endif
+#endif    
+
+	/* 2. 根据 GSTATUS2[1]判断是复位还是唤醒 */	
+	ldr r0, =GSTATUS2
+	ldr r1, [r0]
+	tst r1, #(1<<1)  /* r1 & (1<<1) */
+	bne wake_up	
+
 	/*
 	 * we do sys-critical inits only at reboot,
 	 * not when booting from ram!
 	 */
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
-	bl	cpu_init_crit
+	adr	r0, _start		/* r0 <- current position of code   */
+	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
+	cmp     r0, r1                  /* don't reloc during debug         */
+	blne	cpu_init_crit
 #endif
 
+	/* Set up the stack						    */
+stack_setup:
+	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
+	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
+
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
+#endif
+	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+
 #ifndef CONFIG_SKIP_RELOCATE_UBOOT
 relocate:				/* relocate U-Boot to RAM	    */
 	adr	r0, _start		/* r0 <- current position of code   */
 	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
 	cmp     r0, r1                  /* don't reloc during debug         */
-	beq     stack_setup
-
+	beq     clear_bss
+	
 	ldr	r2, _armboot_start
 	ldr	r3, _bss_start
 	sub	r2, r3, r2		/* r2 <- size of armboot            */
+#if 1
+	bl  CopyCode2Ram	/* r0: source, r1: dest, r2: size */
+#else
 	add	r2, r0, r2		/* r2 <- source end address         */
 
 copy_loop:
@@ -177,17 +285,8 @@
 	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
 	cmp	r0, r2			/* until source end addreee [r2]    */
 	ble	copy_loop
-#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
-
-	/* Set up the stack						    */
-stack_setup:
-	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
-	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
-	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
-#ifdef CONFIG_USE_IRQ
-	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
 #endif
-	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
 
 clear_bss:
 	ldr	r0, _bss_start		/* find start of bss segment        */
@@ -199,6 +298,15 @@
 	cmp	r0, r1
 	ble	clbss_l
 
+SetLoadFlag:
+	/* Set a global flag, PreLoadedONRAM */
+	adr	r0, _start		/* r0 <- current position of code   */
+	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
+	cmp     r0, r1                  /* don't reloc during debug         */
+	ldr r2, =PreLoadedONRAM
+	mov r3, #1
+	streq r3, [r2]
+
 #if 0
 	/* try doing this stuff after the relocation */
 	ldr     r0, =pWTCON
@@ -224,6 +332,29 @@
 
 _start_armboot:	.word start_armboot
 
+/* 1. 按下按键 */
+wake_up:
+	str r1, [r0]  /* clear GSTATUS2 */
+	/* 3. 设置 MISCCR[19:17]=000b, 以释放SDRAM信号 */
+	ldr r0, =MISCCR
+	ldr r1, [r0]
+	bic r1, r1, #(7<<17)
+	str r1, [r0]
+		
+	/* 4. 配置s3c2440的memory controller */
+	bl	cpu_init_crit
+	
+	/* 5. 等待SDRAM退出self-refresh mode */
+	mov r0, #1000
+1:	subs r0, r0, #1
+	cmp r0, #0
+	bne 1b
+	
+	/* 6. 根据GSTATUS[3:4]的值来运行休眠前的函数 */
+	ldr r0, =GSTATUS3
+	ldr r1, [r0]
+	mov pc, r1
+	
 
 /*
  *************************************************************************
@@ -400,14 +531,88 @@
 	bad_save_user_regs
 	bl 	do_not_used
 
+@ thisway.diy, 2006.06.24
+.globl Launch
+    .align	4
+Launch:    
+    mov r7, r0
+    @ diable interrupt
+	@ disable watch dog timer
+	mov	r1, #0x53000000
+	mov	r2, #0x0
+	str	r2, [r1]
+
+    ldr r1,=INTMSK
+    ldr r2,=0xffffffff  @ all interrupt disable
+    str r2,[r1]
+
+    ldr r1,=INTSUBMSK
+    ldr r2,=0x7ff       @ all sub interrupt disable
+    str r2,[r1]
+
+    ldr     r1, = INTMOD
+    mov r2, #0x0        @ set all interrupt as IRQ (not FIQ)
+    str     r2, [r1]
+
+    @ 
+	mov	ip, #0
+	mcr	p15, 0, ip, c13, c0, 0      @	/* zero PID */
+	mcr	p15, 0, ip, c7, c7, 0       @	/* invalidate I,D caches */
+	mcr	p15, 0, ip, c7, c10, 4      @	/* drain write buffer */
+	mcr	p15, 0, ip, c8, c7, 0       @	/* invalidate I,D TLBs */
+	mrc	p15, 0, ip, c1, c0, 0       @	/* get control register */
+	bic	ip, ip, #0x0001             @	/* disable MMU */
+	mcr	p15, 0, ip, c1, c0, 0       @	/* write control register */
+
+    @ MMU_EnableICache
+    @mrc p15,0,r1,c1,c0,0
+    @orr r1,r1,#(1<<12)
+    @mcr p15,0,r1,c1,c0,0
+
+    @ clear SDRAM: the end of free mem(has wince on it now) to the end of SDRAM
+    ldr     r3, FREE_RAM_END
+    ldr     r4, =PHYS_SDRAM_1+PHYS_SDRAM_1_SIZE    @ must clear all the memory unused to zero
+    mov     r5, #0
+
+    ldr     r1, _armboot_start
+    ldr     r2, =On_Steppingstone
+    sub     r2, r2, r1
+    mov     pc, r2
+On_Steppingstone:
+2:  stmia   r3!, {r5}
+    cmp     r3, r4
+    bne     2b
+
+    @ set sp = 0 on sys mode
+    mov sp, #0
+
+    @ add by thisway.diy 2006.06.26, switch to SVC mode
+	msr	cpsr_c,	#0xdf	@ set the I-bit = 1, diable the IRQ interrupt
+	msr	cpsr_c,	#0xd3	@ set the I-bit = 1, diable the IRQ interrupt
+    ldr sp, =0x31ff5800	
+    
+    nop
+	nop
+    nop
+	nop
+
+	mov     pc, r7  @ Jump to PhysicalAddress
+	nop
+    mov pc, lr
+
 #ifdef CONFIG_USE_IRQ
 
 	.align	5
 irq:
-	get_irq_stack
-	irq_save_user_regs
-	bl 	do_irq
-	irq_restore_user_regs
+/* add by www.100ask.net to use IRQ for USB and DMA */
+	sub	lr, lr, #4			        @ the return address
+	ldr	sp, IRQ_STACK_START	        @ the stack for irq
+	stmdb	sp!, 	{ r0-r12,lr }	@ save registers
+	
+	ldr	lr,	=int_return		        @ set the return addr
+	ldr	pc, =IRQ_Handle		        @ call the isr
+int_return:
+	ldmia	sp!, 	{ r0-r12,pc }^	@ return from interrupt
 
 	.align	5
 fiq:
diff -urN u-boot-1.1.6/cpu/arm920t/suspend.S u-boot-1.1.6_fdt/cpu/arm920t/suspend.S
--- u-boot-1.1.6/cpu/arm920t/suspend.S	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/cpu/arm920t/suspend.S	2018-10-22 15:53:21.545641225 +0800
@@ -0,0 +1,62 @@
+
+	/* s3c2410_cpu_suspend
+	 *
+	 * put the cpu into sleep mode
+	*/
+#define S3C2440_REFRESH_SELF		(1<<22)
+#define S3C2440_MISCCR_SDSLEEP	    (7<<17)
+#define S3C2440_CLKCON_POWER	     (1<<3)
+		
+#define GSTATUS2       (0x560000B4)
+#define GSTATUS3       (0x560000B8)
+#define GSTATUS4       (0x560000BC)
+
+#define REFRESH        (0x48000024)
+#define MISCCR         (0x56000080)
+#define CLKCON         (0x4C00000C)
+
+.globl s3c2440_cpu_suspend
+	@@ prepare cpu to sleep
+s3c2440_cpu_suspend:
+	stmdb	sp!, { r4-r12,lr }
+
+	/* GSTATUS3中存放唤醒时要执行的函数 */
+	ldr r0, =s3c2440_do_resume
+	ldr r1, =GSTATUS3
+	str r0, [r1]
+
+	ldr r1, =GSTATUS4
+	str sp, [r1]
+	
+	ldr	r4, =REFRESH
+	ldr	r5, =MISCCR
+	ldr	r6, =CLKCON
+	ldr	r7, [ r4 ]		@ get REFRESH 
+	ldr	r8, [ r5 ]		@ get MISCCR 
+	ldr	r9, [ r6 ]		@ get CLKCON 
+
+	orr	r7, r7, #S3C2440_REFRESH_SELF	@ SDRAM sleep command
+	orr	r8, r8, #S3C2440_MISCCR_SDSLEEP @ SDRAM power-down signals
+	orr	r9, r9, #S3C2440_CLKCON_POWER	@ power down command
+
+	teq	pc, #0			@ first as a trial-run to load cache
+	bl	s3c2440_do_sleep
+	teq	r0, r0			@ now do it for real
+	b	s3c2440_do_sleep	@
+
+	@@ align next bit of code to cache line
+	.align	5
+s3c2440_do_sleep:
+	streq	r7, [ r4 ]			@ SDRAM sleep command
+	streq	r8, [ r5 ]			@ SDRAM power-down config
+	streq	r9, [ r6 ]			@ CPU sleep
+1:	beq	1b
+	mov	pc, r14
+
+s3c2440_do_resume:
+	/* 返回到do_suspend函数 */
+	ldr r1, =GSTATUS4
+	ldr sp, [r1]
+	
+	ldmia	sp!, 	{ r4-r12,pc }
+
diff -urN u-boot-1.1.6/doc/README.SBC8560 u-boot-1.1.6_fdt/doc/README.SBC8560
--- u-boot-1.1.6/doc/README.SBC8560	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/doc/README.SBC8560	1970-01-01 08:00:00.000000000 +0800
@@ -1,57 +0,0 @@
-The port was tested on Wind River System Sbc8560 board
-<www.windriver.com>. U-Boot was installed on the flash memory of the
-CPU card (no the SODIMM).
-
-NOTE: Please configure uboot compile to the proper PCI frequency and
-setup the appropriate DIP switch settings.
-
-SBC8560 board:
-
-Make sure boards switches are set to their appropriate conditions.
-Refer to the Engineering Reference Guide ERG-00300-002. Of particular
-importance are: 1) the settings for JP4 (JP4 1-3 and 2-4), which
-select the on-board FLASH device (Intel 28F128Jx); 2) The settings
-for the Clock SW9 (33 MHz or 66 MHz).
-
-	Note:	SW9 Settings: 66 MHz
-		4:1 ratio CCB clocks:SYSCLK
-		3:1 ration e500 Core:CCB
-		pos1 - on, pos2 - on, pos3 - off, pos4 - on, pos5 - off, pos6 - on
-	Note:	SW9 Settings: 33 MHz
-		8:1 ratio CCB clocks:SYSCLK
-		3:1 ration e500 Core:CCB
-		pos1 - on, pos2 - on, pos3 - on, pos4 - off, pos5 - off, pos6 - on
-
-
-Flashing the FLASH device with the "Wind River ICE":
-
-1) Properly connect and configure the Wind River ICE to the target
-   JTAG port. This includes running the SBC8560 register script. Make
-   sure target memory can be read and written.
-
-2) Build the u-boot image:
-	make distclean
-	make SBC8560_66_config or SBC8560_33_config
-	make CROSS_COMPILE=.../ELDK3.0/ppc_8xx-/ all
-
-   Note: reference is made to the ELDK3.0 compiler. Further, it seems
-	 the ppc_8xx compiler is required for the 85xx (no 85xx
-	 designated compiler in ELDK3.0)
-
-3) Convert the uboot (.elf) file to a uboot.bin file (using
-   visionClick converter). The bin file should be converted from
-   fffc0000 to ffffffff
-
-4) Setup the Flash Utility (tools menu) for:
-
-   Do a "dc clr" [visionClick] to load the default register settings
-   Determine the clock speed of the PCI bus and set SW9 accordingly
-	Note: the speed of the PCI bus defaults to the slowest PCI card
-   PlayBack the "default" register file for the SBC8560
-   Select the uboot.bin file with zero bias
-   Select the initialize Target prior to programming
-   Select the V28F640Jx (8192 x 8) 1 device FLASH Algorithm
-   Select the erase base address from FFFC0000 to FFFFFFFF
-   Select the start address from 0 with size of 4000
-
-5) Erase and Program
diff -urN u-boot-1.1.6/drivers/cfi_flash.c u-boot-1.1.6_fdt/drivers/cfi_flash.c
--- u-boot-1.1.6/drivers/cfi_flash.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/cfi_flash.c	2018-10-22 15:53:21.545641225 +0800
@@ -4,11 +4,12 @@
  *
  * Copyright (C) 2003 Arabella Software Ltd.
  * Yuli Barcohen <yuli@arabellasw.com>
- * Modified to work with AMD flashes
  *
  * Copyright (C) 2004
  * Ed Okerson
- * Modified to work with little-endian systems.
+ *
+ * Copyright (C) 2006
+ * Tolunay Orkun <listmember@orkun.us>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -28,17 +29,6 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
  * MA 02111-1307 USA
  *
- * History
- * 01/20/2004 - combined variants of original driver.
- * 01/22/2004 - Write performance enhancements for parallel chips (Tolunay)
- * 01/23/2004 - Support for x8/x16 chips (Rune Raknerud)
- * 01/27/2004 - Little endian support Ed Okerson
- *
- * Tested Architectures
- * Port Width  Chip Width    # of banks	   Flash Chip  Board
- * 32	       16	     1		   28F128J3    seranoa/eagle
- * 64	       16	     1		   28F128J3    seranoa/falcon
- *
  */
 
 /* The DEBUG define must be before common to enable debugging */
@@ -46,29 +36,30 @@
 
 #include <common.h>
 #include <asm/processor.h>
+#include <asm/io.h>
 #include <asm/byteorder.h>
 #include <environment.h>
 #ifdef	CFG_FLASH_CFI_DRIVER
 
 /*
- * This file implements a Common Flash Interface (CFI) driver for U-Boot.
- * The width of the port and the width of the chips are determined at initialization.
- * These widths are used to calculate the address for access CFI data structures.
- * It has been tested on an Intel Strataflash implementation and AMD 29F016D.
+ * This file implements a Common Flash Interface (CFI) driver for
+ * U-Boot.
+ *
+ * The width of the port and the width of the chips are determined at
+ * initialization.  These widths are used to calculate the address for
+ * access CFI data structures.
  *
  * References
  * JEDEC Standard JESD68 - Common Flash Interface (CFI)
  * JEDEC Standard JEP137-A Common Flash Interface (CFI) ID Codes
  * Intel Application Note 646 Common Flash Interface (CFI) and Command Sets
  * Intel 290667-008 3 Volt Intel StrataFlash Memory datasheet
+ * AMD CFI Specification, Release 2.0 December 1, 2001
+ * AMD/Spansion Application Note: Migration from Single-byte to Three-byte
+ *   Device IDs, Publication Number 25538 Revision A, November 8, 2001
  *
- * TODO
- *
- * Use Primary Extended Query table (PRI) and Alternate Algorithm Query
- * Table (ALT) to determine if protection is available
- *
- * Add support for other command sets Use the PRI and ALT to determine command set
- * Verify erase and program timeouts.
+ * Define CFG_WRITE_SWAPPED_DATA, if you have to swap the Bytes between
+ * reading and writing ... (yes there is such a Hardware).
  */
 
 #ifndef CFG_FLASH_BANKS_LIST
@@ -85,7 +76,9 @@
 #define FLASH_CMD_PROTECT_SET		0x01
 #define FLASH_CMD_PROTECT_CLEAR		0xD0
 #define FLASH_CMD_CLEAR_STATUS		0x50
+#define FLASH_CMD_READ_STATUS		0x70
 #define FLASH_CMD_WRITE_TO_BUFFER	0xE8
+#define FLASH_CMD_WRITE_BUFFER_PROG	0xE9
 #define FLASH_CMD_WRITE_BUFFER_CONFIRM	0xD0
 
 #define FLASH_STATUS_DONE		0x80
@@ -110,14 +103,16 @@
 #define AMD_STATUS_TOGGLE		0x40
 #define AMD_STATUS_ERROR		0x20
 
-#define AMD_ADDR_ERASE_START	((info->portwidth == FLASH_CFI_8BIT) ? 0xAAA : 0x555)
-#define AMD_ADDR_START		((info->portwidth == FLASH_CFI_8BIT) ? 0xAAA : 0x555)
-#define AMD_ADDR_ACK		((info->portwidth == FLASH_CFI_8BIT) ? 0x555 : 0x2AA)
-
+#define FLASH_OFFSET_MANUFACTURER_ID	0x00
+#define FLASH_OFFSET_DEVICE_ID		0x01
+#define FLASH_OFFSET_DEVICE_ID2		0x0E
+#define FLASH_OFFSET_DEVICE_ID3		0x0F
 #define FLASH_OFFSET_CFI		0x55
+#define FLASH_OFFSET_CFI_ALT		0x555
 #define FLASH_OFFSET_CFI_RESP		0x10
 #define FLASH_OFFSET_PRIMARY_VENDOR	0x13
-#define FLASH_OFFSET_EXT_QUERY_T_P_ADDR	0x15	/* extended query table primary addr */
+/* extended query table primary address */
+#define FLASH_OFFSET_EXT_QUERY_T_P_ADDR	0x15
 #define FLASH_OFFSET_WTOUT		0x1F
 #define FLASH_OFFSET_WBTOUT		0x20
 #define FLASH_OFFSET_ETOUT		0x21
@@ -135,22 +130,19 @@
 #define FLASH_OFFSET_USER_PROTECTION	0x85
 #define FLASH_OFFSET_INTEL_PROTECTION	0x81
 
-
-#define FLASH_MAN_CFI			0x01000000
-
-#define CFI_CMDSET_NONE		    0
-#define CFI_CMDSET_INTEL_EXTENDED   1
-#define CFI_CMDSET_AMD_STANDARD	    2
-#define CFI_CMDSET_INTEL_STANDARD   3
-#define CFI_CMDSET_AMD_EXTENDED	    4
-#define CFI_CMDSET_MITSU_STANDARD   256
-#define CFI_CMDSET_MITSU_EXTENDED   257
-#define CFI_CMDSET_SST		    258
-
+#define CFI_CMDSET_NONE			0
+#define CFI_CMDSET_INTEL_EXTENDED	1
+#define CFI_CMDSET_AMD_STANDARD		2
+#define CFI_CMDSET_INTEL_STANDARD	3
+#define CFI_CMDSET_AMD_EXTENDED		4
+#define CFI_CMDSET_MITSU_STANDARD	256
+#define CFI_CMDSET_MITSU_EXTENDED	257
+#define CFI_CMDSET_SST			258
+#define CFI_CMDSET_INTEL_PROG_REGIONS	512
 
 #ifdef CFG_FLASH_CFI_AMD_RESET /* needed for STM_ID_29W320DB on UC100 */
 # undef  FLASH_CMD_RESET
-# define FLASH_CMD_RESET                AMD_CMD_RESET /* use AMD-Reset instead */
+# define FLASH_CMD_RESET	AMD_CMD_RESET /* use AMD-Reset instead */
 #endif
 
 
@@ -161,24 +153,19 @@
 	unsigned long long ll;
 } cfiword_t;
 
-typedef union {
-	volatile unsigned char *cp;
-	volatile unsigned short *wp;
-	volatile unsigned long *lp;
-	volatile unsigned long long *llp;
-} cfiptr_t;
+#define NUM_ERASE_REGIONS	4 /* max. number of erase regions */
 
-#define NUM_ERASE_REGIONS 4
+static uint flash_offset_cfi[2] = { FLASH_OFFSET_CFI, FLASH_OFFSET_CFI_ALT };
 
 /* use CFG_MAX_FLASH_BANKS_DETECT if defined */
 #ifdef CFG_MAX_FLASH_BANKS_DETECT
-static ulong bank_base[CFG_MAX_FLASH_BANKS_DETECT] = CFG_FLASH_BANKS_LIST;
-flash_info_t flash_info[CFG_MAX_FLASH_BANKS_DETECT];	/* FLASH chips info */
+# define CFI_MAX_FLASH_BANKS	CFG_MAX_FLASH_BANKS_DETECT
 #else
-static ulong bank_base[CFG_MAX_FLASH_BANKS] = CFG_FLASH_BANKS_LIST;
-flash_info_t flash_info[CFG_MAX_FLASH_BANKS];		/* FLASH chips info */
+# define CFI_MAX_FLASH_BANKS	CFG_MAX_FLASH_BANKS
 #endif
 
+flash_info_t flash_info[CFI_MAX_FLASH_BANKS];	/* FLASH chips info */
+
 /*
  * Check if chip width is defined. If not, start detecting with 8bit.
  */
@@ -186,45 +173,187 @@
 #define CFG_FLASH_CFI_WIDTH	FLASH_CFI_8BIT
 #endif
 
+typedef unsigned long flash_sect_t;
 
-/*-----------------------------------------------------------------------
- * Functions
+/* CFI standard query structure */
+struct cfi_qry {
+	u8	qry[3];
+	u16	p_id;
+	u16	p_adr;
+	u16	a_id;
+	u16	a_adr;
+	u8	vcc_min;
+	u8	vcc_max;
+	u8	vpp_min;
+	u8	vpp_max;
+	u8	word_write_timeout_typ;
+	u8	buf_write_timeout_typ;
+	u8	block_erase_timeout_typ;
+	u8	chip_erase_timeout_typ;
+	u8	word_write_timeout_max;
+	u8	buf_write_timeout_max;
+	u8	block_erase_timeout_max;
+	u8	chip_erase_timeout_max;
+	u8	dev_size;
+	u16	interface_desc;
+	u16	max_buf_write_size;
+	u8	num_erase_regions;
+	u32	erase_region_info[NUM_ERASE_REGIONS];
+} __attribute__((packed));
+
+struct cfi_pri_hdr {
+	u8	pri[3];
+	u8	major_version;
+	u8	minor_version;
+} __attribute__((packed));
+
+/*
+ * Given a physical address and a length, return a virtual address
+ * that can be used to access the memory range with the caching
+ * properties specified by "flags".
  */
+#define MAP_NOCACHE	(0)
+#define MAP_WRCOMBINE	(0)
+#define MAP_WRBACK	(0)
+#define MAP_WRTHROUGH	(0)
 
-typedef unsigned long flash_sect_t;
+#define sync()		/* nothing */
 
-static void flash_add_byte (flash_info_t * info, cfiword_t * cword, uchar c);
-static void flash_make_cmd (flash_info_t * info, uchar cmd, void *cmdbuf);
-static void flash_write_cmd (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
-static void flash_unlock_seq (flash_info_t * info, flash_sect_t sect);
-static int flash_isequal (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
-static int flash_isset (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
-static int flash_toggle (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
-static int flash_detect_cfi (flash_info_t * info);
-static int flash_write_cfiword (flash_info_t * info, ulong dest, cfiword_t cword);
-static int flash_full_status_check (flash_info_t * info, flash_sect_t sector,
-				    ulong tout, char *prompt);
-ulong flash_get_size (ulong base, int banknum);
+static inline void *
+map_physmem(phys_addr_t paddr, unsigned long len, unsigned long flags)
+{
+	return (void *)paddr;
+}
+
+static inline void unmap_physmem(void *vaddr, unsigned long flags)
+{
+
+}
+
+static void flash_write8(u8 value, void *addr)
+{
+	__raw_writeb(value, addr);
+}
+
+static void flash_write16(u16 value, void *addr)
+{
+	__raw_writew(value, addr);
+}
+
+static void flash_write32(u32 value, void *addr)
+{
+	__raw_writel(value, addr);
+}
+
+static void flash_write64(u64 value, void *addr)
+{
+	/* No architectures currently implement __raw_writeq() */
+	*(volatile u64 *)addr = value;
+}
+
+static u8 flash_read8(void *addr)
+{
+	return __raw_readb(addr);
+}
+
+static u16 flash_read16(void *addr)
+{
+	return __raw_readw(addr);
+}
+
+static u32 flash_read32(void *addr)
+{
+	return __raw_readl(addr);
+}
+
+static u64 __flash_read64(void *addr)
+{
+	/* No architectures currently implement __raw_readq() */
+	return *(volatile u64 *)addr;
+}
+
+u64 flash_read64(void *addr)__attribute__((weak, alias("__flash_read64")));
+
+/*-----------------------------------------------------------------------
+ */
 #if defined(CFG_ENV_IS_IN_FLASH) || defined(CFG_ENV_ADDR_REDUND) || (CFG_MONITOR_BASE >= CFG_FLASH_BASE)
-static flash_info_t *flash_get_info(ulong base);
-#endif
-#ifdef CFG_FLASH_USE_BUFFER_WRITE
-static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp, int len);
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info = 0;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		info = & flash_info[i];
+		if (info->size && info->start[0] <= base &&
+		    base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CFG_MAX_FLASH_BANKS ? 0 : info;
+}
 #endif
 
+unsigned long flash_sector_size(flash_info_t *info, flash_sect_t sect)
+{
+	if (sect != (info->sector_count - 1))
+		return info->start[sect + 1] - info->start[sect];
+	else
+		return info->start[0] + info->size - info->start[sect];
+}
+
 /*-----------------------------------------------------------------------
  * create an address based on the offset and the port width
  */
-inline uchar *flash_make_addr (flash_info_t * info, flash_sect_t sect, uint offset)
+static inline void *
+flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+	unsigned int byte_offset = offset * info->portwidth;
+
+	return map_physmem(info->start[sect] + byte_offset,
+			flash_sector_size(info, sect) - byte_offset,
+			MAP_NOCACHE);
+}
+
+static inline void flash_unmap(flash_info_t *info, flash_sect_t sect,
+		unsigned int offset, void *addr)
+{
+	unsigned int byte_offset = offset * info->portwidth;
+
+	unmap_physmem(addr, flash_sector_size(info, sect) - byte_offset);
+}
+
+/*-----------------------------------------------------------------------
+ * make a proper sized command based on the port and chip widths
+ */
+static void flash_make_cmd(flash_info_t *info, u32 cmd, void *cmdbuf)
 {
-	return ((uchar *) (info->start[sect] + (offset * info->portwidth)));
+	int i;
+	int cword_offset;
+	int cp_offset;
+#if defined(__LITTLE_ENDIAN) || defined(CFG_WRITE_SWAPPED_DATA)
+	u32 cmd_le = cpu_to_le32(cmd);
+#endif
+	uchar val;
+	uchar *cp = (uchar *) cmdbuf;
+
+	for (i = info->portwidth; i > 0; i--){
+		cword_offset = (info->portwidth-i)%info->chipwidth;
+#if defined(__LITTLE_ENDIAN) || defined(CFG_WRITE_SWAPPED_DATA)
+		cp_offset = info->portwidth - i;
+		val = *((uchar*)&cmd_le + cword_offset);
+#else
+		cp_offset = i - 1;
+		val = *((uchar*)&cmd + sizeof(u32) - cword_offset - 1);
+#endif
+		cp[cp_offset] = (cword_offset >= sizeof(u32)) ? 0x00 : val;
+	}
 }
 
 #ifdef DEBUG
 /*-----------------------------------------------------------------------
  * Debug support
  */
-void print_longlong (char *str, unsigned long long data)
+static void print_longlong (char *str, unsigned long long data)
 {
 	int i;
 	char *cp;
@@ -233,28 +362,25 @@
 	for (i = 0; i < 8; i++)
 		sprintf (&str[i * 2], "%2.2x", *cp++);
 }
-static void flash_printqry (flash_info_t * info, flash_sect_t sect)
+
+static void flash_printqry (struct cfi_qry *qry)
 {
-	cfiptr_t cptr;
+	u8 *p = (u8 *)qry;
 	int x, y;
 
-	for (x = 0; x < 0x40; x += 16U / info->portwidth) {
-		cptr.cp =
-			flash_make_addr (info, sect,
-					 x + FLASH_OFFSET_CFI_RESP);
-		debug ("%p : ", cptr.cp);
-		for (y = 0; y < 16; y++) {
-			debug ("%2.2x ", cptr.cp[y]);
-		}
-		debug (" ");
+	for (x = 0; x < sizeof(struct cfi_qry); x += 16) {
+		debug("%02x : ", x);
+		for (y = 0; y < 16; y++)
+			debug("%2.2x ", p[x + y]);
+		debug(" ");
 		for (y = 0; y < 16; y++) {
-			if (cptr.cp[y] >= 0x20 && cptr.cp[y] <= 0x7e) {
-				debug ("%c", cptr.cp[y]);
-			} else {
-				debug (".");
-			}
+			unsigned char c = p[x + y];
+			if (c >= 0x20 && c <= 0x7e)
+				debug("%c", c);
+			else
+				debug(".");
 		}
-		debug ("\n");
+		debug("\n");
 	}
 }
 #endif
@@ -263,54 +389,41 @@
 /*-----------------------------------------------------------------------
  * read a character at a port width address
  */
-inline uchar flash_read_uchar (flash_info_t * info, uint offset)
+static inline uchar flash_read_uchar (flash_info_t * info, uint offset)
 {
 	uchar *cp;
+	uchar retval;
 
-	cp = flash_make_addr (info, 0, offset);
-#if defined(__LITTLE_ENDIAN)
-	return (cp[0]);
+	cp = flash_map (info, 0, offset);
+#if defined(__LITTLE_ENDIAN) || defined(CFG_WRITE_SWAPPED_DATA)
+	retval = flash_read8(cp);
 #else
-	return (cp[info->portwidth - 1]);
+	retval = flash_read8(cp + info->portwidth - 1);
 #endif
+	flash_unmap (info, 0, offset, cp);
+	return retval;
 }
 
 /*-----------------------------------------------------------------------
- * read a short word by swapping for ppc format.
+ * read a word at a port width address, assume 16bit bus
  */
-ushort flash_read_ushort (flash_info_t * info, flash_sect_t sect, uint offset)
+static inline ushort flash_read_word (flash_info_t * info, uint offset)
 {
-	uchar *addr;
-	ushort retval;
+	ushort *addr, retval;
 
-#ifdef DEBUG
-	int x;
-#endif
-	addr = flash_make_addr (info, sect, offset);
-
-#ifdef DEBUG
-	debug ("ushort addr is at %p info->portwidth = %d\n", addr,
-	       info->portwidth);
-	for (x = 0; x < 2 * info->portwidth; x++) {
-		debug ("addr[%x] = 0x%x\n", x, addr[x]);
-	}
-#endif
-#if defined(__LITTLE_ENDIAN)
-	retval = ((addr[(info->portwidth)] << 8) | addr[0]);
-#else
-	retval = ((addr[(2 * info->portwidth) - 1] << 8) |
-		  addr[info->portwidth - 1]);
-#endif
-
-	debug ("retval = 0x%x\n", retval);
+	addr = flash_map (info, 0, offset);
+	retval = flash_read16 (addr);
+	flash_unmap (info, 0, offset, addr);
 	return retval;
 }
 
+
 /*-----------------------------------------------------------------------
- * read a long word by picking the least significant byte of each maiximum
+ * read a long word by picking the least significant byte of each maximum
  * port size word. Swap for ppc format.
  */
-ulong flash_read_long (flash_info_t * info, flash_sect_t sect, uint offset)
+static ulong flash_read_long (flash_info_t * info, flash_sect_t sect,
+			      uint offset)
 {
 	uchar *addr;
 	ulong retval;
@@ -318,449 +431,224 @@
 #ifdef DEBUG
 	int x;
 #endif
-	addr = flash_make_addr (info, sect, offset);
+	addr = flash_map (info, sect, offset);
 
 #ifdef DEBUG
 	debug ("long addr is at %p info->portwidth = %d\n", addr,
 	       info->portwidth);
 	for (x = 0; x < 4 * info->portwidth; x++) {
-		debug ("addr[%x] = 0x%x\n", x, addr[x]);
+		debug ("addr[%x] = 0x%x\n", x, flash_read8(addr + x));
 	}
 #endif
-#if defined(__LITTLE_ENDIAN)
-	retval = (addr[0] << 16) | (addr[(info->portwidth)] << 24) |
-		(addr[(2 * info->portwidth)]) | (addr[(3 * info->portwidth)] << 8);
+#if defined(__LITTLE_ENDIAN) || defined(CFG_WRITE_SWAPPED_DATA)
+	retval = ((flash_read8(addr) << 16) |
+		  (flash_read8(addr + info->portwidth) << 24) |
+		  (flash_read8(addr + 2 * info->portwidth)) |
+		  (flash_read8(addr + 3 * info->portwidth) << 8));
 #else
-	retval = (addr[(2 * info->portwidth) - 1] << 24) |
-		(addr[(info->portwidth) - 1] << 16) |
-		(addr[(4 * info->portwidth) - 1] << 8) |
-		addr[(3 * info->portwidth) - 1];
+	retval = ((flash_read8(addr + 2 * info->portwidth - 1) << 24) |
+		  (flash_read8(addr + info->portwidth - 1) << 16) |
+		  (flash_read8(addr + 4 * info->portwidth - 1) << 8) |
+		  (flash_read8(addr + 3 * info->portwidth - 1)));
 #endif
+	flash_unmap(info, sect, offset, addr);
+
 	return retval;
 }
 
-
-/*-----------------------------------------------------------------------
+/*
+ * Write a proper sized command to the correct address
  */
-unsigned long flash_init (void)
+static void flash_write_cmd (flash_info_t * info, flash_sect_t sect,
+			     uint offset, u32 cmd)
 {
-	unsigned long size = 0;
-	int i;
-
-#ifdef CFG_FLASH_PROTECTION
-	char *s = getenv("unlock");
-#endif
-
-	/* Init: no FLASHes known */
-	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
-		flash_info[i].flash_id = FLASH_UNKNOWN;
-		size += flash_info[i].size = flash_get_size (bank_base[i], i);
-		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
-#ifndef CFG_FLASH_QUIET_TEST
-			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB\n",
-				i, flash_info[i].size, flash_info[i].size << 20);
-#endif /* CFG_FLASH_QUIET_TEST */
-		}
-#ifdef CFG_FLASH_PROTECTION
-		else if ((s != NULL) && (strcmp(s, "yes") == 0)) {
-			/*
-			 * Only the U-Boot image and it's environment is protected,
-			 * all other sectors are unprotected (unlocked) if flash
-			 * hardware protection is used (CFG_FLASH_PROTECTION) and
-			 * the environment variable "unlock" is set to "yes".
-			 */
-			if (flash_info[i].legacy_unlock) {
-				int k;
 
-				/*
-				 * Disable legacy_unlock temporarily, since
-				 * flash_real_protect would relock all other sectors
-				 * again otherwise.
-				 */
-				flash_info[i].legacy_unlock = 0;
+	void *addr;
+	cfiword_t cword;
 
-				/*
-				 * Legacy unlocking (e.g. Intel J3) -> unlock only one
-				 * sector. This will unlock all sectors.
-				 */
-				flash_real_protect (&flash_info[i], 0, 0);
+	addr = flash_map (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		debug ("fwc addr %p cmd %x %x 8bit x %d bit\n", addr, cmd,
+		       cword.c, info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		flash_write8(cword.c, addr);
+		break;
+	case FLASH_CFI_16BIT:
+		debug ("fwc addr %p cmd %x %4.4x 16bit x %d bit\n", addr,
+		       cmd, cword.w,
+		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		flash_write16(cword.w, addr);
+		break;
+	case FLASH_CFI_32BIT:
+		debug ("fwc addr %p cmd %x %8.8lx 32bit x %d bit\n", addr,
+		       cmd, cword.l,
+		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		flash_write32(cword.l, addr);
+		break;
+	case FLASH_CFI_64BIT:
+#ifdef DEBUG
+		{
+			char str[20];
 
-				flash_info[i].legacy_unlock = 1;
+			print_longlong (str, cword.ll);
 
-				/*
-				 * Manually mark other sectors as unlocked (unprotected)
-				 */
-				for (k = 1; k < flash_info[i].sector_count; k++)
-					flash_info[i].protect[k] = 0;
-			} else {
-				/*
-				 * No legancy unlocking -> unlock all sectors
-				 */
-				flash_protect (FLAG_PROTECT_CLEAR,
-					       flash_info[i].start[0],
-					       flash_info[i].start[0] + flash_info[i].size - 1,
-					       &flash_info[i]);
-			}
+			debug ("fwrite addr %p cmd %x %s 64 bit x %d bit\n",
+			       addr, cmd, str,
+			       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
 		}
-#endif /* CFG_FLASH_PROTECTION */
+#endif
+		flash_write64(cword.ll, addr);
+		break;
 	}
 
-	/* Monitor protection ON by default */
-#if (CFG_MONITOR_BASE >= CFG_FLASH_BASE)
-	flash_protect (FLAG_PROTECT_SET,
-		       CFG_MONITOR_BASE,
-		       CFG_MONITOR_BASE + monitor_flash_len  - 1,
-		       flash_get_info(CFG_MONITOR_BASE));
-#endif
+	/* Ensure all the instructions are fully finished */
+	sync();
 
-	/* Environment protection ON by default */
-#ifdef CFG_ENV_IS_IN_FLASH
-	flash_protect (FLAG_PROTECT_SET,
-		       CFG_ENV_ADDR,
-		       CFG_ENV_ADDR + CFG_ENV_SECT_SIZE - 1,
-		       flash_get_info(CFG_ENV_ADDR));
-#endif
+	flash_unmap(info, sect, offset, addr);
+}
 
-	/* Redundant environment protection ON by default */
-#ifdef CFG_ENV_ADDR_REDUND
-	flash_protect (FLAG_PROTECT_SET,
-		       CFG_ENV_ADDR_REDUND,
-		       CFG_ENV_ADDR_REDUND + CFG_ENV_SIZE_REDUND - 1,
-		       flash_get_info(CFG_ENV_ADDR_REDUND));
-#endif
-	return (size);
+static void flash_unlock_seq (flash_info_t * info, flash_sect_t sect)
+{
+	flash_write_cmd (info, sect, info->addr_unlock1, AMD_CMD_UNLOCK_START);
+	flash_write_cmd (info, sect, info->addr_unlock2, AMD_CMD_UNLOCK_ACK);
 }
 
 /*-----------------------------------------------------------------------
  */
-#if defined(CFG_ENV_IS_IN_FLASH) || defined(CFG_ENV_ADDR_REDUND) || (CFG_MONITOR_BASE >= CFG_FLASH_BASE)
-static flash_info_t *flash_get_info(ulong base)
+static int flash_isequal (flash_info_t * info, flash_sect_t sect,
+			  uint offset, uchar cmd)
 {
-	int i;
-	flash_info_t * info = 0;
+	void *addr;
+	cfiword_t cword;
+	int retval;
 
-	for (i = 0; i < CFG_MAX_FLASH_BANKS; i ++) {
-		info = & flash_info[i];
-		if (info->size && info->start[0] <= base &&
-		    base <= info->start[0] + info->size - 1)
-			break;
+	addr = flash_map (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+
+	debug ("is= cmd %x(%c) addr %p ", cmd, cmd, addr);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		debug ("is= %x %x\n", flash_read8(addr), cword.c);
+		retval = (flash_read8(addr) == cword.c);
+		break;
+	case FLASH_CFI_16BIT:
+		debug ("is= %4.4x %4.4x\n", flash_read16(addr), cword.w);
+		retval = (flash_read16(addr) == cword.w);
+		break;
+	case FLASH_CFI_32BIT:
+		debug ("is= %8.8lx %8.8lx\n", flash_read32(addr), cword.l);
+		retval = (flash_read32(addr) == cword.l);
+		break;
+	case FLASH_CFI_64BIT:
+#ifdef DEBUG
+		{
+			char str1[20];
+			char str2[20];
+
+			print_longlong (str1, flash_read64(addr));
+			print_longlong (str2, cword.ll);
+			debug ("is= %s %s\n", str1, str2);
+		}
+#endif
+		retval = (flash_read64(addr) == cword.ll);
+		break;
+	default:
+		retval = 0;
+		break;
 	}
+	flash_unmap(info, sect, offset, addr);
 
-	return i == CFG_MAX_FLASH_BANKS ? 0 : info;
+	return retval;
 }
-#endif
 
 /*-----------------------------------------------------------------------
  */
-int flash_erase (flash_info_t * info, int s_first, int s_last)
+static int flash_isset (flash_info_t * info, flash_sect_t sect,
+			uint offset, uchar cmd)
 {
-	int rcode = 0;
-	int prot;
-	flash_sect_t sect;
-
-	if (info->flash_id != FLASH_MAN_CFI) {
-		puts ("Can't erase unknown flash type - aborted\n");
-		return 1;
-	}
-	if ((s_first < 0) || (s_first > s_last)) {
-		puts ("- no sectors to erase\n");
-		return 1;
-	}
+	void *addr;
+	cfiword_t cword;
+	int retval;
 
-	prot = 0;
-	for (sect = s_first; sect <= s_last; ++sect) {
-		if (info->protect[sect]) {
-			prot++;
-		}
-	}
-	if (prot) {
-		printf ("- Warning: %d protected sectors will not be erased!\n", prot);
-	} else {
-		putc ('\n');
-	}
-
-
-	for (sect = s_first; sect <= s_last; sect++) {
-		if (info->protect[sect] == 0) { /* not protected */
-			switch (info->vendor) {
-			case CFI_CMDSET_INTEL_STANDARD:
-			case CFI_CMDSET_INTEL_EXTENDED:
-				flash_write_cmd (info, sect, 0, FLASH_CMD_CLEAR_STATUS);
-				flash_write_cmd (info, sect, 0, FLASH_CMD_BLOCK_ERASE);
-				flash_write_cmd (info, sect, 0, FLASH_CMD_ERASE_CONFIRM);
-				break;
-			case CFI_CMDSET_AMD_STANDARD:
-			case CFI_CMDSET_AMD_EXTENDED:
-				flash_unlock_seq (info, sect);
-				flash_write_cmd (info, sect, AMD_ADDR_ERASE_START,
-							AMD_CMD_ERASE_START);
-				flash_unlock_seq (info, sect);
-				flash_write_cmd (info, sect, 0, AMD_CMD_ERASE_SECTOR);
-				break;
-			default:
-				debug ("Unkown flash vendor %d\n",
-				       info->vendor);
-				break;
-			}
-
-			if (flash_full_status_check
-			    (info, sect, info->erase_blk_tout, "erase")) {
-				rcode = 1;
-			} else
-				putc ('.');
-		}
-	}
-	puts (" done\n");
-	return rcode;
-}
-
-/*-----------------------------------------------------------------------
- */
-void flash_print_info (flash_info_t * info)
-{
-	int i;
-
-	if (info->flash_id != FLASH_MAN_CFI) {
-		puts ("missing or unknown FLASH type\n");
-		return;
+	addr = flash_map (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		retval = ((flash_read8(addr) & cword.c) == cword.c);
+		break;
+	case FLASH_CFI_16BIT:
+		retval = ((flash_read16(addr) & cword.w) == cword.w);
+		break;
+	case FLASH_CFI_32BIT:
+		retval = ((flash_read32(addr) & cword.l) == cword.l);
+		break;
+	case FLASH_CFI_64BIT:
+		retval = ((flash_read64(addr) & cword.ll) == cword.ll);
+		break;
+	default:
+		retval = 0;
+		break;
 	}
+	flash_unmap(info, sect, offset, addr);
 
-	printf ("CFI conformant FLASH (%d x %d)",
-		(info->portwidth << 3), (info->chipwidth << 3));
-	printf ("  Size: %ld MB in %d Sectors\n",
-		info->size >> 20, info->sector_count);
-	printf (" Erase timeout %ld ms, write timeout %ld ms, buffer write timeout %ld ms, buffer size %d\n",
-		info->erase_blk_tout,
-		info->write_tout,
-		info->buffer_write_tout,
-		info->buffer_size);
-
-	puts ("  Sector Start Addresses:");
-	for (i = 0; i < info->sector_count; ++i) {
-#ifdef CFG_FLASH_EMPTY_INFO
-		int k;
-		int size;
-		int erased;
-		volatile unsigned long *flash;
-
-		/*
-		 * Check if whole sector is erased
-		 */
-		if (i != (info->sector_count - 1))
-			size = info->start[i + 1] - info->start[i];
-		else
-			size = info->start[0] + info->size - info->start[i];
-		erased = 1;
-		flash = (volatile unsigned long *) info->start[i];
-		size = size >> 2;	/* divide by 4 for longword access */
-		for (k = 0; k < size; k++) {
-			if (*flash++ != 0xffffffff) {
-				erased = 0;
-				break;
-			}
-		}
-
-		if ((i % 5) == 0)
-			printf ("\n");
-		/* print empty and read-only info */
-		printf (" %08lX%s%s",
-			info->start[i],
-			erased ? " E" : "  ",
-			info->protect[i] ? "RO " : "   ");
-#else	/* ! CFG_FLASH_EMPTY_INFO */
-		if ((i % 5) == 0)
-			printf ("\n   ");
-		printf (" %08lX%s",
-			info->start[i], info->protect[i] ? " (RO)" : "     ");
-#endif
-	}
-	putc ('\n');
-	return;
+	return retval;
 }
 
 /*-----------------------------------------------------------------------
- * Copy memory to flash, returns:
- * 0 - OK
- * 1 - write timeout
- * 2 - Flash not erased
  */
-int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+static int flash_toggle (flash_info_t * info, flash_sect_t sect,
+			 uint offset, uchar cmd)
 {
-	ulong wp;
-	ulong cp;
-	int aln;
+	void *addr;
 	cfiword_t cword;
-	int i, rc;
-
-#ifdef CFG_FLASH_USE_BUFFER_WRITE
-	int buffered_size;
-#endif
-	/* get lower aligned address */
-	/* get lower aligned address */
-	wp = (addr & ~(info->portwidth - 1));
-
-	/* handle unaligned start */
-	if ((aln = addr - wp) != 0) {
-		cword.l = 0;
-		cp = wp;
-		for (i = 0; i < aln; ++i, ++cp)
-			flash_add_byte (info, &cword, (*(uchar *) cp));
-
-		for (; (i < info->portwidth) && (cnt > 0); i++) {
-			flash_add_byte (info, &cword, *src++);
-			cnt--;
-			cp++;
-		}
-		for (; (cnt == 0) && (i < info->portwidth); ++i, ++cp)
-			flash_add_byte (info, &cword, (*(uchar *) cp));
-		if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
-			return rc;
-		wp = cp;
-	}
-
-	/* handle the aligned part */
-#ifdef CFG_FLASH_USE_BUFFER_WRITE
-	buffered_size = (info->portwidth / info->chipwidth);
-	buffered_size *= info->buffer_size;
-	while (cnt >= info->portwidth) {
-		/* prohibit buffer write when buffer_size is 1 */
-		if (info->buffer_size == 1) {
-			cword.l = 0;
-			for (i = 0; i < info->portwidth; i++)
-				flash_add_byte (info, &cword, *src++);
-			if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
-				return rc;
-			wp += info->portwidth;
-			cnt -= info->portwidth;
-			continue;
-		}
-
-		/* write buffer until next buffered_size aligned boundary */
-		i = buffered_size - (wp % buffered_size);
-		if (i > cnt)
-			i = cnt;
-		if ((rc = flash_write_cfibuffer (info, wp, src, i)) != ERR_OK)
-			return rc;
-		i -= i & (info->portwidth - 1);
-		wp += i;
-		src += i;
-		cnt -= i;
-	}
-#else
-	while (cnt >= info->portwidth) {
-		cword.l = 0;
-		for (i = 0; i < info->portwidth; i++) {
-			flash_add_byte (info, &cword, *src++);
-		}
-		if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
-			return rc;
-		wp += info->portwidth;
-		cnt -= info->portwidth;
-	}
-#endif /* CFG_FLASH_USE_BUFFER_WRITE */
-	if (cnt == 0) {
-		return (0);
-	}
-
-	/*
-	 * handle unaligned tail bytes
-	 */
-	cword.l = 0;
-	for (i = 0, cp = wp; (i < info->portwidth) && (cnt > 0); ++i, ++cp) {
-		flash_add_byte (info, &cword, *src++);
-		--cnt;
-	}
-	for (; i < info->portwidth; ++i, ++cp) {
-		flash_add_byte (info, &cword, (*(uchar *) cp));
-	}
-
-	return flash_write_cfiword (info, wp, cword);
-}
-
-/*-----------------------------------------------------------------------
- */
-#ifdef CFG_FLASH_PROTECTION
-
-int flash_real_protect (flash_info_t * info, long sector, int prot)
-{
-	int retcode = 0;
-
-	flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
-	flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT);
-	if (prot)
-		flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT_SET);
-	else
-		flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT_CLEAR);
-
-	if ((retcode =
-	     flash_full_status_check (info, sector, info->erase_blk_tout,
-				      prot ? "protect" : "unprotect")) == 0) {
-
-		info->protect[sector] = prot;
-
-		/*
-		 * On some of Intel's flash chips (marked via legacy_unlock)
-		 * unprotect unprotects all locking.
-		 */
-		if ((prot == 0) && (info->legacy_unlock)) {
-			flash_sect_t i;
+	int retval;
 
-			for (i = 0; i < info->sector_count; i++) {
-				if (info->protect[i])
-					flash_real_protect (info, i, 1);
-			}
-		}
+	addr = flash_map (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		retval = flash_read8(addr) != flash_read8(addr);
+		break;
+	case FLASH_CFI_16BIT:
+		retval = flash_read16(addr) != flash_read16(addr);
+		break;
+	case FLASH_CFI_32BIT:
+		retval = flash_read32(addr) != flash_read32(addr);
+		break;
+	case FLASH_CFI_64BIT:
+		retval = flash_read64(addr) != flash_read64(addr);
+		break;
+	default:
+		retval = 0;
+		break;
 	}
-	return retcode;
-}
+	flash_unmap(info, sect, offset, addr);
 
-/*-----------------------------------------------------------------------
- * flash_read_user_serial - read the OneTimeProgramming cells
- */
-void flash_read_user_serial (flash_info_t * info, void *buffer, int offset,
-			     int len)
-{
-	uchar *src;
-	uchar *dst;
-
-	dst = buffer;
-	src = flash_make_addr (info, 0, FLASH_OFFSET_USER_PROTECTION);
-	flash_write_cmd (info, 0, 0, FLASH_CMD_READ_ID);
-	memcpy (dst, src + offset, len);
-	flash_write_cmd (info, 0, 0, info->cmd_reset);
-}
-
-/*
- * flash_read_factory_serial - read the device Id from the protection area
- */
-void flash_read_factory_serial (flash_info_t * info, void *buffer, int offset,
-				int len)
-{
-	uchar *src;
-
-	src = flash_make_addr (info, 0, FLASH_OFFSET_INTEL_PROTECTION);
-	flash_write_cmd (info, 0, 0, FLASH_CMD_READ_ID);
-	memcpy (buffer, src + offset, len);
-	flash_write_cmd (info, 0, 0, info->cmd_reset);
+	return retval;
 }
 
-#endif /* CFG_FLASH_PROTECTION */
-
 /*
  * flash_is_busy - check to see if the flash is busy
- * This routine checks the status of the chip and returns true if the chip is busy
+ *
+ * This routine checks the status of the chip and returns true if the
+ * chip is busy.
  */
 static int flash_is_busy (flash_info_t * info, flash_sect_t sect)
 {
 	int retval;
 
 	switch (info->vendor) {
+	case CFI_CMDSET_INTEL_PROG_REGIONS:
 	case CFI_CMDSET_INTEL_STANDARD:
 	case CFI_CMDSET_INTEL_EXTENDED:
 		retval = !flash_isset (info, sect, 0, FLASH_STATUS_DONE);
 		break;
 	case CFI_CMDSET_AMD_STANDARD:
 	case CFI_CMDSET_AMD_EXTENDED:
+#ifdef CONFIG_FLASH_CFI_LEGACY
+	case CFI_CMDSET_AMD_LEGACY:
+#endif
 		retval = flash_toggle (info, sect, 0, AMD_STATUS_TOGGLE);
 		break;
 	default:
@@ -799,7 +687,9 @@
 }
 
 /*-----------------------------------------------------------------------
- * Wait for XSR.7 to be set, if it times out print an error, otherwise do a full status check.
+ * Wait for XSR.7 to be set, if it times out print an error, otherwise
+ * do a full status check.
+ *
  * This routine sets the flash to read-array mode.
  */
 static int flash_full_status_check (flash_info_t * info, flash_sect_t sector,
@@ -809,6 +699,7 @@
 
 	retcode = flash_status_check (info, sector, tout, prompt);
 	switch (info->vendor) {
+	case CFI_CMDSET_INTEL_PROG_REGIONS:
 	case CFI_CMDSET_INTEL_EXTENDED:
 	case CFI_CMDSET_INTEL_STANDARD:
 		if ((retcode == ERR_OK)
@@ -816,12 +707,15 @@
 			retcode = ERR_INVAL;
 			printf ("Flash %s error at address %lx\n", prompt,
 				info->start[sector]);
-			if (flash_isset (info, sector, 0, FLASH_STATUS_ECLBS | FLASH_STATUS_PSLBS)) {
+			if (flash_isset (info, sector, 0, FLASH_STATUS_ECLBS |
+					 FLASH_STATUS_PSLBS)) {
 				puts ("Command Sequence Error.\n");
-			} else if (flash_isset (info, sector, 0, FLASH_STATUS_ECLBS)) {
+			} else if (flash_isset (info, sector, 0,
+						FLASH_STATUS_ECLBS)) {
 				puts ("Block Erase Error.\n");
 				retcode = ERR_NOT_ERASED;
-			} else if (flash_isset (info, sector, 0, FLASH_STATUS_PSLBS)) {
+			} else if (flash_isset (info, sector, 0,
+						FLASH_STATUS_PSLBS)) {
 				puts ("Locking Error\n");
 			}
 			if (flash_isset (info, sector, 0, FLASH_STATUS_DPS)) {
@@ -843,7 +737,7 @@
  */
 static void flash_add_byte (flash_info_t * info, cfiword_t * cword, uchar c)
 {
-#if defined(__LITTLE_ENDIAN)
+#if defined(__LITTLE_ENDIAN) && !defined(CFG_WRITE_SWAPPED_DATA)
 	unsigned short	w;
 	unsigned int	l;
 	unsigned long long ll;
@@ -854,7 +748,7 @@
 		cword->c = c;
 		break;
 	case FLASH_CFI_16BIT:
-#if defined(__LITTLE_ENDIAN)
+#if defined(__LITTLE_ENDIAN) && !defined(CFG_WRITE_SWAPPED_DATA)
 		w = c;
 		w <<= 8;
 		cword->w = (cword->w >> 8) | w;
@@ -863,7 +757,7 @@
 #endif
 		break;
 	case FLASH_CFI_32BIT:
-#if defined(__LITTLE_ENDIAN)
+#if defined(__LITTLE_ENDIAN) && !defined(CFG_WRITE_SWAPPED_DATA)
 		l = c;
 		l <<= 24;
 		cword->l = (cword->l >> 8) | l;
@@ -872,7 +766,7 @@
 #endif
 		break;
 	case FLASH_CFI_64BIT:
-#if defined(__LITTLE_ENDIAN)
+#if defined(__LITTLE_ENDIAN) && !defined(CFG_WRITE_SWAPPED_DATA)
 		ll = c;
 		ll <<= 56;
 		cword->ll = (cword->ll >> 8) | ll;
@@ -883,199 +777,922 @@
 	}
 }
 
-
-/*-----------------------------------------------------------------------
- * make a proper sized command based on the port and chip widths
+/* loop through the sectors from the highest address when the passed
+ * address is greater or equal to the sector address we have a match
  */
-static void flash_make_cmd (flash_info_t * info, uchar cmd, void *cmdbuf)
+static flash_sect_t find_sector (flash_info_t * info, ulong addr)
 {
-	int i;
-	uchar *cp = (uchar *) cmdbuf;
+	flash_sect_t sector;
 
-#if defined(__LITTLE_ENDIAN)
-	for (i = info->portwidth; i > 0; i--)
-#else
-	for (i = 1; i <= info->portwidth; i++)
-#endif
-		*cp++ = (i & (info->chipwidth - 1)) ? '\0' : cmd;
+	for (sector = info->sector_count - 1; sector >= 0; sector--) {
+		if (addr >= info->start[sector])
+			break;
+	}
+	return sector;
 }
 
-/*
- * Write a proper sized command to the correct address
+/*-----------------------------------------------------------------------
  */
-static void flash_write_cmd (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd)
+static int flash_write_cfiword (flash_info_t * info, ulong dest,
+				cfiword_t cword)
 {
+	void *dstaddr;
+	int flag;
 
-	volatile cfiptr_t addr;
-	cfiword_t cword;
+	dstaddr = map_physmem(dest, info->portwidth, MAP_NOCACHE);
 
-	addr.cp = flash_make_addr (info, sect, offset);
-	flash_make_cmd (info, cmd, &cword);
+	/* Check if Flash is (sufficiently) erased */
 	switch (info->portwidth) {
 	case FLASH_CFI_8BIT:
-		debug ("fwc addr %p cmd %x %x 8bit x %d bit\n", addr.cp, cmd,
-		       cword.c, info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
-		*addr.cp = cword.c;
-#ifdef CONFIG_BLACKFIN
-		asm("ssync;");
-#endif
+		flag = ((flash_read8(dstaddr) & cword.c) == cword.c);
 		break;
 	case FLASH_CFI_16BIT:
-		debug ("fwc addr %p cmd %x %4.4x 16bit x %d bit\n", addr.wp,
-		       cmd, cword.w,
-		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
-		*addr.wp = cword.w;
-#ifdef CONFIG_BLACKFIN
-		asm("ssync;");
-#endif
+		flag = ((flash_read16(dstaddr) & cword.w) == cword.w);
 		break;
 	case FLASH_CFI_32BIT:
-		debug ("fwc addr %p cmd %x %8.8lx 32bit x %d bit\n", addr.lp,
-		       cmd, cword.l,
-		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
-		*addr.lp = cword.l;
-#ifdef CONFIG_BLACKFIN
-		asm("ssync;");
-#endif
+		flag = ((flash_read32(dstaddr) & cword.l) == cword.l);
 		break;
 	case FLASH_CFI_64BIT:
-#ifdef DEBUG
-		{
-			char str[20];
+		flag = ((flash_read64(dstaddr) & cword.ll) == cword.ll);
+		break;
+	default:
+		flag = 0;
+		break;
+	}
+	if (!flag) {
+		unmap_physmem(dstaddr, info->portwidth);
+		return ERR_NOT_ERASED;
+	}
 
-			print_longlong (str, cword.ll);
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
 
-			debug ("fwrite addr %p cmd %x %s 64 bit x %d bit\n",
-			       addr.llp, cmd, str,
-			       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
-		}
-#endif
-		*addr.llp = cword.ll;
-#ifdef CONFIG_BLACKFIN
-		asm("ssync;");
+	switch (info->vendor) {
+	case CFI_CMDSET_INTEL_PROG_REGIONS:
+	case CFI_CMDSET_INTEL_EXTENDED:
+	case CFI_CMDSET_INTEL_STANDARD:
+		flash_write_cmd (info, 0, 0, FLASH_CMD_CLEAR_STATUS);
+		flash_write_cmd (info, 0, 0, FLASH_CMD_WRITE);
+		break;
+	case CFI_CMDSET_AMD_EXTENDED:
+	case CFI_CMDSET_AMD_STANDARD:
+#ifdef CONFIG_FLASH_CFI_LEGACY
+	case CFI_CMDSET_AMD_LEGACY:
 #endif
+		flash_unlock_seq (info, 0);
+		flash_write_cmd (info, 0, info->addr_unlock1, AMD_CMD_WRITE);
 		break;
 	}
-}
-
-static void flash_unlock_seq (flash_info_t * info, flash_sect_t sect)
-{
-	flash_write_cmd (info, sect, AMD_ADDR_START, AMD_CMD_UNLOCK_START);
-	flash_write_cmd (info, sect, AMD_ADDR_ACK, AMD_CMD_UNLOCK_ACK);
-}
-
-/*-----------------------------------------------------------------------
- */
-static int flash_isequal (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd)
-{
-	cfiptr_t cptr;
-	cfiword_t cword;
-	int retval;
-
-	cptr.cp = flash_make_addr (info, sect, offset);
-	flash_make_cmd (info, cmd, &cword);
 
-	debug ("is= cmd %x(%c) addr %p ", cmd, cmd, cptr.cp);
 	switch (info->portwidth) {
 	case FLASH_CFI_8BIT:
-		debug ("is= %x %x\n", cptr.cp[0], cword.c);
-		retval = (cptr.cp[0] == cword.c);
+		flash_write8(cword.c, dstaddr);
 		break;
 	case FLASH_CFI_16BIT:
-		debug ("is= %4.4x %4.4x\n", cptr.wp[0], cword.w);
-		retval = (cptr.wp[0] == cword.w);
+		flash_write16(cword.w, dstaddr);
 		break;
 	case FLASH_CFI_32BIT:
-		debug ("is= %8.8lx %8.8lx\n", cptr.lp[0], cword.l);
-		retval = (cptr.lp[0] == cword.l);
+		flash_write32(cword.l, dstaddr);
 		break;
 	case FLASH_CFI_64BIT:
-#ifdef DEBUG
-		{
-			char str1[20];
-			char str2[20];
-
-			print_longlong (str1, cptr.llp[0]);
-			print_longlong (str2, cword.ll);
-			debug ("is= %s %s\n", str1, str2);
-		}
-#endif
-		retval = (cptr.llp[0] == cword.ll);
-		break;
-	default:
-		retval = 0;
+		flash_write64(cword.ll, dstaddr);
 		break;
 	}
-	return retval;
+
+	/* re-enable interrupts if necessary */
+	if (flag)
+		enable_interrupts ();
+
+	unmap_physmem(dstaddr, info->portwidth);
+
+	return flash_full_status_check (info, find_sector (info, dest),
+					info->write_tout, "write");
 }
 
-/*-----------------------------------------------------------------------
- */
-static int flash_isset (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd)
+#ifdef CFG_FLASH_USE_BUFFER_WRITE
+
+static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
+				  int len)
 {
-	cfiptr_t cptr;
-	cfiword_t cword;
-	int retval;
+	flash_sect_t sector;
+	int cnt;
+	int retcode;
+	void *src = cp;
+	void *dst = map_physmem(dest, len, MAP_NOCACHE);
+	void *dst2 = dst;
+	int flag = 0;
+	uint offset = 0;
+	unsigned int shift;
+	uchar write_cmd;
 
-	cptr.cp = flash_make_addr (info, sect, offset);
-	flash_make_cmd (info, cmd, &cword);
 	switch (info->portwidth) {
 	case FLASH_CFI_8BIT:
-		retval = ((cptr.cp[0] & cword.c) == cword.c);
+		shift = 0;
 		break;
 	case FLASH_CFI_16BIT:
-		retval = ((cptr.wp[0] & cword.w) == cword.w);
+		shift = 1;
 		break;
 	case FLASH_CFI_32BIT:
-		retval = ((cptr.lp[0] & cword.l) == cword.l);
+		shift = 2;
 		break;
 	case FLASH_CFI_64BIT:
-		retval = ((cptr.llp[0] & cword.ll) == cword.ll);
+		shift = 3;
 		break;
 	default:
-		retval = 0;
+		retcode = ERR_INVAL;
+		goto out_unmap;
+	}
+
+	cnt = len >> shift;
+
+	while ((cnt-- > 0) && (flag == 0)) {
+		switch (info->portwidth) {
+		case FLASH_CFI_8BIT:
+			flag = ((flash_read8(dst2) & flash_read8(src)) ==
+				flash_read8(src));
+			src += 1, dst2 += 1;
+			break;
+		case FLASH_CFI_16BIT:
+			flag = ((flash_read16(dst2) & flash_read16(src)) ==
+				flash_read16(src));
+			src += 2, dst2 += 2;
+			break;
+		case FLASH_CFI_32BIT:
+			flag = ((flash_read32(dst2) & flash_read32(src)) ==
+				flash_read32(src));
+			src += 4, dst2 += 4;
+			break;
+		case FLASH_CFI_64BIT:
+			flag = ((flash_read64(dst2) & flash_read64(src)) ==
+				flash_read64(src));
+			src += 8, dst2 += 8;
+			break;
+		}
+	}
+	if (!flag) {
+		retcode = ERR_NOT_ERASED;
+		goto out_unmap;
+	}
+
+	src = cp;
+	sector = find_sector (info, dest);
+
+	switch (info->vendor) {
+	case CFI_CMDSET_INTEL_PROG_REGIONS:
+	case CFI_CMDSET_INTEL_STANDARD:
+	case CFI_CMDSET_INTEL_EXTENDED:
+		write_cmd = (info->vendor == CFI_CMDSET_INTEL_PROG_REGIONS) ?
+					FLASH_CMD_WRITE_BUFFER_PROG : FLASH_CMD_WRITE_TO_BUFFER;
+		flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+		flash_write_cmd (info, sector, 0, FLASH_CMD_READ_STATUS);
+		flash_write_cmd (info, sector, 0, write_cmd);
+		retcode = flash_status_check (info, sector,
+					      info->buffer_write_tout,
+					      "write to buffer");
+		if (retcode == ERR_OK) {
+			/* reduce the number of loops by the width of
+			 * the port */
+			cnt = len >> shift;
+			flash_write_cmd (info, sector, 0, cnt - 1);
+			while (cnt-- > 0) {
+				switch (info->portwidth) {
+				case FLASH_CFI_8BIT:
+					flash_write8(flash_read8(src), dst);
+					src += 1, dst += 1;
+					break;
+				case FLASH_CFI_16BIT:
+					flash_write16(flash_read16(src), dst);
+					src += 2, dst += 2;
+					break;
+				case FLASH_CFI_32BIT:
+					flash_write32(flash_read32(src), dst);
+					src += 4, dst += 4;
+					break;
+				case FLASH_CFI_64BIT:
+					flash_write64(flash_read64(src), dst);
+					src += 8, dst += 8;
+					break;
+				default:
+					retcode = ERR_INVAL;
+					goto out_unmap;
+				}
+			}
+			flash_write_cmd (info, sector, 0,
+					 FLASH_CMD_WRITE_BUFFER_CONFIRM);
+			retcode = flash_full_status_check (
+				info, sector, info->buffer_write_tout,
+				"buffer write");
+		}
+
+		break;
+
+	case CFI_CMDSET_AMD_STANDARD:
+	case CFI_CMDSET_AMD_EXTENDED:
+		flash_unlock_seq(info,0);
+
+#ifdef CONFIG_FLASH_SPANSION_S29WS_N
+		offset = ((unsigned long)dst - info->start[sector]) >> shift;
+#endif
+		flash_write_cmd(info, sector, offset, AMD_CMD_WRITE_TO_BUFFER);
+		cnt = len >> shift;
+		flash_write_cmd(info, sector, offset, (uchar)cnt - 1);
+
+		switch (info->portwidth) {
+		case FLASH_CFI_8BIT:
+			while (cnt-- > 0) {
+				flash_write8(flash_read8(src), dst);
+				src += 1, dst += 1;
+			}
+			break;
+		case FLASH_CFI_16BIT:
+			while (cnt-- > 0) {
+				flash_write16(flash_read16(src), dst);
+				src += 2, dst += 2;
+			}
+			break;
+		case FLASH_CFI_32BIT:
+			while (cnt-- > 0) {
+				flash_write32(flash_read32(src), dst);
+				src += 4, dst += 4;
+			}
+			break;
+		case FLASH_CFI_64BIT:
+			while (cnt-- > 0) {
+				flash_write64(flash_read64(src), dst);
+				src += 8, dst += 8;
+			}
+			break;
+		default:
+			retcode = ERR_INVAL;
+			goto out_unmap;
+		}
+
+		flash_write_cmd (info, sector, 0, AMD_CMD_WRITE_BUFFER_CONFIRM);
+		retcode = flash_full_status_check (info, sector,
+						   info->buffer_write_tout,
+						   "buffer write");
+		break;
+
+	default:
+		debug ("Unknown Command Set\n");
+		retcode = ERR_INVAL;
 		break;
 	}
-	return retval;
+
+out_unmap:
+	unmap_physmem(dst, len);
+	return retcode;
+}
+#endif /* CFG_FLASH_USE_BUFFER_WRITE */
+
+
+/*-----------------------------------------------------------------------
+ */
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	int rcode = 0;
+	int prot;
+	flash_sect_t sect;
+
+	if (info->flash_id != FLASH_MAN_CFI) {
+		puts ("Can't erase unknown flash type - aborted\n");
+		return 1;
+	}
+	if ((s_first < 0) || (s_first > s_last)) {
+		puts ("- no sectors to erase\n");
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		putc ('\n');
+	}
+
+
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) { /* not protected */
+			switch (info->vendor) {
+			case CFI_CMDSET_INTEL_PROG_REGIONS:
+			case CFI_CMDSET_INTEL_STANDARD:
+			case CFI_CMDSET_INTEL_EXTENDED:
+				flash_write_cmd (info, sect, 0,
+						 FLASH_CMD_CLEAR_STATUS);
+				flash_write_cmd (info, sect, 0,
+						 FLASH_CMD_BLOCK_ERASE);
+				flash_write_cmd (info, sect, 0,
+						 FLASH_CMD_ERASE_CONFIRM);
+				break;
+			case CFI_CMDSET_AMD_STANDARD:
+			case CFI_CMDSET_AMD_EXTENDED:
+				flash_unlock_seq (info, 0);
+				flash_write_cmd (info, 0,
+						info->addr_unlock1,
+						AMD_CMD_ERASE_START);
+				flash_unlock_seq (info, 0);
+				flash_write_cmd (info, sect, 0,
+						 AMD_CMD_ERASE_SECTOR);
+				break;
+#ifdef CONFIG_FLASH_CFI_LEGACY
+			case CFI_CMDSET_AMD_LEGACY:
+				flash_unlock_seq (info, 0);
+				flash_write_cmd (info, 0, info->addr_unlock1,
+						AMD_CMD_ERASE_START);
+				flash_unlock_seq (info, 0);
+				flash_write_cmd (info, sect, 0,
+						AMD_CMD_ERASE_SECTOR);
+				break;
+#endif
+			default:
+				debug ("Unkown flash vendor %d\n",
+				       info->vendor);
+				break;
+			}
+
+			if (flash_full_status_check
+			    (info, sect, info->erase_blk_tout, "erase")) {
+				rcode = 1;
+			} else
+				putc ('.');
+		}
+	}
+	puts (" done\n");
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	if (info->flash_id != FLASH_MAN_CFI) {
+		puts ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	printf ("%s FLASH (%d x %d)",
+		info->name,
+		(info->portwidth << 3), (info->chipwidth << 3));
+	if (info->size < 1024*1024)
+		printf ("  Size: %ld kB in %d Sectors\n",
+			info->size >> 10, info->sector_count);
+	else
+		printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+	printf ("  ");
+	switch (info->vendor) {
+		case CFI_CMDSET_INTEL_PROG_REGIONS:
+			printf ("Intel Prog Regions");
+			break;
+		case CFI_CMDSET_INTEL_STANDARD:
+			printf ("Intel Standard");
+			break;
+		case CFI_CMDSET_INTEL_EXTENDED:
+			printf ("Intel Extended");
+			break;
+		case CFI_CMDSET_AMD_STANDARD:
+			printf ("AMD Standard");
+			break;
+		case CFI_CMDSET_AMD_EXTENDED:
+			printf ("AMD Extended");
+			break;
+#ifdef CONFIG_FLASH_CFI_LEGACY
+		case CFI_CMDSET_AMD_LEGACY:
+			printf ("AMD Legacy");
+			break;
+#endif
+		default:
+			printf ("Unknown (%d)", info->vendor);
+			break;
+	}
+	printf (" command set, Manufacturer ID: 0x%02X, Device ID: 0x%02X",
+		info->manufacturer_id, info->device_id);
+	if (info->device_id == 0x7E) {
+		printf("%04X", info->device_id2);
+	}
+	printf ("\n  Erase timeout: %ld ms, write timeout: %ld ms\n",
+		info->erase_blk_tout,
+		info->write_tout);
+	if (info->buffer_size > 1) {
+		printf ("  Buffer write timeout: %ld ms, "
+			"buffer size: %d bytes\n",
+		info->buffer_write_tout,
+		info->buffer_size);
+	}
+
+	puts ("\n  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+		if ((i % 5) == 0)
+			printf ("\n");
+#ifdef CFG_FLASH_EMPTY_INFO
+		int k;
+		int size;
+		int erased;
+		volatile unsigned long *flash;
+
+		/*
+		 * Check if whole sector is erased
+		 */
+		size = flash_sector_size(info, i);
+		erased = 1;
+		flash = (volatile unsigned long *) info->start[i];
+		size = size >> 2;	/* divide by 4 for longword access */
+		for (k = 0; k < size; k++) {
+			if (*flash++ != 0xffffffff) {
+				erased = 0;
+				break;
+			}
+		}
+
+		/* print empty and read-only info */
+		printf ("  %08lX %c %s ",
+			info->start[i],
+			erased ? 'E' : ' ',
+			info->protect[i] ? "RO" : "  ");
+#else	/* ! CFG_FLASH_EMPTY_INFO */
+		printf ("  %08lX   %s ",
+			info->start[i],
+			info->protect[i] ? "RO" : "  ");
+#endif
+	}
+	putc ('\n');
+	return;
+}
+
+/*-----------------------------------------------------------------------
+ * This is used in a few places in write_buf() to show programming
+ * progress.  Making it a function is nasty because it needs to do side
+ * effect updates to digit and dots.  Repeated code is nasty too, so
+ * we define it once here.
+ */
+#ifdef CONFIG_FLASH_SHOW_PROGRESS
+#define FLASH_SHOW_PROGRESS(scale, dots, digit, dots_sub) \
+	dots -= dots_sub; \
+	if ((scale > 0) && (dots <= 0)) { \
+		if ((digit % 5) == 0) \
+			printf ("%d", digit / 5); \
+		else \
+			putc ('.'); \
+		digit--; \
+		dots += scale; \
+	}
+#else
+#define FLASH_SHOW_PROGRESS(scale, dots, digit, dots_sub)
+#endif
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong wp;
+	uchar *p;
+	int aln;
+	cfiword_t cword;
+	int i, rc;
+#ifdef CFG_FLASH_USE_BUFFER_WRITE
+	int buffered_size;
+#endif
+#ifdef CONFIG_FLASH_SHOW_PROGRESS
+	int digit = CONFIG_FLASH_SHOW_PROGRESS;
+	int scale = 0;
+	int dots  = 0;
+
+	/*
+	 * Suppress if there are fewer than CONFIG_FLASH_SHOW_PROGRESS writes.
+	 */
+	if (cnt >= CONFIG_FLASH_SHOW_PROGRESS) {
+		scale = (int)((cnt + CONFIG_FLASH_SHOW_PROGRESS - 1) /
+			CONFIG_FLASH_SHOW_PROGRESS);
+	}
+#endif
+
+	/* get lower aligned address */
+	wp = (addr & ~(info->portwidth - 1));
+
+	/* handle unaligned start */
+	if ((aln = addr - wp) != 0) {
+		cword.l = 0;
+		p = map_physmem(wp, info->portwidth, MAP_NOCACHE);
+		for (i = 0; i < aln; ++i)
+			flash_add_byte (info, &cword, flash_read8(p + i));
+
+		for (; (i < info->portwidth) && (cnt > 0); i++) {
+			flash_add_byte (info, &cword, *src++);
+			cnt--;
+		}
+		for (; (cnt == 0) && (i < info->portwidth); ++i)
+			flash_add_byte (info, &cword, flash_read8(p + i));
+
+		rc = flash_write_cfiword (info, wp, cword);
+		unmap_physmem(p, info->portwidth);
+		if (rc != 0)
+			return rc;
+
+		wp += i;
+		FLASH_SHOW_PROGRESS(scale, dots, digit, i);
+	}
+
+	/* handle the aligned part */
+#ifdef CFG_FLASH_USE_BUFFER_WRITE
+	buffered_size = (info->portwidth / info->chipwidth);
+	buffered_size *= info->buffer_size;
+	while (cnt >= info->portwidth) {
+		/* prohibit buffer write when buffer_size is 1 */
+		if (info->buffer_size == 1 || info->buffer_size == 0) {
+			cword.l = 0;
+			for (i = 0; i < info->portwidth; i++)
+				flash_add_byte (info, &cword, *src++);
+			if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
+				return rc;
+			wp += info->portwidth;
+			cnt -= info->portwidth;
+			continue;
+		}
+
+		/* write buffer until next buffered_size aligned boundary */
+		i = buffered_size - (wp % buffered_size);
+		if (i > cnt)
+			i = cnt;
+		if ((rc = flash_write_cfibuffer (info, wp, src, i)) != ERR_OK)
+			return rc;
+		i -= i & (info->portwidth - 1);
+		wp += i;
+		src += i;
+		cnt -= i;
+		FLASH_SHOW_PROGRESS(scale, dots, digit, i);
+	}
+#else
+	while (cnt >= info->portwidth) {
+		cword.l = 0;
+		for (i = 0; i < info->portwidth; i++) {
+			flash_add_byte (info, &cword, *src++);
+		}
+		if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
+			return rc;
+		wp += info->portwidth;
+		cnt -= info->portwidth;
+		FLASH_SHOW_PROGRESS(scale, dots, digit, info->portwidth);
+	}
+#endif /* CFG_FLASH_USE_BUFFER_WRITE */
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	cword.l = 0;
+	p = map_physmem(wp, info->portwidth, MAP_NOCACHE);
+	for (i = 0; (i < info->portwidth) && (cnt > 0); ++i) {
+		flash_add_byte (info, &cword, *src++);
+		--cnt;
+	}
+	for (; i < info->portwidth; ++i)
+		flash_add_byte (info, &cword, flash_read8(p + i));
+	unmap_physmem(p, info->portwidth);
+
+	return flash_write_cfiword (info, wp, cword);
+}
+
+/*-----------------------------------------------------------------------
+ */
+#ifdef CFG_FLASH_PROTECTION
+
+int flash_real_protect (flash_info_t * info, long sector, int prot)
+{
+	int retcode = 0;
+
+	flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+	flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT);
+	if (prot)
+		flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT_SET);
+	else
+		flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT_CLEAR);
+
+	if ((retcode =
+	     flash_full_status_check (info, sector, info->erase_blk_tout,
+				      prot ? "protect" : "unprotect")) == 0) {
+
+		info->protect[sector] = prot;
+
+		/*
+		 * On some of Intel's flash chips (marked via legacy_unlock)
+		 * unprotect unprotects all locking.
+		 */
+		if ((prot == 0) && (info->legacy_unlock)) {
+			flash_sect_t i;
+
+			for (i = 0; i < info->sector_count; i++) {
+				if (info->protect[i])
+					flash_real_protect (info, i, 1);
+			}
+		}
+	}
+	return retcode;
+}
+
+/*-----------------------------------------------------------------------
+ * flash_read_user_serial - read the OneTimeProgramming cells
+ */
+void flash_read_user_serial (flash_info_t * info, void *buffer, int offset,
+			     int len)
+{
+	uchar *src;
+	uchar *dst;
+
+	dst = buffer;
+	src = flash_map (info, 0, FLASH_OFFSET_USER_PROTECTION);
+	flash_write_cmd (info, 0, 0, FLASH_CMD_READ_ID);
+	memcpy (dst, src + offset, len);
+	flash_write_cmd (info, 0, 0, info->cmd_reset);
+	flash_unmap(info, 0, FLASH_OFFSET_USER_PROTECTION, src);
+}
+
+/*
+ * flash_read_factory_serial - read the device Id from the protection area
+ */
+void flash_read_factory_serial (flash_info_t * info, void *buffer, int offset,
+				int len)
+{
+	uchar *src;
+
+	src = flash_map (info, 0, FLASH_OFFSET_INTEL_PROTECTION);
+	flash_write_cmd (info, 0, 0, FLASH_CMD_READ_ID);
+	memcpy (buffer, src + offset, len);
+	flash_write_cmd (info, 0, 0, info->cmd_reset);
+	flash_unmap(info, 0, FLASH_OFFSET_INTEL_PROTECTION, src);
+}
+
+#endif /* CFG_FLASH_PROTECTION */
+
+/*-----------------------------------------------------------------------
+ * Reverse the order of the erase regions in the CFI QRY structure.
+ * This is needed for chips that are either a) correctly detected as
+ * top-boot, or b) buggy.
+ */
+static void cfi_reverse_geometry(struct cfi_qry *qry)
+{
+	unsigned int i, j;
+	u32 tmp;
+
+	for (i = 0, j = qry->num_erase_regions - 1; i < j; i++, j--) {
+		tmp = qry->erase_region_info[i];
+		qry->erase_region_info[i] = qry->erase_region_info[j];
+		qry->erase_region_info[j] = tmp;
+	}
+}
+
+/*-----------------------------------------------------------------------
+ * read jedec ids from device and set corresponding fields in info struct
+ *
+ * Note: assume cfi->vendor, cfi->portwidth and cfi->chipwidth are correct
+ *
+ */
+static void cmdset_intel_read_jedec_ids(flash_info_t *info)
+{
+	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
+	flash_write_cmd(info, 0, 0, FLASH_CMD_READ_ID);
+	udelay(1000); /* some flash are slow to respond */
+	info->manufacturer_id = flash_read_uchar (info,
+					FLASH_OFFSET_MANUFACTURER_ID);
+	info->device_id = flash_read_uchar (info,
+					FLASH_OFFSET_DEVICE_ID);
+	flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
+}
+
+static int cmdset_intel_init(flash_info_t *info, struct cfi_qry *qry)
+{
+	info->cmd_reset = FLASH_CMD_RESET;
+
+	cmdset_intel_read_jedec_ids(info);
+	flash_write_cmd(info, 0, info->cfi_offset, FLASH_CMD_CFI);
+
+#ifdef CFG_FLASH_PROTECTION
+	/* read legacy lock/unlock bit from intel flash */
+	if (info->ext_addr) {
+		info->legacy_unlock = flash_read_uchar (info,
+				info->ext_addr + 5) & 0x08;
+	}
+#endif
+
+	return 0;
+}
+
+static void cmdset_amd_read_jedec_ids(flash_info_t *info)
+{
+	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
+	flash_unlock_seq(info, 0);
+	flash_write_cmd(info, 0, info->addr_unlock1, FLASH_CMD_READ_ID);
+	udelay(1000); /* some flash are slow to respond */
+
+	info->manufacturer_id = flash_read_uchar (info,
+					FLASH_OFFSET_MANUFACTURER_ID);
+
+	switch (info->chipwidth){
+	case FLASH_CFI_8BIT:
+		info->device_id = flash_read_uchar (info,
+						FLASH_OFFSET_DEVICE_ID);
+		if (info->device_id == 0x7E) {
+			/* AMD 3-byte (expanded) device ids */
+			info->device_id2 = flash_read_uchar (info,
+						FLASH_OFFSET_DEVICE_ID2);
+			info->device_id2 <<= 8;
+			info->device_id2 |= flash_read_uchar (info,
+						FLASH_OFFSET_DEVICE_ID3);
+		}
+		break;
+	case FLASH_CFI_16BIT:
+		info->device_id = flash_read_word (info,
+						FLASH_OFFSET_DEVICE_ID);
+		break;
+	default:
+		break;
+	}
+	flash_write_cmd(info, 0, 0, AMD_CMD_RESET);
+}
+
+static int cmdset_amd_init(flash_info_t *info, struct cfi_qry *qry)
+{
+	info->cmd_reset = AMD_CMD_RESET;
+
+	cmdset_amd_read_jedec_ids(info);
+	flash_write_cmd(info, 0, info->cfi_offset, FLASH_CMD_CFI);
+
+	return 0;
+}
+
+#ifdef CONFIG_FLASH_CFI_LEGACY
+void flash_read_jedec_ids (flash_info_t * info)
+{
+	info->manufacturer_id = 0;
+	info->device_id       = 0;
+	info->device_id2      = 0;
+
+	switch (info->vendor) {
+	case CFI_CMDSET_INTEL_PROG_REGIONS:
+	case CFI_CMDSET_INTEL_STANDARD:
+	case CFI_CMDSET_INTEL_EXTENDED:
+		cmdset_intel_read_jedec_ids(info);
+		break;
+	case CFI_CMDSET_AMD_STANDARD:
+	case CFI_CMDSET_AMD_EXTENDED:
+		cmdset_amd_read_jedec_ids(info);
+		break;
+	default:
+		break;
+	}
+}
+
+/*-----------------------------------------------------------------------
+ * Call board code to request info about non-CFI flash.
+ * board_flash_get_legacy needs to fill in at least:
+ * info->portwidth, info->chipwidth and info->interface for Jedec probing.
+ */
+static int flash_detect_legacy(ulong base, int banknum)
+{
+	flash_info_t *info = &flash_info[banknum];
+
+	if (board_flash_get_legacy(base, banknum, info)) {
+		/* board code may have filled info completely. If not, we
+		   use JEDEC ID probing. */
+		if (!info->vendor) {
+			int modes[] = {
+				CFI_CMDSET_AMD_STANDARD,
+				CFI_CMDSET_INTEL_STANDARD
+			};
+			int i;
+
+			for (i = 0; i < sizeof(modes) / sizeof(modes[0]); i++) {
+				int ret = 0;
+				info->vendor = modes[i];
+				info->start[0] = base;
+
+				if (info->vendor == CFI_CMDSET_INTEL_STANDARD) {
+					flash_read_jedec_ids(info);
+					printf("JEDEC PROBE: ID %x %x %x\n",
+							info->manufacturer_id,
+							info->device_id,
+							info->device_id2);
+					ret = jedec_flash_match(info, base);
+				} else {
+					ret = jedec_flash_probe(info, base);
+				}
+				
+				if (ret)
+					break;
+			}
+		}
+
+		switch(info->vendor) {
+		case CFI_CMDSET_INTEL_PROG_REGIONS:
+		case CFI_CMDSET_INTEL_STANDARD:
+		case CFI_CMDSET_INTEL_EXTENDED:
+			info->cmd_reset = FLASH_CMD_RESET;
+			break;
+		case CFI_CMDSET_AMD_STANDARD:
+		case CFI_CMDSET_AMD_EXTENDED:
+		case CFI_CMDSET_AMD_LEGACY:
+			info->cmd_reset = AMD_CMD_RESET;
+			break;
+		}
+		info->flash_id = FLASH_MAN_CFI;
+		return 1;
+	}
+	return 0; /* use CFI */
 }
+#else
+static inline int flash_detect_legacy(ulong base, int banknum)
+{
+	return 0; /* use CFI */
+}
+#endif
 
 /*-----------------------------------------------------------------------
+ * detect if flash is compatible with the Common Flash Interface (CFI)
+ * http://www.jedec.org/download/search/jesd68.pdf
  */
-static int flash_toggle (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd)
+static void flash_read_cfi (flash_info_t *info, void *buf,
+		unsigned int start, size_t len)
 {
-	cfiptr_t cptr;
-	cfiword_t cword;
-	int retval;
+	u8 *p = buf;
+	unsigned int i;
 
-	cptr.cp = flash_make_addr (info, sect, offset);
-	flash_make_cmd (info, cmd, &cword);
-	switch (info->portwidth) {
-	case FLASH_CFI_8BIT:
-		retval = ((cptr.cp[0] & cword.c) != (cptr.cp[0] & cword.c));
-		break;
-	case FLASH_CFI_16BIT:
-		retval = ((cptr.wp[0] & cword.w) != (cptr.wp[0] & cword.w));
-		break;
-	case FLASH_CFI_32BIT:
-		retval = ((cptr.lp[0] & cword.l) != (cptr.lp[0] & cword.l));
-		break;
-	case FLASH_CFI_64BIT:
-		retval = ((cptr.llp[0] & cword.ll) !=
-			  (cptr.llp[0] & cword.ll));
-		break;
-	default:
-		retval = 0;
-		break;
+	for (i = 0; i < len; i++)
+		p[i] = flash_read_uchar(info, start + i);
+}
+
+static int __flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
+{
+	int cfi_offset;
+
+	/* We do not yet know what kind of commandset to use, so we issue
+	   the reset command in both Intel and AMD variants, in the hope
+	   that AMD flash roms ignore the Intel command. */
+	flash_write_cmd (info, 0, 0, AMD_CMD_RESET);
+	flash_write_cmd (info, 0, 0, FLASH_CMD_RESET);
+
+	for (cfi_offset=0;
+	     cfi_offset < sizeof(flash_offset_cfi) / sizeof(uint);
+	     cfi_offset++) {
+		flash_write_cmd (info, 0, flash_offset_cfi[cfi_offset],
+				 FLASH_CMD_CFI);
+		if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
+		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 1, 'R')
+		    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 2, 'Y')) {
+			flash_read_cfi(info, qry, FLASH_OFFSET_CFI_RESP,
+					sizeof(struct cfi_qry));
+			info->interface	= le16_to_cpu(qry->interface_desc);
+
+			info->cfi_offset = flash_offset_cfi[cfi_offset];
+			debug ("device interface is %d\n",
+			       info->interface);
+			debug ("found port %d chip %d ",
+			       info->portwidth, info->chipwidth);
+			debug ("port %d bits chip %d bits\n",
+			       info->portwidth << CFI_FLASH_SHIFT_WIDTH,
+			       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+
+			/* calculate command offsets as in the Linux driver */
+			info->addr_unlock1 = 0x555;
+			info->addr_unlock2 = 0x2aa;
+
+			/*
+			 * modify the unlock address if we are
+			 * in compatibility mode
+			 */
+			if (	/* x8/x16 in x8 mode */
+				((info->chipwidth == FLASH_CFI_BY8) &&
+					(info->interface == FLASH_CFI_X8X16)) ||
+				/* x16/x32 in x16 mode */
+				((info->chipwidth == FLASH_CFI_BY16) &&
+					(info->interface == FLASH_CFI_X16X32)))
+			{
+				info->addr_unlock1 = 0xaaa;
+				info->addr_unlock2 = 0x555;
+			}
+
+			info->name = "CFI conformant";
+			return 1;
+		}
 	}
-	return retval;
+
+	return 0;
 }
 
-/*-----------------------------------------------------------------------
- * detect if flash is compatible with the Common Flash Interface (CFI)
- * http://www.jedec.org/download/search/jesd68.pdf
- *
-*/
-static int flash_detect_cfi (flash_info_t * info)
+static int flash_detect_cfi (flash_info_t * info, struct cfi_qry *qry)
 {
 	debug ("flash detect cfi\n");
 
@@ -1083,29 +1700,58 @@
 	     info->portwidth <= FLASH_CFI_64BIT; info->portwidth <<= 1) {
 		for (info->chipwidth = FLASH_CFI_BY8;
 		     info->chipwidth <= info->portwidth;
-		     info->chipwidth <<= 1) {
-			flash_write_cmd (info, 0, 0, info->cmd_reset);
-			flash_write_cmd (info, 0, FLASH_OFFSET_CFI, FLASH_CMD_CFI);
-			if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
-			    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 1, 'R')
-			    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 2, 'Y')) {
-				info->interface = flash_read_ushort (info, 0, FLASH_OFFSET_INTERFACE);
-				debug ("device interface is %d\n",
-				       info->interface);
-				debug ("found port %d chip %d ",
-				       info->portwidth, info->chipwidth);
-				debug ("port %d bits chip %d bits\n",
-				       info->portwidth << CFI_FLASH_SHIFT_WIDTH,
-				       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		     info->chipwidth <<= 1)
+			if (__flash_detect_cfi(info, qry))
 				return 1;
-			}
-		}
 	}
 	debug ("not found\n");
 	return 0;
 }
 
 /*
+ * Manufacturer-specific quirks. Add workarounds for geometry
+ * reversal, etc. here.
+ */
+static void flash_fixup_amd(flash_info_t *info, struct cfi_qry *qry)
+{
+	/* check if flash geometry needs reversal */
+	if (qry->num_erase_regions > 1) {
+		/* reverse geometry if top boot part */
+		if (info->cfi_version < 0x3131) {
+			/* CFI < 1.1, try to guess from device id */
+			if ((info->device_id & 0x80) != 0)
+				cfi_reverse_geometry(qry);
+		} else if (flash_read_uchar(info, info->ext_addr + 0xf) == 3) {
+			/* CFI >= 1.1, deduct from top/bottom flag */
+			/* note: ext_addr is valid since cfi_version > 0 */
+			cfi_reverse_geometry(qry);
+		}
+	}
+}
+
+static void flash_fixup_atmel(flash_info_t *info, struct cfi_qry *qry)
+{
+	int reverse_geometry = 0;
+
+	/* Check the "top boot" bit in the PRI */
+	if (info->ext_addr && !(flash_read_uchar(info, info->ext_addr + 6) & 1))
+		reverse_geometry = 1;
+
+	/* AT49BV6416(T) list the erase regions in the wrong order.
+	 * However, the device ID is identical with the non-broken
+	 * AT49BV642D since u-boot only reads the low byte (they
+	 * differ in the high byte.) So leave out this fixup for now.
+	 */
+#if 0
+	if (info->device_id == 0xd6 || info->device_id == 0xd2)
+		reverse_geometry = !reverse_geometry;
+#endif
+
+	if (reverse_geometry)
+		cfi_reverse_geometry(qry);
+}
+
+/*
  * The following code cannot be run from FLASH!
  *
  */
@@ -1120,45 +1766,78 @@
 	uchar num_erase_regions;
 	int erase_region_size;
 	int erase_region_count;
+	struct cfi_qry qry;
+
+	memset(&qry, 0, sizeof(qry));
+
+	info->ext_addr = 0;
+	info->cfi_version = 0;
 #ifdef CFG_FLASH_PROTECTION
-	int ext_addr;
 	info->legacy_unlock = 0;
 #endif
 
 	info->start[0] = base;
 
-	if (flash_detect_cfi (info)) {
-		info->vendor = flash_read_ushort (info, 0, FLASH_OFFSET_PRIMARY_VENDOR);
+	if (flash_detect_cfi (info, &qry)) {
+		info->vendor = le16_to_cpu(qry.p_id);
+		info->ext_addr = le16_to_cpu(qry.p_adr);
+		num_erase_regions = qry.num_erase_regions;
+
+		if (info->ext_addr) {
+			info->cfi_version = (ushort) flash_read_uchar (info,
+						info->ext_addr + 3) << 8;
+			info->cfi_version |= (ushort) flash_read_uchar (info,
+						info->ext_addr + 4);
+		}
+
 #ifdef DEBUG
-		flash_printqry (info, 0);
+		flash_printqry (&qry);
 #endif
+
 		switch (info->vendor) {
+		case CFI_CMDSET_INTEL_PROG_REGIONS:
 		case CFI_CMDSET_INTEL_STANDARD:
 		case CFI_CMDSET_INTEL_EXTENDED:
-		default:
-			info->cmd_reset = FLASH_CMD_RESET;
-#ifdef CFG_FLASH_PROTECTION
-			/* read legacy lock/unlock bit from intel flash */
-			ext_addr = flash_read_ushort (info, 0,
-						      FLASH_OFFSET_EXT_QUERY_T_P_ADDR);
-			info->legacy_unlock =
-				flash_read_uchar (info, ext_addr + 5) & 0x08;
-#endif
+			cmdset_intel_init(info, &qry);
 			break;
 		case CFI_CMDSET_AMD_STANDARD:
 		case CFI_CMDSET_AMD_EXTENDED:
-			info->cmd_reset = AMD_CMD_RESET;
+			cmdset_amd_init(info, &qry);
+			break;
+		default:
+			printf("CFI: Unknown command set 0x%x\n",
+					info->vendor);
+			/*
+			 * Unfortunately, this means we don't know how
+			 * to get the chip back to Read mode. Might
+			 * as well try an Intel-style reset...
+			 */
+			flash_write_cmd(info, 0, 0, FLASH_CMD_RESET);
+			return 0;
+		}
+
+		/* Do manufacturer-specific fixups */
+		switch (info->manufacturer_id) {
+		case 0x0001:
+			flash_fixup_amd(info, &qry);
+			break;
+		case 0x001f:
+			flash_fixup_atmel(info, &qry);
 			break;
 		}
 
 		debug ("manufacturer is %d\n", info->vendor);
+		debug ("manufacturer id is 0x%x\n", info->manufacturer_id);
+		debug ("device id is 0x%x\n", info->device_id);
+		debug ("device id2 is 0x%x\n", info->device_id2);
+		debug ("cfi version is 0x%04x\n", info->cfi_version);
+
 		size_ratio = info->portwidth / info->chipwidth;
 		/* if the chip is x8/x16 reduce the ratio by half */
 		if ((info->interface == FLASH_CFI_X8X16)
 		    && (info->chipwidth == FLASH_CFI_BY8)) {
 			size_ratio >>= 1;
 		}
-		num_erase_regions = flash_read_uchar (info, FLASH_OFFSET_NUM_ERASE_REGIONS);
 		debug ("size_ratio %d port %d bits chip %d bits\n",
 		       size_ratio, info->portwidth << CFI_FLASH_SHIFT_WIDTH,
 		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
@@ -1171,23 +1850,30 @@
 					num_erase_regions, NUM_ERASE_REGIONS);
 				break;
 			}
-			tmp = flash_read_long (info, 0,
-					       FLASH_OFFSET_ERASE_REGIONS +
-					       i * 4);
+
+			tmp = le32_to_cpu(qry.erase_region_info[i]);
+			debug("erase region %u: 0x%08lx\n", i, tmp);
+
+			erase_region_count = (tmp & 0xffff) + 1;
+			tmp >>= 16;
 			erase_region_size =
 				(tmp & 0xffff) ? ((tmp & 0xffff) * 256) : 128;
-			tmp >>= 16;
-			erase_region_count = (tmp & 0xffff) + 1;
 			debug ("erase_region_count = %d erase_region_size = %d\n",
 				erase_region_count, erase_region_size);
 			for (j = 0; j < erase_region_count; j++) {
+				if (sect_cnt >= CFG_MAX_FLASH_SECT) {
+					printf("ERROR: too many flash sectors\n");
+					break;
+				}
 				info->start[sect_cnt] = sector;
 				sector += (erase_region_size * size_ratio);
 
 				/*
-				 * Only read protection status from supported devices (intel...)
+				 * Only read protection status from
+				 * supported devices (intel...)
 				 */
 				switch (info->vendor) {
+				case CFI_CMDSET_INTEL_PROG_REGIONS:
 				case CFI_CMDSET_INTEL_EXTENDED:
 				case CFI_CMDSET_INTEL_STANDARD:
 					info->protect[sect_cnt] =
@@ -1196,7 +1882,8 @@
 							     FLASH_STATUS_PROTECT);
 					break;
 				default:
-					info->protect[sect_cnt] = 0; /* default: not protected */
+					/* default: not protected */
+					info->protect[sect_cnt] = 0;
 				}
 
 				sect_cnt++;
@@ -1204,20 +1891,27 @@
 		}
 
 		info->sector_count = sect_cnt;
+		info->size = 1 << qry.dev_size;
 		/* multiply the size by the number of chips */
-		info->size = (1 << flash_read_uchar (info, FLASH_OFFSET_SIZE)) * size_ratio;
-		info->buffer_size = (1 << flash_read_ushort (info, 0, FLASH_OFFSET_BUFFER_SIZE));
-		tmp = 1 << flash_read_uchar (info, FLASH_OFFSET_ETOUT);
-		info->erase_blk_tout = (tmp * (1 << flash_read_uchar (info, FLASH_OFFSET_EMAX_TOUT)));
-		tmp = (1 << flash_read_uchar (info, FLASH_OFFSET_WBTOUT)) *
-			(1 << flash_read_uchar (info, FLASH_OFFSET_WBMAX_TOUT));
-		info->buffer_write_tout = tmp / 1000 + (tmp % 1000 ? 1 : 0); /* round up when converting to ms */
-		tmp = (1 << flash_read_uchar (info, FLASH_OFFSET_WTOUT)) *
-		      (1 << flash_read_uchar (info, FLASH_OFFSET_WMAX_TOUT));
-		info->write_tout = tmp / 1000 + (tmp % 1000 ? 1 : 0); /* round up when converting to ms */
+		info->size *= size_ratio;
+		info->buffer_size = 1 << le16_to_cpu(qry.max_buf_write_size);
+		tmp = 1 << qry.block_erase_timeout_typ;
+		info->erase_blk_tout = tmp *
+			(1 << qry.block_erase_timeout_max);
+		tmp = (1 << qry.buf_write_timeout_typ) *
+			(1 << qry.buf_write_timeout_max);
+
+		/* round up when converting to ms */
+		info->buffer_write_tout = (tmp + 999) / 1000;
+		tmp = (1 << qry.word_write_timeout_typ) *
+			(1 << qry.word_write_timeout_max);
+		/* round up when converting to ms */
+		info->write_tout = (tmp + 999) / 1000;
 		info->flash_id = FLASH_MAN_CFI;
-		if ((info->interface == FLASH_CFI_X8X16) && (info->chipwidth == FLASH_CFI_BY8)) {
-			info->portwidth >>= 1;	/* XXX - Need to test on x8/x16 in parallel. */
+		if ((info->interface == FLASH_CFI_X8X16) &&
+		    (info->chipwidth == FLASH_CFI_BY8)) {
+			/* XXX - Need to test on x8/x16 in parallel. */
+			info->portwidth >>= 1;
 		}
 	}
 
@@ -1225,203 +1919,127 @@
 	return (info->size);
 }
 
-/* loop through the sectors from the highest address
- * when the passed address is greater or equal to the sector address
- * we have a match
- */
-static flash_sect_t find_sector (flash_info_t * info, ulong addr)
-{
-	flash_sect_t sector;
-
-	for (sector = info->sector_count - 1; sector >= 0; sector--) {
-		if (addr >= info->start[sector])
-			break;
-	}
-	return sector;
-}
-
 /*-----------------------------------------------------------------------
  */
-static int flash_write_cfiword (flash_info_t * info, ulong dest,
-				cfiword_t cword)
+unsigned long flash_init (void)
 {
-	cfiptr_t ctladdr;
-	cfiptr_t cptr;
-	int flag;
-
-	ctladdr.cp = flash_make_addr (info, 0, 0);
-	cptr.cp = (uchar *) dest;
-
+	unsigned long size = 0;
+	int i;
+#if defined(CFG_FLASH_AUTOPROTECT_LIST)
+	struct apl_s {
+		ulong start;
+		ulong size;
+	} apl[] = CFG_FLASH_AUTOPROTECT_LIST;
+#endif
 
-	/* Check if Flash is (sufficiently) erased */
-	switch (info->portwidth) {
-	case FLASH_CFI_8BIT:
-		flag = ((cptr.cp[0] & cword.c) == cword.c);
-		break;
-	case FLASH_CFI_16BIT:
-		flag = ((cptr.wp[0] & cword.w) == cword.w);
-		break;
-	case FLASH_CFI_32BIT:
-		flag = ((cptr.lp[0] & cword.l) == cword.l);
-		break;
-	case FLASH_CFI_64BIT:
-		flag = ((cptr.llp[0] & cword.ll) == cword.ll);
-		break;
-	default:
-		return 2;
-	}
-	if (!flag)
-		return 2;
+#ifdef CFG_FLASH_PROTECTION
+	char *s = getenv("unlock");
+#endif
 
-	/* Disable interrupts which might cause a timeout here */
-	flag = disable_interrupts ();
+#define BANK_BASE(i)	(((unsigned long [CFI_MAX_FLASH_BANKS])CFG_FLASH_BANKS_LIST)[i])
 
-	switch (info->vendor) {
-	case CFI_CMDSET_INTEL_EXTENDED:
-	case CFI_CMDSET_INTEL_STANDARD:
-		flash_write_cmd (info, 0, 0, FLASH_CMD_CLEAR_STATUS);
-		flash_write_cmd (info, 0, 0, FLASH_CMD_WRITE);
-		break;
-	case CFI_CMDSET_AMD_EXTENDED:
-	case CFI_CMDSET_AMD_STANDARD:
-		flash_unlock_seq (info, 0);
-		flash_write_cmd (info, 0, AMD_ADDR_START, AMD_CMD_WRITE);
-		break;
-	}
+	memset(flash_info, 0, sizeof(flash_info));
 
-	switch (info->portwidth) {
-	case FLASH_CFI_8BIT:
-		cptr.cp[0] = cword.c;
-		break;
-	case FLASH_CFI_16BIT:
-		cptr.wp[0] = cword.w;
-		break;
-	case FLASH_CFI_32BIT:
-		cptr.lp[0] = cword.l;
-		break;
-	case FLASH_CFI_64BIT:
-		cptr.llp[0] = cword.ll;
-		break;
-	}
+	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
 
-	/* re-enable interrupts if necessary */
-	if (flag)
-		enable_interrupts ();
+		if (!flash_detect_legacy (BANK_BASE(i), i))
+			flash_get_size (BANK_BASE(i), i);
+		size += flash_info[i].size;
+		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
+#ifndef CFG_FLASH_QUIET_TEST
+			printf ("## Unknown FLASH on Bank %d "
+				"- Size = 0x%08lx = %ld MB\n",
+				i+1, flash_info[i].size,
+				flash_info[i].size << 20);
+#endif /* CFG_FLASH_QUIET_TEST */
+		}
+#ifdef CFG_FLASH_PROTECTION
+		else if ((s != NULL) && (strcmp(s, "yes") == 0)) {
+			/*
+			 * Only the U-Boot image and it's environment
+			 * is protected, all other sectors are
+			 * unprotected (unlocked) if flash hardware
+			 * protection is used (CFG_FLASH_PROTECTION)
+			 * and the environment variable "unlock" is
+			 * set to "yes".
+			 */
+			if (flash_info[i].legacy_unlock) {
+				int k;
 
-	return flash_full_status_check (info, find_sector (info, dest),
-					info->write_tout, "write");
-}
+				/*
+				 * Disable legacy_unlock temporarily,
+				 * since flash_real_protect would
+				 * relock all other sectors again
+				 * otherwise.
+				 */
+				flash_info[i].legacy_unlock = 0;
 
-#ifdef CFG_FLASH_USE_BUFFER_WRITE
+				/*
+				 * Legacy unlocking (e.g. Intel J3) ->
+				 * unlock only one sector. This will
+				 * unlock all sectors.
+				 */
+				flash_real_protect (&flash_info[i], 0, 0);
 
-static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
-				  int len)
-{
-	flash_sect_t sector;
-	int cnt;
-	int retcode;
-	volatile cfiptr_t src;
-	volatile cfiptr_t dst;
+				flash_info[i].legacy_unlock = 1;
 
-	switch (info->vendor) {
-	case CFI_CMDSET_INTEL_STANDARD:
-	case CFI_CMDSET_INTEL_EXTENDED:
-		src.cp = cp;
-		dst.cp = (uchar *) dest;
-		sector = find_sector (info, dest);
-		flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
-		flash_write_cmd (info, sector, 0, FLASH_CMD_WRITE_TO_BUFFER);
-		if ((retcode = flash_status_check (info, sector, info->buffer_write_tout,
-						   "write to buffer")) == ERR_OK) {
-			/* reduce the number of loops by the width of the port	*/
-			switch (info->portwidth) {
-			case FLASH_CFI_8BIT:
-				cnt = len;
-				break;
-			case FLASH_CFI_16BIT:
-				cnt = len >> 1;
-				break;
-			case FLASH_CFI_32BIT:
-				cnt = len >> 2;
-				break;
-			case FLASH_CFI_64BIT:
-				cnt = len >> 3;
-				break;
-			default:
-				return ERR_INVAL;
-				break;
-			}
-			flash_write_cmd (info, sector, 0, (uchar) cnt - 1);
-			while (cnt-- > 0) {
-				switch (info->portwidth) {
-				case FLASH_CFI_8BIT:
-					*dst.cp++ = *src.cp++;
-					break;
-				case FLASH_CFI_16BIT:
-					*dst.wp++ = *src.wp++;
-					break;
-				case FLASH_CFI_32BIT:
-					*dst.lp++ = *src.lp++;
-					break;
-				case FLASH_CFI_64BIT:
-					*dst.llp++ = *src.llp++;
-					break;
-				default:
-					return ERR_INVAL;
-					break;
-				}
+				/*
+				 * Manually mark other sectors as
+				 * unlocked (unprotected)
+				 */
+				for (k = 1; k < flash_info[i].sector_count; k++)
+					flash_info[i].protect[k] = 0;
+			} else {
+				/*
+				 * No legancy unlocking -> unlock all sectors
+				 */
+				flash_protect (FLAG_PROTECT_CLEAR,
+					       flash_info[i].start[0],
+					       flash_info[i].start[0]
+					       + flash_info[i].size - 1,
+					       &flash_info[i]);
 			}
-			flash_write_cmd (info, sector, 0,
-					 FLASH_CMD_WRITE_BUFFER_CONFIRM);
-			retcode = flash_full_status_check (info, sector,
-							   info->buffer_write_tout,
-							   "buffer write");
 		}
-		return retcode;
-
-	case CFI_CMDSET_AMD_STANDARD:
-	case CFI_CMDSET_AMD_EXTENDED:
-		src.cp = cp;
-		dst.cp = (uchar *) dest;
-		sector = find_sector (info, dest);
+#endif /* CFG_FLASH_PROTECTION */
+	}
 
-		flash_unlock_seq(info,0);
-		flash_write_cmd (info, sector, 0, AMD_CMD_WRITE_TO_BUFFER);
+	/* Monitor protection ON by default */
+#if (CFG_MONITOR_BASE >= CFG_FLASH_BASE)
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_MONITOR_BASE,
+		       CFG_MONITOR_BASE + monitor_flash_len  - 1,
+		       flash_get_info(CFG_MONITOR_BASE));
+#endif
 
-		switch (info->portwidth) {
-		case FLASH_CFI_8BIT:
-			cnt = len;
-			flash_write_cmd (info, sector, 0,  (uchar) cnt - 1);
-			while (cnt-- > 0) *dst.cp++ = *src.cp++;
-			break;
-		case FLASH_CFI_16BIT:
-			cnt = len >> 1;
-			flash_write_cmd (info, sector, 0,  (uchar) cnt - 1);
-			while (cnt-- > 0) *dst.wp++ = *src.wp++;
-			break;
-		case FLASH_CFI_32BIT:
-			cnt = len >> 2;
-			flash_write_cmd (info, sector, 0,  (uchar) cnt - 1);
-			while (cnt-- > 0) *dst.lp++ = *src.lp++;
-			break;
-		case FLASH_CFI_64BIT:
-			cnt = len >> 3;
-			flash_write_cmd (info, sector, 0,  (uchar) cnt - 1);
-			while (cnt-- > 0) *dst.llp++ = *src.llp++;
-			break;
-		default:
-			return ERR_INVAL;
-		}
+	/* Environment protection ON by default */
+#ifdef CFG_ENV_IS_IN_FLASH
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_ENV_ADDR,
+		       CFG_ENV_ADDR + CFG_ENV_SECT_SIZE - 1,
+		       flash_get_info(CFG_ENV_ADDR));
+#endif
 
-		flash_write_cmd (info, sector, 0, AMD_CMD_WRITE_BUFFER_CONFIRM);
-		retcode = flash_full_status_check (info, sector, info->buffer_write_tout,
-						   "buffer write");
-		return retcode;
+	/* Redundant environment protection ON by default */
+#ifdef CFG_ENV_ADDR_REDUND
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_ENV_ADDR_REDUND,
+		       CFG_ENV_ADDR_REDUND + CFG_ENV_SIZE_REDUND - 1,
+		       flash_get_info(CFG_ENV_ADDR_REDUND));
+#endif
 
-	default:
-		debug ("Unknown Command Set\n");
-		return ERR_INVAL;
+#if defined(CFG_FLASH_AUTOPROTECT_LIST)
+	for (i = 0; i < (sizeof(apl) / sizeof(struct apl_s)); i++) {
+		debug("autoprotecting from %08x to %08x\n",
+		      apl[i].start, apl[i].start + apl[i].size - 1);
+		flash_protect (FLAG_PROTECT_SET,
+			       apl[i].start,
+			       apl[i].start + apl[i].size - 1,
+			       flash_get_info(apl[i].start));
 	}
+#endif
+	return (size);
 }
-#endif /* CFG_FLASH_USE_BUFFER_WRITE */
+
 #endif /* CFG_FLASH_CFI */
diff -urN u-boot-1.1.6/drivers/dm9000x.c u-boot-1.1.6_fdt/drivers/dm9000x.c
--- u-boot-1.1.6/drivers/dm9000x.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/dm9000x.c	2018-10-22 15:53:21.549641225 +0800
@@ -17,17 +17,17 @@
   (C)Copyright 1997-1998 DAVICOM Semiconductor,Inc. All Rights Reserved.
 
 V0.11	06/20/2001	REG_0A bit3=1, default enable BP with DA match
-	06/22/2001 	Support DM9801 progrmming
-	 	 	E3: R25 = ((R24 + NF) & 0x00ff) | 0xf000
-		 	E4: R25 = ((R24 + NF) & 0x00ff) | 0xc200
-     		R17 = (R17 & 0xfff0) | NF + 3
-		 	E5: R25 = ((R24 + NF - 3) & 0x00ff) | 0xc200
-     		R17 = (R17 & 0xfff0) | NF
+	06/22/2001	Support DM9801 progrmming
+			E3: R25 = ((R24 + NF) & 0x00ff) | 0xf000
+			E4: R25 = ((R24 + NF) & 0x00ff) | 0xc200
+		R17 = (R17 & 0xfff0) | NF + 3
+			E5: R25 = ((R24 + NF - 3) & 0x00ff) | 0xc200
+		R17 = (R17 & 0xfff0) | NF
 
-v1.00               	modify by simon 2001.9.5
+v1.00			modify by simon 2001.9.5
 	                change for kernel 2.4.x
 
-v1.1   11/09/2001      	fix force mode bug
+v1.1   11/09/2001	fix force mode bug
 
 v1.2   03/18/2003       Weilun Huang <weilun_huang@davicom.com.tw>:
 			Fixed phy reset.
@@ -36,17 +36,32 @@
 
 --------------------------------------
 
-       12/15/2003       Initial port to u-boot by Sascha Hauer <saschahauer@web.de>
+       12/15/2003       Initial port to u-boot by
+       			Sascha Hauer <saschahauer@web.de>
+
+       06/03/2008	Remy Bohmer <linux@bohmer.net>
+			- Fixed the driver to work with DM9000A.
+			  (check on ISR receive status bit before reading the
+			  FIFO as described in DM9000 programming guide and
+			  application notes)
+			- Added autodetect of databus width.
+			- Made debug code compile again.
+			- Adapt eth_send such that it matches the DM9000*
+			  application notes. Needed to make it work properly
+			  for DM9000A.
+			- Adapted reset procedure to match DM9000 application
+			  notes (i.e. double reset)
+			- some minor code cleanups
+			These changes are tested with DM9000{A,EP,E} together
+			with a 200MHz Atmel AT91SAM92161 core
 
 TODO: Homerun NIC and longrun NIC are not functional, only internal at the
       moment.
 */
-
 #include <common.h>
 #include <command.h>
 #include <net.h>
 #include <asm/io.h>
-
 #ifdef CONFIG_DRIVER_DM9000
 
 #include "dm9000x.h"
@@ -59,10 +74,22 @@
 /* #define CONFIG_DM9000_DEBUG */
 
 #ifdef CONFIG_DM9000_DEBUG
-#define DM9000_DBG(fmt,args...) printf(fmt ,##args)
-#else				/*  */
+#define DM9000_DBG(fmt,args...) printf(fmt, ##args)
+#define DM9000_DMP_PACKET(func,packet,length)  \
+	do { \
+		int i; 							\
+		printf(func ": length: %d\n", length);			\
+		for (i = 0; i < length; i++) {				\
+			if (i % 8 == 0)					\
+				printf("\n%s: %02x: ", func, i);	\
+			printf("%02x ", ((unsigned char *) packet)[i]);	\
+		} printf("\n");						\
+	} while(0)
+#else
 #define DM9000_DBG(fmt,args...)
-#endif				/*  */
+#define DM9000_DMP_PACKET(func,packet,length)
+#endif
+
 enum DM9000_PHY_mode { DM9000_10MHD = 0, DM9000_100MHD =
 	    1, DM9000_10MFD = 4, DM9000_100MFD = 5, DM9000_AUTO =
 	    8, DM9000_1M_HPNA = 0x10
@@ -84,8 +111,11 @@
 	u8 device_wait_reset;	/* device state */
 	u8 nic_type;		/* NIC type */
 	unsigned char srom[128];
+	void (*outblk)(volatile void *data_ptr, int count);
+	void (*inblk)(void *data_ptr, int count);
+	void (*rx_status)(u16 *RxStatus, u16 *RxLen);
 } board_info_t;
-board_info_t dmfe_info;
+static board_info_t dm9000_info;
 
 /* For module input parameter */
 static int media_mode = DM9000_AUTO;
@@ -99,7 +129,7 @@
 static int dm9000_probe(void);
 static u16 phy_read(int);
 static void phy_write(int, u16);
-static u16 read_srom_word(int);
+u16 read_srom_word(int);
 static u8 DM9000_ior(int);
 static void DM9000_iow(int reg, u8 value);
 
@@ -112,6 +142,16 @@
 #define DM9000_inw(r) (*(volatile u16 *)r)
 #define DM9000_inl(r) (*(volatile u32 *)r)
 
+static inline int is_zero_ether_addr(const u8 *addr)
+{
+	return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
+}
+
+static inline int is_multicast_ether_addr(const u8 *addr)
+{
+	return (0x01 & addr[0]);
+}
+
 #ifdef CONFIG_DM9000_DEBUG
 static void
 dump_regs(void)
@@ -124,10 +164,85 @@
 	DM9000_DBG("TSRII (0x04): %02x\n", DM9000_ior(4));
 	DM9000_DBG("RCR   (0x05): %02x\n", DM9000_ior(5));
 	DM9000_DBG("RSR   (0x06): %02x\n", DM9000_ior(6));
-	DM9000_DBG("ISR   (0xFE): %02x\n", DM9000_ior(ISR));
+	DM9000_DBG("ISR   (0xFE): %02x\n", DM9000_ior(DM9000_ISR));
 	DM9000_DBG("\n");
 }
-#endif				/*  */
+#endif
+
+static void dm9000_outblk_8bit(volatile void *data_ptr, int count)
+{
+	int i;
+	for (i = 0; i < count; i++)
+		DM9000_outb((((u8 *) data_ptr)[i] & 0xff), DM9000_DATA);
+}
+
+static void dm9000_outblk_16bit(volatile void *data_ptr, int count)
+{
+	int i;
+	u32 tmplen = (count + 1) / 2;
+
+	for (i = 0; i < tmplen; i++)
+		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);
+}
+static void dm9000_outblk_32bit(volatile void *data_ptr, int count)
+{
+	int i;
+	u32 tmplen = (count + 3) / 4;
+
+	for (i = 0; i < tmplen; i++)
+		DM9000_outl(((u32 *) data_ptr)[i], DM9000_DATA);
+}
+
+static void dm9000_inblk_8bit(void *data_ptr, int count)
+{
+	int i;
+	for (i = 0; i < count; i++)
+		((u8 *) data_ptr)[i] = DM9000_inb(DM9000_DATA);
+}
+
+static void dm9000_inblk_16bit(void *data_ptr, int count)
+{
+	int i;
+	u32 tmplen = (count + 1) / 2;
+
+	for (i = 0; i < tmplen; i++)
+		((u16 *) data_ptr)[i] = DM9000_inw(DM9000_DATA);
+}
+static void dm9000_inblk_32bit(void *data_ptr, int count)
+{
+	int i;
+	u32 tmplen = (count + 3) / 4;
+
+	for (i = 0; i < tmplen; i++)
+		((u32 *) data_ptr)[i] = DM9000_inl(DM9000_DATA);
+}
+
+static void dm9000_rx_status_32bit(u16 *RxStatus, u16 *RxLen)
+{
+	u32 tmpdata;
+
+	DM9000_outb(DM9000_MRCMD, DM9000_IO);
+
+	tmpdata = DM9000_inl(DM9000_DATA);
+	*RxStatus = tmpdata;
+	*RxLen = tmpdata >> 16;
+}
+
+static void dm9000_rx_status_16bit(u16 *RxStatus, u16 *RxLen)
+{
+	DM9000_outb(DM9000_MRCMD, DM9000_IO);
+
+	*RxStatus = DM9000_inw(DM9000_DATA);
+	*RxLen = DM9000_inw(DM9000_DATA);
+}
+
+static void dm9000_rx_status_8bit(u16 *RxStatus, u16 *RxLen)
+{
+	DM9000_outb(DM9000_MRCMD, DM9000_IO);
+
+	*RxStatus = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
+	*RxLen = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
+}
 
 /*
   Search DM9000 board, allocate space and register it
@@ -236,7 +351,7 @@
 static void
 identify_nic(void)
 {
-	struct board_info *db = &dmfe_info;	/* Point a board information structure */
+	struct board_info *db = &dm9000_info;
 	u16 phy_reg3;
 	DM9000_iow(DM9000_NCR, NCR_EXT_PHY);
 	phy_reg3 = phy_read(3);
@@ -263,9 +378,35 @@
 static void
 dm9000_reset(void)
 {
-	DM9000_DBG("resetting\n");
-	DM9000_iow(DM9000_NCR, NCR_RST);
-	udelay(1000);		/* delay 1ms */
+	DM9000_DBG("resetting DM9000\n");
+
+	/* Reset DM9000,
+	   see DM9000 Application Notes V1.22 Jun 11, 2004 page 29 */
+
+	/* DEBUG: Make all GPIO pins outputs */
+	DM9000_iow(DM9000_GPCR, 0x0F);
+	/* Step 1: Power internal PHY by writing 0 to GPIO0 pin */
+	DM9000_iow(DM9000_GPR, 0);
+	/* Step 2: Software reset */
+	DM9000_iow(DM9000_NCR, 3);
+
+	do {
+		DM9000_DBG("resetting the DM9000, 1st reset\n");
+		udelay(25); /* Wait at least 20 us */
+	} while (DM9000_ior(DM9000_NCR) & 1);
+
+	DM9000_iow(DM9000_NCR, 0);
+	DM9000_iow(DM9000_NCR, 3); /* Issue a second reset */
+
+	do {
+		DM9000_DBG("resetting the DM9000, 2nd reset\n");
+		udelay(25); /* Wait at least 20 us */
+	} while (DM9000_ior(DM9000_NCR) & 1);
+
+	/* Check whether the ethernet controller is present */
+	if ((DM9000_ior(DM9000_PIDL) != 0x0) ||
+	    (DM9000_ior(DM9000_PIDH) != 0x90))
+		printf("ERROR: resetting DM9000 -> not responding\n");
 }
 
 /* Initilize dm9000 board
@@ -274,12 +415,46 @@
 eth_init(bd_t * bd)
 {
 	int i, oft, lnk;
+	u8 io_mode;
+	struct board_info *db = &dm9000_info;
+
 	DM9000_DBG("eth_init()\n");
 
 	/* RESET device */
 	dm9000_reset();
 	dm9000_probe();
 
+	/* Auto-detect 8/16/32 bit mode, ISR Bit 6+7 indicate bus width */
+	io_mode = DM9000_ior(DM9000_ISR) >> 6;
+
+	switch (io_mode) {
+	case 0x0:  /* 16-bit mode */
+		printf("DM9000: running in 16 bit mode\n");
+		db->outblk    = dm9000_outblk_16bit;
+		db->inblk     = dm9000_inblk_16bit;
+		db->rx_status = dm9000_rx_status_16bit;
+		break;
+	case 0x01:  /* 32-bit mode */
+		printf("DM9000: running in 32 bit mode\n");
+		db->outblk    = dm9000_outblk_32bit;
+		db->inblk     = dm9000_inblk_32bit;
+		db->rx_status = dm9000_rx_status_32bit;
+		break;
+	case 0x02: /* 8 bit mode */
+		printf("DM9000: running in 8 bit mode\n");
+		db->outblk    = dm9000_outblk_8bit;
+		db->inblk     = dm9000_inblk_8bit;
+		db->rx_status = dm9000_rx_status_8bit;
+		break;
+	default:
+		/* Assume 8 bit mode, will probably not work anyway */
+		printf("DM9000: Undefined IO-mode:0x%x\n", io_mode);
+		db->outblk    = dm9000_outblk_8bit;
+		db->inblk     = dm9000_inblk_8bit;
+		db->rx_status = dm9000_rx_status_8bit;
+		break;
+	}
+
 	/* NIC Type: FASTETHER, HOMERUN, LONGRUN */
 	identify_nic();
 
@@ -289,19 +464,43 @@
 	/* Set PHY */
 	set_PHY_mode();
 
-	/* Program operating register */
-	DM9000_iow(DM9000_NCR, 0x0);	/* only intern phy supported by now */
-	DM9000_iow(DM9000_TCR, 0);	/* TX Polling clear */
-	DM9000_iow(DM9000_BPTR, 0x3f);	/* Less 3Kb, 200us */
-	DM9000_iow(DM9000_FCTR, FCTR_HWOT(3) | FCTR_LWOT(8));	/* Flow Control : High/Low Water */
-	DM9000_iow(DM9000_FCR, 0x0);	/* SH FIXME: This looks strange! Flow Control */
-	DM9000_iow(DM9000_SMCR, 0);	/* Special Mode */
-	DM9000_iow(DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);	/* clear TX status */
-	DM9000_iow(DM9000_ISR, 0x0f);	/* Clear interrupt status */
+	/* Program operating register, only intern phy supported by now */
+	DM9000_iow(DM9000_NCR, 0x0);
+	/* TX Polling clear */
+	DM9000_iow(DM9000_TCR, 0);
+	/* Less 3Kb, 200us */
+	DM9000_iow(DM9000_BPTR, 0x3f);
+	/* Flow Control : High/Low Water */
+	DM9000_iow(DM9000_FCTR, FCTR_HWOT(3) | FCTR_LWOT(8));
+	/* SH FIXME: This looks strange! Flow Control */
+	DM9000_iow(DM9000_FCR, 0x0);
+	/* Special Mode */
+	DM9000_iow(DM9000_SMCR, 0);
+	/* clear TX status */
+	DM9000_iow(DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);
+	/* Clear interrupt status */
+	DM9000_iow(DM9000_ISR, 0x0f);
 
 	/* Set Node address */
+#ifndef CONFIG_AT91SAM9261EK
 	for (i = 0; i < 6; i++)
 		((u16 *) bd->bi_enetaddr)[i] = read_srom_word(i);
+#endif
+
+	if (is_zero_ether_addr(bd->bi_enetaddr) ||
+	    is_multicast_ether_addr(bd->bi_enetaddr)) {
+		/* try reading from environment */
+		u8 i;
+		char *s, *e;
+		s = getenv ("ethaddr");
+		for (i = 0; i < 6; ++i) {
+			bd->bi_enetaddr[i] = s ?
+				simple_strtoul (s, &e, 16) : 0;
+			if (s)
+				s = (*e) ? e + 1 : e;
+		}
+	}
+
 	printf("MAC: %02x:%02x:%02x:%02x:%02x:%02x\n", bd->bi_enetaddr[0],
 	       bd->bi_enetaddr[1], bd->bi_enetaddr[2], bd->bi_enetaddr[3],
 	       bd->bi_enetaddr[4], bd->bi_enetaddr[5]);
@@ -316,8 +515,11 @@
 	DM9000_DBG("\n");
 
 	/* Activate DM9000 */
-	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);	/* RX enable */
-	DM9000_iow(DM9000_IMR, IMR_PAR);	/* Enable TX/RX interrupt mask */
+	/* RX enable */
+	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);
+	/* Enable TX/RX interrupt mask */
+	DM9000_iow(DM9000_IMR, IMR_PAR);
+
 	i = 0;
 	while (!(phy_read(1) & 0x20)) {	/* autonegation complete bit */
 		udelay(1000);
@@ -359,54 +561,37 @@
 int
 eth_send(volatile void *packet, int length)
 {
-	char *data_ptr;
-	u32 tmplen, i;
 	int tmo;
-	DM9000_DBG("eth_send: length: %d\n", length);
-	for (i = 0; i < length; i++) {
-		if (i % 8 == 0)
-			DM9000_DBG("\nSend: 02x: ", i);
-		DM9000_DBG("%02x ", ((unsigned char *) packet)[i]);
-	} DM9000_DBG("\n");
+	struct board_info *db = &dm9000_info;
 
-	/* Move data to DM9000 TX RAM */
-	data_ptr = (char *) packet;
-	DM9000_outb(DM9000_MWCMD, DM9000_IO);
+	DM9000_DMP_PACKET("eth_send", packet, length);
 
-#ifdef CONFIG_DM9000_USE_8BIT
-	/* Byte mode */
-	for (i = 0; i < length; i++)
-		DM9000_outb((data_ptr[i] & 0xff), DM9000_DATA);
-
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_16BIT
-	tmplen = (length + 1) / 2;
-	for (i = 0; i < tmplen; i++)
-		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);
+	DM9000_iow(DM9000_ISR, IMR_PTM); /* Clear Tx bit in ISR */
 
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_32BIT
-	tmplen = (length + 3) / 4;
-	for (i = 0; i < tmplen; i++)
-		DM9000_outl(((u32 *) data_ptr)[i], DM9000_DATA);
+	/* Move data to DM9000 TX RAM */
+	DM9000_outb(DM9000_MWCMD, DM9000_IO); /* Prepare for TX-data */
 
-#endif				/*  */
+	/* push the data to the TX-fifo */
+	(db->outblk)(packet, length);
 
 	/* Set TX length to DM9000 */
 	DM9000_iow(DM9000_TXPLL, length & 0xff);
 	DM9000_iow(DM9000_TXPLH, (length >> 8) & 0xff);
 
 	/* Issue TX polling command */
-	DM9000_iow(DM9000_TCR, TCR_TXREQ);	/* Cleared after TX complete */
+	DM9000_iow(DM9000_TCR, TCR_TXREQ); /* Cleared after TX complete */
 
 	/* wait for end of transmission */
 	tmo = get_timer(0) + 5 * CFG_HZ;
-	while (DM9000_ior(DM9000_TCR) & TCR_TXREQ) {
+	while ( !(DM9000_ior(DM9000_NSR) & (NSR_TX1END | NSR_TX2END)) ||
+		!(DM9000_ior(DM9000_ISR) & IMR_PTM) ) {
 		if (get_timer(0) >= tmo) {
 			printf("transmission timeout\n");
 			break;
 		}
 	}
+	DM9000_iow(DM9000_ISR, IMR_PTM); /* Clear Tx bit in ISR */
+
 	DM9000_DBG("transmit done\n\n");
 	return 0;
 }
@@ -435,86 +620,67 @@
 {
 	u8 rxbyte, *rdptr = (u8 *) NetRxPackets[0];
 	u16 RxStatus, RxLen = 0;
-	u32 tmplen, i;
-#ifdef CONFIG_DM9000_USE_32BIT
-	u32 tmpdata;
-#endif
+	struct board_info *db = &dm9000_info;
 
-	/* Check packet ready or not */
-	DM9000_ior(DM9000_MRCMDX);	/* Dummy read */
-	rxbyte = DM9000_inb(DM9000_DATA);	/* Got most updated data */
-	if (rxbyte == 0)
+	/* Check packet ready or not, we must check
+	   the ISR status first for DM9000A */
+	if (!(DM9000_ior(DM9000_ISR) & 0x01)) /* Rx-ISR bit must be set. */
 		return 0;
 
-	/* Status check: this byte must be 0 or 1 */
-	if (rxbyte > 1) {
-		DM9000_iow(DM9000_RCR, 0x00);	/* Stop Device */
-		DM9000_iow(DM9000_ISR, 0x80);	/* Stop INT request */
-		DM9000_DBG("rx status check: %d\n", rxbyte);
-	}
-	DM9000_DBG("receiving packet\n");
-
-	/* A packet ready now  & Get status/length */
-	DM9000_outb(DM9000_MRCMD, DM9000_IO);
+	DM9000_iow(DM9000_ISR, 0x01); /* clear PR status latched in bit 0 */
 
-#ifdef CONFIG_DM9000_USE_8BIT
-	RxStatus = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
-	RxLen = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
-
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_16BIT
-	RxStatus = DM9000_inw(DM9000_DATA);
-	RxLen = DM9000_inw(DM9000_DATA);
+	/* There is _at least_ 1 package in the fifo, read them all */
+	for (;;) {
+		DM9000_ior(DM9000_MRCMDX);	/* Dummy read */
+
+		/* Get most updated data,
+		   only look at bits 0:1, See application notes DM9000 */
+		rxbyte = DM9000_inb(DM9000_DATA) & 0x03;
+
+		/* Status check: this byte must be 0 or 1 */
+		if (rxbyte > DM9000_PKT_RDY) {
+			DM9000_iow(DM9000_RCR, 0x00);	/* Stop Device */
+			DM9000_iow(DM9000_ISR, 0x80);	/* Stop INT request */
+			printf("DM9000 error: status check fail: 0x%x\n",
+				rxbyte);
+			return 0;
+		}
 
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_32BIT
-	tmpdata = DM9000_inl(DM9000_DATA);
-	RxStatus = tmpdata;
-	RxLen = tmpdata >> 16;
+		if (rxbyte != DM9000_PKT_RDY)
+			return 0; /* No packet received, ignore */
 
-#endif				/*  */
-	DM9000_DBG("rx status: 0x%04x rx len: %d\n", RxStatus, RxLen);
+		DM9000_DBG("receiving packet\n");
 
-	/* Move data from DM9000 */
-	/* Read received packet from RX SRAM */
-#ifdef CONFIG_DM9000_USE_8BIT
-	for (i = 0; i < RxLen; i++)
-		rdptr[i] = DM9000_inb(DM9000_DATA);
-
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_16BIT
-	tmplen = (RxLen + 1) / 2;
-	for (i = 0; i < tmplen; i++)
-		((u16 *) rdptr)[i] = DM9000_inw(DM9000_DATA);
+		/* A packet ready now  & Get status/length */
+		(db->rx_status)(&RxStatus, &RxLen);
 
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_32BIT
-	tmplen = (RxLen + 3) / 4;
-	for (i = 0; i < tmplen; i++)
-		((u32 *) rdptr)[i] = DM9000_inl(DM9000_DATA);
+		DM9000_DBG("rx status: 0x%04x rx len: %d\n", RxStatus, RxLen);
+
+		/* Move data from DM9000 */
+		/* Read received packet from RX SRAM */
+		(db->inblk)(rdptr, RxLen);
+
+		if ((RxStatus & 0xbf00) || (RxLen < 0x40)
+			|| (RxLen > DM9000_PKT_MAX)) {
+			if (RxStatus & 0x100) {
+				printf("rx fifo error\n");
+			}
+			if (RxStatus & 0x200) {
+				printf("rx crc error\n");
+			}
+			if (RxStatus & 0x8000) {
+				printf("rx length error\n");
+			}
+			if (RxLen > DM9000_PKT_MAX) {
+				printf("rx length too big\n");
+				dm9000_reset();
+			}
+		} else {
+			DM9000_DMP_PACKET("eth_rx", rdptr, RxLen);
 
-#endif				/*  */
-	if ((RxStatus & 0xbf00) || (RxLen < 0x40)
-	    || (RxLen > DM9000_PKT_MAX)) {
-		if (RxStatus & 0x100) {
-			printf("rx fifo error\n");
+			DM9000_DBG("passing packet to upper layer\n");
+			NetReceive(NetRxPackets[0], RxLen);
 		}
-		if (RxStatus & 0x200) {
-			printf("rx crc error\n");
-		}
-		if (RxStatus & 0x8000) {
-			printf("rx length error\n");
-		}
-		if (RxLen > DM9000_PKT_MAX) {
-			printf("rx length too big\n");
-			dm9000_reset();
-		}
-	} else {
-
-		/* Pass to upper layer */
-		DM9000_DBG("passing packet to upper layer\n");
-		NetReceive(NetRxPackets[0], RxLen);
-		return RxLen;
 	}
 	return 0;
 }
@@ -522,16 +688,28 @@
 /*
   Read a word data from SROM
 */
-static u16
+u16
 read_srom_word(int offset)
 {
 	DM9000_iow(DM9000_EPAR, offset);
 	DM9000_iow(DM9000_EPCR, 0x4);
-	udelay(200);
+	udelay(8000);
 	DM9000_iow(DM9000_EPCR, 0x0);
 	return (DM9000_ior(DM9000_EPDRL) + (DM9000_ior(DM9000_EPDRH) << 8));
 }
 
+void
+write_srom_word(int offset, u16 val)
+{
+	DM9000_iow(DM9000_EPAR, offset);
+	DM9000_iow(DM9000_EPDRH, ((val >> 8) & 0xff));
+	DM9000_iow(DM9000_EPDRL, (val & 0xff));
+	DM9000_iow(DM9000_EPCR, 0x12);
+	udelay(8000);
+	DM9000_iow(DM9000_EPCR, 0);
+}
+
+
 /*
    Read a byte from I/O port
 */
@@ -563,12 +741,12 @@
 	/* Fill the phyxcer register into REG_0C */
 	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
 	DM9000_iow(DM9000_EPCR, 0xc);	/* Issue phyxcer read command */
-	udelay(100);		/* Wait read complete */
+	udelay(100);			/* Wait read complete */
 	DM9000_iow(DM9000_EPCR, 0x0);	/* Clear phyxcer read command */
 	val = (DM9000_ior(DM9000_EPDRH) << 8) | DM9000_ior(DM9000_EPDRL);
 
 	/* The read data keeps on REG_0D & REG_0E */
-	DM9000_DBG("phy_read(%d): %d\n", reg, val);
+	DM9000_DBG("phy_read(0x%x): 0x%x\n", reg, val);
 	return val;
 }
 
@@ -586,8 +764,9 @@
 	DM9000_iow(DM9000_EPDRL, (value & 0xff));
 	DM9000_iow(DM9000_EPDRH, ((value >> 8) & 0xff));
 	DM9000_iow(DM9000_EPCR, 0xa);	/* Issue phyxcer write command */
-	udelay(500);		/* Wait write complete */
+	udelay(500);			/* Wait write complete */
 	DM9000_iow(DM9000_EPCR, 0x0);	/* Clear phyxcer write command */
-	DM9000_DBG("phy_write(reg:%d, value:%d)\n", reg, value);
+	DM9000_DBG("phy_write(reg:0x%x, value:0x%x)\n", reg, value);
 }
-#endif				/* CONFIG_DRIVER_DM9000 */
+
+#endif /* CONFIG_DRIVER_DM9000 */
diff -urN u-boot-1.1.6/drivers/jedec_flash.c u-boot-1.1.6_fdt/drivers/jedec_flash.c
--- u-boot-1.1.6/drivers/jedec_flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/jedec_flash.c	2018-10-22 15:53:21.549641225 +0800
@@ -0,0 +1,1894 @@
+/*
+ * (C) Copyright 2007
+ * Michael Schwingen, <michael@schwingen.org>
+ *
+ * based in great part on jedec_probe.c from linux kernel:
+ * (C) 2000 Red Hat. GPL'd.
+ * Occasionally maintained by Thayne Harbaugh tharbaugh at lnxi dot com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+/* The DEBUG define must be before common to enable debugging */
+/*#define DEBUG*/
+
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <environment.h>
+
+#define P_ID_NONE               0x0000
+#define P_ID_INTEL_EXT          0x0001
+#define P_ID_AMD_STD            0x0002
+#define P_ID_INTEL_STD          0x0003
+#define P_ID_AMD_EXT            0x0004
+#define P_ID_WINBOND            0x0006
+#define P_ID_ST_ADV             0x0020
+#define P_ID_MITSUBISHI_STD     0x0100
+#define P_ID_MITSUBISHI_EXT     0x0101
+#define P_ID_SST_PAGE           0x0102
+#define P_ID_INTEL_PERFORMANCE  0x0200
+#define P_ID_INTEL_DATA         0x0210
+#define P_ID_RESERVED           0xffff
+
+
+/* Manufacturers */
+#define MANUFACTURER_AMD	0x0001
+#define MANUFACTURER_ATMEL	0x001f
+#define MANUFACTURER_FUJITSU	0x0004
+#define MANUFACTURER_HYUNDAI	0x00AD
+#define MANUFACTURER_INTEL	0x0089
+#define MANUFACTURER_MACRONIX	0x00C2
+#define MANUFACTURER_NEC	0x0010
+#define MANUFACTURER_PMC	0x009D
+#define MANUFACTURER_SHARP	0x00b0
+#define MANUFACTURER_SST	0x00BF
+#define MANUFACTURER_ST		0x0020
+#define MANUFACTURER_TOSHIBA	0x0098
+#define MANUFACTURER_WINBOND	0x00da
+
+
+/* AMD */
+#define AM29DL800BB	0x22C8
+#define AM29DL800BT	0x224A
+
+#define AM29F800BB	0x2258
+#define AM29F800BT	0x22D6
+#define AM29LV400BB	0x22BA
+#define AM29LV400BT	0x22B9
+#define AM29LV800BB	0x225B
+#define AM29LV800BT	0x22DA
+#define AM29LV160DT	0x22C4
+#define AM29LV160DB	0x2249
+#define AM29F017D	0x003D
+#define AM29F016D	0x00AD
+#define AM29F080	0x00D5
+#define AM29F040	0x00A4
+#define AM29LV040B	0x004F
+#define AM29F032B	0x0041
+#define AM29F002T	0x00B0
+
+/* Atmel */
+#define AT49BV512	0x0003
+#define AT29LV512	0x003d
+#define AT49BV16X	0x00C0
+#define AT49BV16XT	0x00C2
+#define AT49BV32X	0x00C8
+#define AT49BV32XT	0x00C9
+
+/* Fujitsu */
+#define MBM29F040C	0x00A4
+#define MBM29LV650UE	0x22D7
+#define MBM29LV320TE	0x22F6
+#define MBM29LV320BE	0x22F9
+#define MBM29LV160TE	0x22C4
+#define MBM29LV160BE	0x2249
+#define MBM29LV800BA	0x225B
+#define MBM29LV800TA	0x22DA
+#define MBM29LV400TC	0x22B9
+#define MBM29LV400BC	0x22BA
+
+/* Hyundai */
+#define HY29F002T	0x00B0
+
+/* Intel */
+#define I28F004B3T	0x00d4
+#define I28F004B3B	0x00d5
+#define I28F400B3T	0x8894
+#define I28F400B3B	0x8895
+#define I28F008S5	0x00a6
+#define I28F016S5	0x00a0
+#define I28F008SA	0x00a2
+#define I28F008B3T	0x00d2
+#define I28F008B3B	0x00d3
+#define I28F800B3T	0x8892
+#define I28F800B3B	0x8893
+#define I28F016S3	0x00aa
+#define I28F016B3T	0x00d0
+#define I28F016B3B	0x00d1
+#define I28F160B3T	0x8890
+#define I28F160B3B	0x8891
+#define I28F320B3T	0x8896
+#define I28F320B3B	0x8897
+#define I28F640B3T	0x8898
+#define I28F640B3B	0x8899
+#define I82802AB	0x00ad
+#define I82802AC	0x00ac
+
+/* Macronix */
+#define MX29LV040C	0x004F
+#define MX29LV160T	0x22C4
+#define MX29LV160B	0x2249
+#define MX29F040	0x00A4
+#define MX29F016	0x00AD
+#define MX29F002T	0x00B0
+#define MX29F004T	0x0045
+#define MX29F004B	0x0046
+
+/* NEC */
+#define UPD29F064115	0x221C
+
+/* PMC */
+#define PM49FL002	0x006D
+#define PM49FL004	0x006E
+#define PM49FL008	0x006A
+
+/* Sharp */
+#define LH28F640BF	0x00b0
+
+/* ST - www.st.com */
+#define M29W800DT	0x00D7
+#define M29W800DB	0x005B
+#define M29W160DT	0x22C4
+#define M29W160DB	0x2249
+#define M29W040B	0x00E3
+#define M50FW040	0x002C
+#define M50FW080	0x002D
+#define M50FW016	0x002E
+#define M50LPW080       0x002F
+
+/* SST */
+#define SST29EE020	0x0010
+#define SST29LE020	0x0012
+#define SST29EE512	0x005d
+#define SST29LE512	0x003d
+#define SST39LF800	0x2781
+#define SST39LF160	0x2782
+#define SST39VF1601	0x234b
+#define SST39LF512	0x00D4
+#define SST39LF010	0x00D5
+#define SST39LF020	0x00D6
+#define SST39LF040	0x00D7
+#define SST39SF010A	0x00B5
+#define SST39SF020A	0x00B6
+#define SST49LF004B	0x0060
+#define SST49LF040B	0x0050
+#define SST49LF008A	0x005a
+#define SST49LF030A	0x001C
+#define SST49LF040A	0x0051
+#define SST49LF080A	0x005B
+
+/* Toshiba */
+#define TC58FVT160	0x00C2
+#define TC58FVB160	0x0043
+#define TC58FVT321	0x009A
+#define TC58FVB321	0x009C
+#define TC58FVT641	0x0093
+#define TC58FVB641	0x0095
+
+/* Winbond */
+#define W49V002A	0x00b0
+
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+
+struct unlock_addr {
+	u32 addr1;
+	u32 addr2;
+};
+
+/*
+ * Unlock address sets for AMD command sets.
+ * Intel command sets use the MTD_UADDR_UNNECESSARY.
+ * Each identifier, except MTD_UADDR_UNNECESSARY, and
+ * MTD_UADDR_NO_SUPPORT must be defined below in unlock_addrs[].
+ * MTD_UADDR_NOT_SUPPORTED must be 0 so that structure
+ * initialization need not require initializing all of the
+ * unlock addresses for all bit widths.
+ */
+enum uaddr {
+	MTD_UADDR_NOT_SUPPORTED = 0,	/* data width not supported */
+	MTD_UADDR_0x0555_0x02AA,
+	MTD_UADDR_0x0555_0x0AAA,
+	MTD_UADDR_0x5555_0x2AAA,
+	MTD_UADDR_0x0AAA_0x0555,
+	MTD_UADDR_DONT_CARE,		/* Requires an arbitrary address */
+	MTD_UADDR_UNNECESSARY,		/* Does not require any address */
+};
+
+
+
+
+/*
+ * I don't like the fact that the first entry in unlock_addrs[]
+ * exists, but is for MTD_UADDR_NOT_SUPPORTED - and, therefore,
+ * should not be used.  The  problem is that structures with
+ * initializers have extra fields initialized to 0.  It is _very_
+ * desireable to have the unlock address entries for unsupported
+ * data widths automatically initialized - that means that
+ * MTD_UADDR_NOT_SUPPORTED must be 0 and the first entry here
+ * must go unused.
+ */
+static const struct unlock_addr  unlock_addrs[] = {
+	[MTD_UADDR_NOT_SUPPORTED] = {
+		.addr1 = 0xffff,
+		.addr2 = 0xffff
+	},
+
+	[MTD_UADDR_0x0555_0x02AA] = {
+		.addr1 = 0x0555,
+		.addr2 = 0x02aa
+	},
+
+	[MTD_UADDR_0x0555_0x0AAA] = {
+		.addr1 = 0x0555,
+		.addr2 = 0x0aaa
+	},
+
+	[MTD_UADDR_0x5555_0x2AAA] = {
+		.addr1 = 0x5555,
+		.addr2 = 0x2aaa
+	},
+
+	[MTD_UADDR_0x0AAA_0x0555] = {
+		.addr1 = 0x0AAA,
+		.addr2 = 0x0555
+	},
+
+	[MTD_UADDR_DONT_CARE] = {
+		.addr1 = 0x0000,      /* Doesn't matter which address */
+		.addr2 = 0x0000       /* is used - must be last entry */
+	},
+
+	[MTD_UADDR_UNNECESSARY] = {
+		.addr1 = 0x0000,
+		.addr2 = 0x0000
+	}
+};
+
+struct amd_flash_info {
+	const __u16 mfr_id;
+	const __u16 dev_id;
+	const char *name;
+	const int DevSize;
+	const int NumEraseRegions;
+	const int CmdSet;
+	const __u8 uaddr[4];		/* unlock addrs for 8, 16, 32, 64 */
+	const ulong regions[6];
+};
+
+#define ERASEINFO(size,blocks) (size<<8)|(blocks-1)
+
+#define SIZE_64KiB  16
+#define SIZE_128KiB 17
+#define SIZE_256KiB 18
+#define SIZE_512KiB 19
+#define SIZE_1MiB   20
+#define SIZE_2MiB   21
+#define SIZE_4MiB   22
+#define SIZE_8MiB   23
+
+
+/*
+ * Please keep this list ordered by manufacturer!
+ * Fortunately, the list isn't searched often and so a
+ * slow, linear search isn't so bad.
+ */
+static const struct amd_flash_info jedec_table[] = {
+	{
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29F032B,
+		.name		= "AMD AM29F032B",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_4MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,64)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29LV160DT,
+		.name		= "AMD AM29LV160DT",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA   /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,31),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29LV160DB,
+		.name		= "AMD AM29LV160DB",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA   /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,31)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29LV400BB,
+		.name		= "AMD AM29LV400BB",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,7)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29LV400BT,
+		.name		= "AMD AM29LV400BT",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,7),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29LV800BB,
+		.name		= "AMD AM29LV800BB",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,15),
+		}
+	}, {
+/* add DL */
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29DL800BB,
+		.name		= "AMD AM29DL800BB",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 6,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,4),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x10000,14)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29DL800BT,
+		.name		= "AMD AM29DL800BT",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 6,
+		.regions	= {
+			ERASEINFO(0x10000,14),
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,4),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29F800BB,
+		.name		= "AMD AM29F800BB",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,15),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29LV800BT,
+		.name		= "AMD AM29LV800BT",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,15),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29F800BT,
+		.name		= "AMD AM29F800BT",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,15),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29F017D,
+		.name		= "AMD AM29F017D",
+		.uaddr		= {
+			[0] = MTD_UADDR_DONT_CARE     /* x8 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,32),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29F016D,
+		.name		= "AMD AM29F016D",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,32),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29F080,
+		.name		= "AMD AM29F080",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,16),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29F040,
+		.name		= "AMD AM29F040",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29LV040B,
+		.name		= "AMD AM29LV040B",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_AMD,
+		.dev_id		= AM29F002T,
+		.name		= "AMD AM29F002T",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_256KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,3),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_ATMEL,
+		.dev_id		= AT49BV512,
+		.name		= "Atmel AT49BV512",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_64KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_ATMEL,
+		.dev_id		= AT29LV512,
+		.name		= "Atmel AT29LV512",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_64KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x80,256),
+			ERASEINFO(0x80,256)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_ATMEL,
+		.dev_id		= AT49BV16X,
+		.name		= "Atmel AT49BV16X",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x0AAA,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x0AAA   /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000,8),
+			ERASEINFO(0x10000,31)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_ATMEL,
+		.dev_id		= AT49BV16XT,
+		.name		= "Atmel AT49BV16XT",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x0AAA,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x0AAA   /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000,31),
+			ERASEINFO(0x02000,8)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_ATMEL,
+		.dev_id		= AT49BV32X,
+		.name		= "Atmel AT49BV32X",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x0AAA,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x0AAA   /* x16 */
+		},
+		.DevSize	= SIZE_4MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000,8),
+			ERASEINFO(0x10000,63)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_ATMEL,
+		.dev_id		= AT49BV32XT,
+		.name		= "Atmel AT49BV32XT",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x0AAA,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x0AAA   /* x16 */
+		},
+		.DevSize	= SIZE_4MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000,63),
+			ERASEINFO(0x02000,8)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_FUJITSU,
+		.dev_id		= MBM29F040C,
+		.name		= "Fujitsu MBM29F040C",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555, /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,8)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_FUJITSU,
+		.dev_id		= MBM29LV650UE,
+		.name		= "Fujitsu MBM29LV650UE",
+		.uaddr		= {
+			[0] = MTD_UADDR_DONT_CARE     /* x16 */
+		},
+		.DevSize	= SIZE_8MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,128)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_FUJITSU,
+		.dev_id		= MBM29LV320TE,
+		.name		= "Fujitsu MBM29LV320TE",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_4MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000,63),
+			ERASEINFO(0x02000,8)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_FUJITSU,
+		.dev_id		= MBM29LV320BE,
+		.name		= "Fujitsu MBM29LV320BE",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_4MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000,8),
+			ERASEINFO(0x10000,63)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_FUJITSU,
+		.dev_id		= MBM29LV160TE,
+		.name		= "Fujitsu MBM29LV160TE",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,31),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_FUJITSU,
+		.dev_id		= MBM29LV160BE,
+		.name		= "Fujitsu MBM29LV160BE",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,31)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_FUJITSU,
+		.dev_id		= MBM29LV800BA,
+		.name		= "Fujitsu MBM29LV800BA",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,15)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_FUJITSU,
+		.dev_id		= MBM29LV800TA,
+		.name		= "Fujitsu MBM29LV800TA",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,15),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_FUJITSU,
+		.dev_id		= MBM29LV400BC,
+		.name		= "Fujitsu MBM29LV400BC",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,7)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_FUJITSU,
+		.dev_id		= MBM29LV400TC,
+		.name		= "Fujitsu MBM29LV400TC",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,7),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_HYUNDAI,
+		.dev_id		= HY29F002T,
+		.name		= "Hyundai HY29F002T",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_256KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,3),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F004B3B,
+		.name		= "Intel 28F004B3B",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 7),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F004B3T,
+		.name		= "Intel 28F004B3T",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000, 7),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F400B3B,
+		.name		= "Intel 28F400B3B",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+			[1] = MTD_UADDR_UNNECESSARY,    /* x16 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 7),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F400B3T,
+		.name		= "Intel 28F400B3T",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+			[1] = MTD_UADDR_UNNECESSARY,    /* x16 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000, 7),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F008B3B,
+		.name		= "Intel 28F008B3B",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 15),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F008B3T,
+		.name		= "Intel 28F008B3T",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000, 15),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F008S5,
+		.name		= "Intel 28F008S5",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_INTEL_EXT,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,16),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F016S5,
+		.name		= "Intel 28F016S5",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_INTEL_EXT,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,32),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F008SA,
+		.name		= "Intel 28F008SA",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000, 16),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F800B3B,
+		.name		= "Intel 28F800B3B",
+		.uaddr		= {
+			[1] = MTD_UADDR_UNNECESSARY,    /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 15),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F800B3T,
+		.name		= "Intel 28F800B3T",
+		.uaddr		= {
+			[1] = MTD_UADDR_UNNECESSARY,    /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000, 15),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F016B3B,
+		.name		= "Intel 28F016B3B",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 31),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F016S3,
+		.name		= "Intel I28F016S3",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000, 32),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F016B3T,
+		.name		= "Intel 28F016B3T",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000, 31),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F160B3B,
+		.name		= "Intel 28F160B3B",
+		.uaddr		= {
+			[1] = MTD_UADDR_UNNECESSARY,    /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 31),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F160B3T,
+		.name		= "Intel 28F160B3T",
+		.uaddr		= {
+			[1] = MTD_UADDR_UNNECESSARY,    /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000, 31),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F320B3B,
+		.name		= "Intel 28F320B3B",
+		.uaddr		= {
+			[1] = MTD_UADDR_UNNECESSARY,    /* x16 */
+		},
+		.DevSize	= SIZE_4MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 63),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F320B3T,
+		.name		= "Intel 28F320B3T",
+		.uaddr		= {
+			[1] = MTD_UADDR_UNNECESSARY,    /* x16 */
+		},
+		.DevSize	= SIZE_4MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000, 63),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F640B3B,
+		.name		= "Intel 28F640B3B",
+		.uaddr		= {
+			[1] = MTD_UADDR_UNNECESSARY,    /* x16 */
+		},
+		.DevSize	= SIZE_8MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000, 8),
+			ERASEINFO(0x10000, 127),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I28F640B3T,
+		.name		= "Intel 28F640B3T",
+		.uaddr		= {
+			[1] = MTD_UADDR_UNNECESSARY,    /* x16 */
+		},
+		.DevSize	= SIZE_8MiB,
+		.CmdSet		= P_ID_INTEL_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000, 127),
+			ERASEINFO(0x02000, 8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I82802AB,
+		.name		= "Intel 82802AB",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_INTEL_EXT,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_INTEL,
+		.dev_id		= I82802AC,
+		.name		= "Intel 82802AC",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_INTEL_EXT,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,16),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_MACRONIX,
+		.dev_id		= MX29LV040C,
+		.name		= "Macronix MX29LV040C",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA,  /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_MACRONIX,
+		.dev_id		= MX29LV160T,
+		.name		= "MXIC MX29LV160T",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,31),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_NEC,
+		.dev_id		= UPD29F064115,
+		.name		= "NEC uPD29F064115",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_8MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 3,
+		.regions	= {
+			ERASEINFO(0x2000,8),
+			ERASEINFO(0x10000,126),
+			ERASEINFO(0x2000,8),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_MACRONIX,
+		.dev_id		= MX29LV160B,
+		.name		= "MXIC MX29LV160B",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,31)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_MACRONIX,
+		.dev_id		= MX29F040,
+		.name		= "Macronix MX29F040",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,8),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_MACRONIX,
+		.dev_id		= MX29F016,
+		.name		= "Macronix MX29F016",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,32),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_MACRONIX,
+		.dev_id		= MX29F004T,
+		.name		= "Macronix MX29F004T",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,7),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_MACRONIX,
+		.dev_id		= MX29F004B,
+		.name		= "Macronix MX29F004B",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,7),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_MACRONIX,
+		.dev_id		= MX29F002T,
+		.name		= "Macronix MX29F002T",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_256KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,3),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_PMC,
+		.dev_id		= PM49FL002,
+		.name		= "PMC Pm49FL002",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_256KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO( 0x01000, 64 )
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_PMC,
+		.dev_id		= PM49FL004,
+		.name		= "PMC Pm49FL004",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO( 0x01000, 128 )
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_PMC,
+		.dev_id		= PM49FL008,
+		.name		= "PMC Pm49FL008",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO( 0x01000, 256 )
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_SHARP,
+		.dev_id		= LH28F640BF,
+		.name		= "LH28F640BF",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_4MiB,
+		.CmdSet         = P_ID_INTEL_STD,
+		.NumEraseRegions= 1,
+		.regions        = {
+			ERASEINFO(0x40000,16),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST39LF512,
+		.name		= "SST 39LF512",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_64KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x01000,16),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST39LF010,
+		.name		= "SST 39LF010",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_128KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x01000,32),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_SST,
+ 		.dev_id 	= SST29EE020,
+		.name		= "SST 29EE020",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+ 		.DevSize	= SIZE_256KiB,
+ 		.CmdSet		= P_ID_SST_PAGE,
+ 		.NumEraseRegions= 1,
+ 		.regions = {ERASEINFO(0x01000,64),
+ 		}
+         }, {
+ 		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST29LE020,
+ 		.name		= "SST 29LE020",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+ 		.DevSize	= SIZE_256KiB,
+ 		.CmdSet		= P_ID_SST_PAGE,
+ 		.NumEraseRegions= 1,
+ 		.regions = {ERASEINFO(0x01000,64),
+ 		}
+	}, {
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST39LF020,
+		.name		= "SST 39LF020",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_256KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x01000,64),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST39LF040,
+		.name		= "SST 39LF040",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x01000,128),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST39SF010A,
+		.name		= "SST 39SF010A",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_128KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x01000,32),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST39SF020A,
+		.name		= "SST 39SF020A",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_256KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x01000,64),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id         = SST49LF040B,
+		.name           = "SST 49LF040B",
+		.uaddr          = {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize        = SIZE_512KiB,
+		.CmdSet         = P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions        = {
+			ERASEINFO(0x01000,128),
+		}
+	}, {
+
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST49LF004B,
+		.name		= "SST 49LF004B",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x01000,128),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST49LF008A,
+		.name		= "SST 49LF008A",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x01000,256),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST49LF030A,
+		.name		= "SST 49LF030A",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x01000,96),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST49LF040A,
+		.name		= "SST 49LF040A",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x01000,128),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_SST,
+		.dev_id		= SST49LF080A,
+		.name		= "SST 49LF080A",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x01000,256),
+		}
+	}, {
+               .mfr_id         = MANUFACTURER_SST,     /* should be CFI */
+               .dev_id         = SST39LF160,
+               .name           = "SST 39LF160",
+               .uaddr          = {
+                       [0] = MTD_UADDR_0x5555_0x2AAA,  /* x8 */
+                       [1] = MTD_UADDR_0x5555_0x2AAA   /* x16 */
+               },
+               .DevSize        = SIZE_2MiB,
+               .CmdSet         = P_ID_AMD_STD,
+               .NumEraseRegions= 2,
+               .regions        = {
+                       ERASEINFO(0x1000,256),
+                       ERASEINFO(0x1000,256)
+               }
+	}, {
+               .mfr_id         = MANUFACTURER_SST,     /* should be CFI */
+               .dev_id         = SST39VF1601,
+               .name           = "SST 39VF1601",
+               .uaddr          = {
+                       [0] = MTD_UADDR_0x5555_0x2AAA,  /* x8 */
+                       [1] = MTD_UADDR_0x5555_0x2AAA   /* x16 */
+               },
+               .DevSize        = SIZE_2MiB,
+               .CmdSet         = P_ID_AMD_STD,
+               .NumEraseRegions= 2,
+               .regions        = {
+                       ERASEINFO(0x1000,256),
+                       ERASEINFO(0x1000,256)
+               }
+
+       }, {
+		.mfr_id		= MANUFACTURER_ST,	/* FIXME - CFI device? */
+		.dev_id		= M29W800DT,
+		.name		= "ST M29W800DT",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA,  /* x8 */
+			[1] = MTD_UADDR_0x5555_0x2AAA   /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,15),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_ST,	/* FIXME - CFI device? */
+		.dev_id		= M29W800DB,
+		.name		= "ST M29W800DB",
+ 		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA,  /* x8 */
+			[1] = MTD_UADDR_0x5555_0x2AAA   /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,15)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_ST,	/* FIXME - CFI device? */
+		.dev_id		= M29W160DT,
+		.name		= "ST M29W160DT",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,31),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_ST,	/* FIXME - CFI device? */
+		.dev_id		= M29W160DB,
+		.name		= "ST M29W160DB",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,31)
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_ST,
+		.dev_id		= M29W040B,
+		.name		= "ST M29W040B",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,8),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_ST,
+		.dev_id		= M50FW040,
+		.name		= "ST M50FW040",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_INTEL_EXT,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,8),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_ST,
+		.dev_id		= M50FW080,
+		.name		= "ST M50FW080",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_INTEL_EXT,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,16),
+		}
+        }, {
+		.mfr_id		= MANUFACTURER_ST,
+		.dev_id		= M50FW016,
+		.name		= "ST M50FW016",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_INTEL_EXT,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,32),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_ST,
+		.dev_id		= M50LPW080,
+		.name		= "ST M50LPW080",
+		.uaddr		= {
+			[0] = MTD_UADDR_UNNECESSARY,    /* x8 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_INTEL_EXT,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,16),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.dev_id		= TC58FVT160,
+		.name		= "Toshiba TC58FVT160",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555, /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA  /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000,31),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x04000,1)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.dev_id		= TC58FVB160,
+		.name		= "Toshiba TC58FVB160",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555, /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA  /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,31)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.dev_id		= TC58FVB321,
+		.name		= "Toshiba TC58FVB321",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555, /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA  /* x16 */
+		},
+		.DevSize	= SIZE_4MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000,8),
+			ERASEINFO(0x10000,63)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.dev_id		= TC58FVT321,
+		.name		= "Toshiba TC58FVT321",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555, /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA  /* x16 */
+		},
+		.DevSize	= SIZE_4MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000,63),
+			ERASEINFO(0x02000,8)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.dev_id		= TC58FVB641,
+		.name		= "Toshiba TC58FVB641",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555, /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA, /* x16 */
+		},
+		.DevSize	= SIZE_8MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x02000,8),
+			ERASEINFO(0x10000,127)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_TOSHIBA,
+		.dev_id		= TC58FVT641,
+		.name		= "Toshiba TC58FVT641",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555, /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA, /* x16 */
+		},
+		.DevSize	= SIZE_8MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 2,
+		.regions	= {
+			ERASEINFO(0x10000,127),
+			ERASEINFO(0x02000,8)
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_WINBOND,
+		.dev_id		= W49V002A,
+		.name		= "Winbond W49V002A",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x5555_0x2AAA /* x8 */
+		},
+		.DevSize	= SIZE_256KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x10000, 3),
+			ERASEINFO(0x08000, 1),
+			ERASEINFO(0x02000, 2),
+			ERASEINFO(0x04000, 1),
+		}
+	}
+};
+
+static inline void fill_info(flash_info_t *info, const struct amd_flash_info *jedec_entry, ulong base)
+{
+	int i,j;
+	int sect_cnt;
+	int size_ratio;
+	int total_size;
+	enum uaddr uaddr_idx;
+
+	size_ratio = info->portwidth / info->chipwidth;
+
+	debug("Found JEDEC Flash: %s\n", jedec_entry->name);
+	info->vendor = jedec_entry->CmdSet;
+	/* Todo: do we need device-specific timeouts? */
+	info->erase_blk_tout = 30000;
+	info->buffer_write_tout = 1000;
+	info->write_tout = 100;
+	info->name = jedec_entry->name;
+
+	/* copy unlock addresses from device table to CFI info struct. This
+	   is just here because the addresses are in the table anyway - if
+	   the flash is not detected due to wrong unlock addresses,
+	   flash_detect_legacy would have to try all of them before we even
+	   get here. */
+	switch(info->chipwidth) {
+	case FLASH_CFI_8BIT:
+		uaddr_idx = jedec_entry->uaddr[0];
+		break;
+	case FLASH_CFI_16BIT:
+		uaddr_idx = jedec_entry->uaddr[1];
+		break;
+	case FLASH_CFI_32BIT:
+		uaddr_idx = jedec_entry->uaddr[2];
+		break;
+	default:
+		uaddr_idx = MTD_UADDR_NOT_SUPPORTED;
+		break;
+	}
+
+	debug("unlock address index %d\n", uaddr_idx);
+	info->addr_unlock1 = unlock_addrs[uaddr_idx].addr1;
+	info->addr_unlock2 = unlock_addrs[uaddr_idx].addr2;
+	debug("unlock addresses are 0x%x/0x%x\n", info->addr_unlock1, info->addr_unlock2);
+
+	sect_cnt = 0;
+	total_size = 0;
+	for (i = 0; i < jedec_entry->NumEraseRegions; i++) {
+		ulong erase_region_size = jedec_entry->regions[i] >> 8;
+		ulong erase_region_count = (jedec_entry->regions[i] & 0xff) + 1;
+
+		total_size += erase_region_size * erase_region_count;
+		debug ("erase_region_count = %d erase_region_size = %d\n",
+		       erase_region_count, erase_region_size);
+		for (j = 0; j < erase_region_count; j++) {
+			if (sect_cnt >= CFG_MAX_FLASH_SECT) {
+				printf("ERROR: too many flash sectors\n");
+				break;
+			}
+			info->start[sect_cnt] = base;
+			base += (erase_region_size * size_ratio);
+			sect_cnt++;
+		}
+	}
+	info->sector_count = sect_cnt;
+	info->size = total_size * size_ratio;
+}
+
+/*-----------------------------------------------------------------------
+ * match jedec ids against table. If a match is found, fill flash_info entry
+ */
+int jedec_flash_match(flash_info_t *info, ulong base)
+{
+	int ret = 0;
+	int i;
+	ulong mask = 0xFFFF;
+	if (info->chipwidth == 1)
+		mask = 0xFF;
+
+	for (i = 0; i < ARRAY_SIZE(jedec_table); i++) {
+		if ((jedec_table[i].mfr_id & mask) == (info->manufacturer_id & mask) &&
+		    (jedec_table[i].dev_id & mask) == (info->device_id & mask)) {
+			fill_info(info, &jedec_table[i], base);
+			ret = 1;
+			break;
+		}
+	}
+	return ret;
+}
+
+extern void flash_read_jedec_ids (flash_info_t * info);
+
+int jedec_flash_probe(flash_info_t *info, ulong base)
+{
+	int u;
+	for (u = MTD_UADDR_0x0555_0x02AA; u <= MTD_UADDR_UNNECESSARY; u++) {
+		info->addr_unlock1 = unlock_addrs[u].addr1;
+		info->addr_unlock2 = unlock_addrs[u].addr2;
+		flash_read_jedec_ids(info);
+		debug("JEDEC PROBE: ID %x %x %x\n",
+				info->manufacturer_id,
+				info->device_id,
+				info->device_id2);
+		if (jedec_flash_match(info, base))
+			return 1;
+	}
+	return 0;
+}
+
diff -urN u-boot-1.1.6/drivers/Makefile u-boot-1.1.6_fdt/drivers/Makefile
--- u-boot-1.1.6/drivers/Makefile	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/Makefile	2018-10-22 15:53:21.549641225 +0800
@@ -28,7 +28,7 @@
 LIB	= $(obj)libdrivers.a
 
 COBJS	= 3c589.o 5701rls.o ali512x.o atmel_usart.o \
-	  bcm570x.o bcm570x_autoneg.o cfb_console.o cfi_flash.o \
+	  bcm570x.o bcm570x_autoneg.o cfb_console.o cfi_flash.o jedec_flash.o \
 	  cs8900.o ct69000.o dataflash.o dc2114x.o dm9000x.o \
 	  e1000.o eepro100.o \
 	  i8042.o inca-ip_sw.o keyboard.o \
diff -urN u-boot-1.1.6/drivers/nand/nand_base.c u-boot-1.1.6_fdt/drivers/nand/nand_base.c
--- u-boot-1.1.6/drivers/nand/nand_base.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/nand/nand_base.c	2018-10-22 15:53:21.549641225 +0800
@@ -88,6 +88,12 @@
 #include <jffs2/jffs2.h>
 #endif
 
+#if defined(CONFIG_S3C2400)
+#include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+#endif
+
 /* Define default oob placement schemes for large and small page devices */
 static struct nand_oobinfo nand_oob_8 = {
 	.useecc = MTD_NANDECC_AUTOPLACE,
@@ -427,17 +433,17 @@
 	struct nand_chip *this = mtd->priv;
 	u16 bad;
 
+	page = (int)(ofs >> this->page_shift);
+	chipnr = (int)(ofs >> this->chip_shift);
+
 	if (getchip) {
-		page = (int)(ofs >> this->page_shift);
-		chipnr = (int)(ofs >> this->chip_shift);
 
 		/* Grab the lock and see if the device is available */
 		nand_get_device (this, mtd, FL_READING);
 
 		/* Select the NAND device */
 		this->select_chip(mtd, chipnr);
-	} else
-		page = (int) ofs;
+	} 
 
 	if (this->options & NAND_BUSWIDTH_16) {
 		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos & 0xFE, page & this->pagemask);
@@ -447,9 +453,17 @@
 		if ((bad & 0xFF) != 0xff)
 			res = 1;
 	} else {
-		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos, page & this->pagemask);
-		if (this->read_byte(mtd) != 0xff)
-			res = 1;
+    		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos, page & this->pagemask);
+    		if (this->read_byte(mtd) != 0xff)
+    			res = 1;
+
+        // Apply delay or wait for ready/busy pin
+        // add by www.100ask.net, if not, the erase will be failed
+		if (!this->dev_ready)
+			udelay (this->chip_delay);
+		else
+			while (!this->dev_ready(mtd));
+
 	}
 
 	if (getchip) {
@@ -517,11 +531,11 @@
 {
 	struct nand_chip *this = mtd->priv;
 
-	if (!this->bbt)
+//	if (!this->bbt)
 		return this->block_bad(mtd, ofs, getchip);
 
 	/* Return info from the table */
-	return nand_isbad_bbt (mtd, ofs, allowbbt);
+//	return nand_isbad_bbt (mtd, ofs, allowbbt);
 }
 
 /**
@@ -573,13 +587,17 @@
 			if (this->options & NAND_BUSWIDTH_16)
 				column >>= 1;
 			this->write_byte(mtd, column);
+			udelay(15);
 		}
 		if (page_addr != -1) {
 			this->write_byte(mtd, (unsigned char) (page_addr & 0xff));
+			udelay(15);
 			this->write_byte(mtd, (unsigned char) ((page_addr >> 8) & 0xff));
+			udelay(15);
 			/* One more address cycle for devices > 32MiB */
 			if (this->chipsize > (32 << 20))
 				this->write_byte(mtd, (unsigned char) ((page_addr >> 16) & 0x0f));
+   			    udelay(15);
 		}
 		/* Latch in address */
 		this->hwcontrol(mtd, NAND_CTL_CLRALE);
@@ -662,9 +680,11 @@
 
 		/* Serially input address */
 		if (column != -1) {
+#if 0			
 			/* Adjust columns for 16 bit buswidth */
 			if (this->options & NAND_BUSWIDTH_16)
 				column >>= 1;
+#endif			
 			this->write_byte(mtd, column & 0xff);
 			this->write_byte(mtd, column >> 8);
 		}
@@ -907,7 +927,7 @@
 	switch (eccmode) {
 	/* No ecc, write all */
 	case NAND_ECC_NONE:
-		printk (KERN_WARNING "Writing data without ECC to NAND-FLASH is not recommended\n");
+		//printk (KERN_WARNING "Writing data without ECC to NAND-FLASH is not recommended\n");
 		this->write_buf(mtd, this->data_poi, mtd->oobblock);
 		break;
 
@@ -943,8 +963,21 @@
 	/* Write out OOB data */
 	if (this->options & NAND_HWECC_SYNDROME)
 		this->write_buf(mtd, &oob_buf[oobsel->eccbytes], mtd->oobsize - oobsel->eccbytes);
-	else
+	else if (eccmode != NAND_ECC_NONE)
 		this->write_buf(mtd, oob_buf, mtd->oobsize);
+	else {
+		for (i = 0; i < mtd->oobsize; i++) {
+			if (oob_buf[i] != 0xff)
+				break;
+		}
+		if (i < mtd->oobsize) {
+			printf("Bad oob_buf: page = 0x%x, data = ", page);
+			for (i = 0; i < mtd->oobsize; i++) {
+				printf("%02x ", oob_buf[i]);
+			}
+			printf("\n");
+		}
+	}
 
 	/* Send command to actually program the data */
 	this->cmdfunc (mtd, cached ? NAND_CMD_CACHEDPROG : NAND_CMD_PAGEPROG, -1, -1);
@@ -1216,7 +1249,7 @@
 				lastwhinge = jiffies;
 			}
 #else
-			puts("Reading data from NAND FLASH without ECC is not recommended\n");
+			//puts("Reading data from NAND FLASH without ECC is not recommended\n");
 #endif
 			this->read_buf(mtd, data_poi, end);
 			break;
@@ -1560,8 +1593,10 @@
 	}
 
 	/* If we have no autoplacement or no fs buffer use the internal one */
-	if (!autoplace || !fsbuf)
-		return this->oob_buf;
+        if (!autoplace || !fsbuf) {
+                this->oobdirty = 1;                     // by thisway.diy, www.100ask.net
+                return this->oob_buf;
+        }
 
 	/* Walk through the pages and place the data */
 	this->oobdirty = 1;
@@ -1751,6 +1786,126 @@
 }
 
 
+/*
+ * NAND write
+ */
+int
+nand_write_calmecc(struct mtd_info *mtd, loff_t to, size_t len, 
+           size_t *retlen, const u_char *buf, unsigned int *pdwECCVal)
+{
+	int i, page, col, cnt, status, chipnr;    
+	struct nand_chip *this = mtd->priv;
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+		"%s(): to = 0x%08x, len = %i\n", __FUNCTION__, (unsigned int)to,
+		(int) len);
+
+	/* Do not allow write past end of page */
+	if ((to + len) > mtd->size) {
+		DEBUG(MTD_DEBUG_LEVEL0,
+			"%s(): Attempted write past end of device\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* Shift to get page */
+	page = ((int)to) >> this->page_shift;
+
+	/* Get the starting column */
+	col = to & (mtd->oobblock - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd, FL_WRITING);
+
+	/* Calculate chipnr */
+	chipnr = (int)(to >> this->chip_shift);
+	/* Select the NAND device */
+	this->select_chip(mtd, chipnr);
+
+	/* Check, if it is write protected */
+	if (nand_check_wp(mtd))
+		goto nand_write_exit;
+
+	/* Loop until all data is written */
+	while (*retlen < len) {
+		/* Write data into buffer */
+		if ((col + len) >= mtd->oobblock)
+			for (i = col, cnt = 0; i < mtd->oobblock; i++, cnt++)
+				this->data_buf[i] = buf[(*retlen + cnt)];
+		else
+			for (i = col, cnt = 0; cnt < (len - *retlen); i++, cnt++)
+				this->data_buf[i] = buf[(*retlen + cnt)];
+		/* Write ones for partial page programming */
+		for (i = mtd->oobblock; i < (mtd->oobblock + mtd->oobsize); i++)
+			this->data_buf[i] = 0xff;
+		
+		/* Write pre-padding bytes into buffer */
+		for (i = 0; i < col; i++)
+			this->data_buf[i] = 0xff;
+
+		/* Write post-padding bytes into buffer */
+		if ((col + (len - *retlen)) < mtd->oobblock) {
+			for (i = (col + cnt); i < mtd->oobblock; i++)
+				this->data_buf[i] = 0xff;
+		}
+
+        /* thisway.diy for cal ECC */
+        s3c2440nand->NFCONT |= (1<<4);   // Reset ECC
+        s3c2440nand->NFCONT &= ~(1<<5);  // UnLock MECC
+
+		/* Send command to begin auto page programming */
+		this->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
+
+		/* Write out complete page of data */
+		this->write_buf(mtd, this->data_buf, mtd->oobblock);
+
+        s3c2440nand->NFCONT |= (1<<5);   // Lock MECC
+        *pdwECCVal = s3c2440nand->NFMECC0; // Read MECC
+
+		this->write_buf(mtd, &this->data_buf[mtd->oobblock], mtd->oobsize);
+        
+    	/* Send command to actually program the data */
+    	this->cmdfunc (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+    	/* call wait ready function */
+    	status = this->waitfunc (mtd, this, FL_WRITING);
+    	/* See if device thinks it succeeded */
+    	if (status & 0x01) {
+    		DEBUG (MTD_DEBUG_LEVEL0, "%s: " "Failed write, page 0x%08x, ", __FUNCTION__, page);
+    		return -EIO;
+    	}
+
+		/* 
+		 * If we are writing a large amount of data and/or it
+		 * crosses page or half-page boundaries, we set the
+		 * the column to zero. It simplifies the program logic.
+		 */
+		if (col)
+			col = 0x00;
+
+		/* Update written bytes count */
+		*retlen += cnt;
+
+		/* Increment page address */
+		page++;
+		
+	}
+
+	/* Return happy */
+	*retlen = len;
+	i = 0;
+
+nand_write_exit:
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+
+	return i;
+}
+
+
 /**
  * nand_write_oob - [MTD Interface] NAND write out-of-band
  * @mtd:	MTD device structure
@@ -2631,7 +2786,7 @@
 	mtd->owner = THIS_MODULE;
 #endif
 	/* Build bad block table */
-	return this->scan_bbt (mtd);
+	return 0; //this->scan_bbt (mtd); // cancelled by www.100ask.net, scan_bbt uses more time
 }
 
 /**
diff -urN u-boot-1.1.6/drivers/nand/nand_ids.c u-boot-1.1.6_fdt/drivers/nand/nand_ids.c
--- u-boot-1.1.6/drivers/nand/nand_ids.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/nand/nand_ids.c	2018-10-22 15:53:21.549641225 +0800
@@ -67,7 +67,8 @@
 
 	{"NAND 256MiB 3,3V 8-bit", 	0x71, 512, 256, 0x4000, 0},
 
-	{"NAND 512MiB 3,3V 8-bit", 	0xDC, 512, 512, 0x4000, 0},
+/*	{"NAND 512MiB 3,3V 8-bit", 	0xDC, 512, 512, 0x4000, 0}, */
+	{"NAND 512MiB 3,3V 8-bit",	0xDC, 0, 512, 0, 0},
 
 	/* These are the new chips with large page size. The pagesize
 	* and the erasesize is determined from the extended id bytes
diff -urN u-boot-1.1.6/drivers/nand/nand_util.c u-boot-1.1.6_fdt/drivers/nand/nand_util.c
--- u-boot-1.1.6/drivers/nand/nand_util.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/nand/nand_util.c	2018-10-22 15:53:21.549641225 +0800
@@ -4,12 +4,12 @@
  * Copyright (C) 2006 by Weiss-Electronic GmbH.
  * All rights reserved.
  *
- * @author:	Guido Classen <clagix@gmail.com>
- * @descr:	NAND Flash support
+ * @author: Guido Classen <clagix@gmail.com>
+ * @descr:  NAND Flash support
  * @references: borrowed heavily from Linux mtd-utils code:
- *		flash_eraseall.c by Arcom Control System Ltd
- *		nandwrite.c by Steven J. Hill (sjhill@realitydiluted.com)
- *			       and Thomas Gleixner (tglx@linutronix.de)
+ *      flash_eraseall.c by Arcom Control System Ltd
+ *      nandwrite.c by Steven J. Hill (sjhill@realitydiluted.com)
+ *                 and Thomas Gleixner (tglx@linutronix.de)
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -20,7 +20,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -42,7 +42,7 @@
 #include <jffs2/jffs2.h>
 
 typedef struct erase_info erase_info_t;
-typedef struct mtd_info	  mtd_info_t;
+typedef struct mtd_info   mtd_info_t;
 
 /* support only for native endian JFFS2 */
 #define cpu_to_je16(x) (x)
@@ -51,199 +51,199 @@
 /*****************************************************************************/
 static int nand_block_bad_scrub(struct mtd_info *mtd, loff_t ofs, int getchip)
 {
-	return 0;
+    return 0;
 }
 
 /**
  * nand_erase_opts: - erase NAND flash with support for various options
- *		      (jffs2 formating)
+ *            (jffs2 formating)
  *
- * @param meminfo	NAND device to erase
- * @param opts		options,  @see struct nand_erase_options
- * @return		0 in case of success
+ * @param meminfo   NAND device to erase
+ * @param opts      options,  @see struct nand_erase_options
+ * @return      0 in case of success
  *
  * This code is ported from flash_eraseall.c from Linux mtd utils by
  * Arcom Control System Ltd.
  */
 int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
 {
-	struct jffs2_unknown_node cleanmarker;
-	int clmpos = 0;
-	int clmlen = 8;
-	erase_info_t erase;
-	ulong erase_length;
-	int isNAND;
-	int bbtest = 1;
-	int result;
-	int percent_complete = -1;
-	int (*nand_block_bad_old)(struct mtd_info *, loff_t, int) = NULL;
-	const char *mtd_device = meminfo->name;
-
-	memset(&erase, 0, sizeof(erase));
-
-	erase.mtd = meminfo;
-	erase.len  = meminfo->erasesize;
-	erase.addr = opts->offset;
-	erase_length = opts->length;
-
-	isNAND = meminfo->type == MTD_NANDFLASH ? 1 : 0;
-
-	if (opts->jffs2) {
-		cleanmarker.magic = cpu_to_je16 (JFFS2_MAGIC_BITMASK);
-		cleanmarker.nodetype = cpu_to_je16 (JFFS2_NODETYPE_CLEANMARKER);
-		if (isNAND) {
-			struct nand_oobinfo *oobinfo = &meminfo->oobinfo;
-
-			/* check for autoplacement */
-			if (oobinfo->useecc == MTD_NANDECC_AUTOPLACE) {
-				/* get the position of the free bytes */
-				if (!oobinfo->oobfree[0][1]) {
-					printf(" Eeep. Autoplacement selected "
-					       "and no empty space in oob\n");
-					return -1;
-				}
-				clmpos = oobinfo->oobfree[0][0];
-				clmlen = oobinfo->oobfree[0][1];
-				if (clmlen > 8)
-					clmlen = 8;
-			} else {
-				/* legacy mode */
-				switch (meminfo->oobsize) {
-				case 8:
-					clmpos = 6;
-					clmlen = 2;
-					break;
-				case 16:
-					clmpos = 8;
-					clmlen = 8;
-					break;
-				case 64:
-					clmpos = 16;
-					clmlen = 8;
-					break;
-				}
-			}
-
-			cleanmarker.totlen = cpu_to_je32(8);
-		} else {
-			cleanmarker.totlen =
-				cpu_to_je32(sizeof(struct jffs2_unknown_node));
-		}
-		cleanmarker.hdr_crc =  cpu_to_je32(
-			crc32_no_comp(0, (unsigned char *) &cleanmarker,
-				      sizeof(struct jffs2_unknown_node) - 4));
-	}
-
-	/* scrub option allows to erase badblock. To prevent internal
-	 * check from erase() method, set block check method to dummy
-	 * and disable bad block table while erasing.
-	 */
-	if (opts->scrub) {
-		struct nand_chip *priv_nand = meminfo->priv;
-
-		nand_block_bad_old = priv_nand->block_bad;
-		priv_nand->block_bad = nand_block_bad_scrub;
-		/* we don't need the bad block table anymore...
-		 * after scrub, there are no bad blocks left!
-		 */
-		if (priv_nand->bbt) {
-			kfree(priv_nand->bbt);
-		}
-		priv_nand->bbt = NULL;
-	}
-
-	for (;
-	     erase.addr < opts->offset + erase_length;
-	     erase.addr += meminfo->erasesize) {
-
-		WATCHDOG_RESET ();
-
-		if (!opts->scrub && bbtest) {
-			int ret = meminfo->block_isbad(meminfo, erase.addr);
-			if (ret > 0) {
-				if (!opts->quiet)
-					printf("\rSkipping bad block at  "
-					       "0x%08x                   "
-					       "                         \n",
-					       erase.addr);
-				continue;
-
-			} else if (ret < 0) {
-				printf("\n%s: MTD get bad block failed: %d\n",
-				       mtd_device,
-				       ret);
-				return -1;
-			}
-		}
-
-		result = meminfo->erase(meminfo, &erase);
-		if (result != 0) {
-			printf("\n%s: MTD Erase failure: %d\n",
-			       mtd_device, result);
-			continue;
-		}
-
-		/* format for JFFS2 ? */
-		if (opts->jffs2) {
-
-			/* write cleanmarker */
-			if (isNAND) {
-				size_t written;
-				result = meminfo->write_oob(meminfo,
-							    erase.addr + clmpos,
-							    clmlen,
-							    &written,
-							    (unsigned char *)
-							    &cleanmarker);
-				if (result != 0) {
-					printf("\n%s: MTD writeoob failure: %d\n",
-					       mtd_device, result);
-					continue;
-				}
-			} else {
-				printf("\n%s: this erase routine only supports"
-				       " NAND devices!\n",
-				       mtd_device);
-			}
-		}
-
-		if (!opts->quiet) {
-			int percent = (int)
-				((unsigned long long)
-				 (erase.addr+meminfo->erasesize-opts->offset)
-				 * 100 / erase_length);
-
-			/* output progress message only at whole percent
-			 * steps to reduce the number of messages printed
-			 * on (slow) serial consoles
-			 */
-			if (percent != percent_complete) {
-				percent_complete = percent;
-
-				printf("\rErasing at 0x%x -- %3d%% complete.",
-				       erase.addr, percent);
-
-				if (opts->jffs2 && result == 0)
-					printf(" Cleanmarker written at 0x%x.",
-					       erase.addr);
-			}
-		}
-	}
-	if (!opts->quiet)
-		printf("\n");
-
-	if (nand_block_bad_old) {
-		struct nand_chip *priv_nand = meminfo->priv;
-
-		priv_nand->block_bad = nand_block_bad_old;
-		priv_nand->scan_bbt(meminfo);
-	}
+    struct jffs2_unknown_node cleanmarker;
+    int clmpos = 0;
+    int clmlen = 8;
+    erase_info_t erase;
+    ulong erase_length;
+    int isNAND;
+    int bbtest = 1;
+    int result;
+    int percent_complete = -1;
+    int (*nand_block_bad_old)(struct mtd_info *, loff_t, int) = NULL;
+    const char *mtd_device = meminfo->name;
+
+    memset(&erase, 0, sizeof(erase));
+
+    erase.mtd = meminfo;
+    erase.len  = meminfo->erasesize;
+    erase.addr = opts->offset;
+    erase_length = opts->length;
+
+    isNAND = meminfo->type == MTD_NANDFLASH ? 1 : 0;
+
+    if (opts->jffs2) {
+        cleanmarker.magic = cpu_to_je16 (JFFS2_MAGIC_BITMASK);
+        cleanmarker.nodetype = cpu_to_je16 (JFFS2_NODETYPE_CLEANMARKER);
+        if (isNAND) {
+            struct nand_oobinfo *oobinfo = &meminfo->oobinfo;
+
+            /* check for autoplacement */
+            if (oobinfo->useecc == MTD_NANDECC_AUTOPLACE) {
+                /* get the position of the free bytes */
+                if (!oobinfo->oobfree[0][1]) {
+                    printf(" Eeep. Autoplacement selected "
+                           "and no empty space in oob\n");
+                    return -1;
+                }
+                clmpos = oobinfo->oobfree[0][0];
+                clmlen = oobinfo->oobfree[0][1];
+                if (clmlen > 8)
+                    clmlen = 8;
+            } else {
+                /* legacy mode */
+                switch (meminfo->oobsize) {
+                case 8:
+                    clmpos = 6;
+                    clmlen = 2;
+                    break;
+                case 16:
+                    clmpos = 8;
+                    clmlen = 8;
+                    break;
+                case 64:
+                    clmpos = 16;
+                    clmlen = 8;
+                    break;
+                }
+            }
+
+            cleanmarker.totlen = cpu_to_je32(8);
+        } else {
+            cleanmarker.totlen =
+                cpu_to_je32(sizeof(struct jffs2_unknown_node));
+        }
+        cleanmarker.hdr_crc =  cpu_to_je32(
+            crc32_no_comp(0, (unsigned char *) &cleanmarker,
+                      sizeof(struct jffs2_unknown_node) - 4));
+    }
+
+    /* scrub option allows to erase badblock. To prevent internal
+     * check from erase() method, set block check method to dummy
+     * and disable bad block table while erasing.
+     */
+    if (opts->scrub) {
+        struct nand_chip *priv_nand = meminfo->priv;
+
+        nand_block_bad_old = priv_nand->block_bad;
+        priv_nand->block_bad = nand_block_bad_scrub;
+        /* we don't need the bad block table anymore...
+         * after scrub, there are no bad blocks left!
+         */
+        if (priv_nand->bbt) {
+            kfree(priv_nand->bbt);
+        }
+        priv_nand->bbt = NULL;
+    }
+
+    for (;
+         erase.addr < opts->offset + erase_length;
+         erase.addr += meminfo->erasesize) {
+
+        WATCHDOG_RESET ();
+
+        if (!opts->scrub && bbtest) {
+            int ret = meminfo->block_isbad(meminfo, erase.addr);
+            if (ret > 0) {
+                if (!opts->quiet)
+                    printf("\rSkipping bad block at  "
+                           "0x%08x                   "
+                           "                         \n",
+                           erase.addr);
+                continue;
+
+            } else if (ret < 0) {
+                printf("\n%s: MTD get bad block failed: %d\n",
+                       mtd_device,
+                       ret);
+                return -1;
+            }
+        }
+
+        result = meminfo->erase(meminfo, &erase);
+        if (result != 0) {
+            printf("\n%s: MTD Erase failure: %d\n",
+                   mtd_device, result);
+            continue;
+        }
+
+        /* format for JFFS2 ? */
+        if (opts->jffs2) {
+
+            /* write cleanmarker */
+            if (isNAND) {
+                size_t written;
+                result = meminfo->write_oob(meminfo,
+                                erase.addr + clmpos,
+                                clmlen,
+                                &written,
+                                (unsigned char *)
+                                &cleanmarker);
+                if (result != 0) {
+                    printf("\n%s: MTD writeoob failure: %d\n",
+                           mtd_device, result);
+                    continue;
+                }
+            } else {
+                printf("\n%s: this erase routine only supports"
+                       " NAND devices!\n",
+                       mtd_device);
+            }
+        }
+
+        if (!opts->quiet) {
+            int percent = (int)
+                ((unsigned long )
+                 (erase.addr+meminfo->erasesize-opts->offset)
+                 * 100 / erase_length);
+
+            /* output progress message only at whole percent
+             * steps to reduce the number of messages printed
+             * on (slow) serial consoles
+             */
+            if (percent != percent_complete) {
+                percent_complete = percent;
+
+                printf("\rErasing at 0x%x -- %3d%% complete.",
+                       erase.addr, percent);
+
+                if (opts->jffs2 && result == 0)
+                    printf(" Cleanmarker written at 0x%x.",
+                           erase.addr);
+            }
+        }
+    }
+    if (!opts->quiet)
+        printf("\n");
+
+    if (nand_block_bad_old) {
+        struct nand_chip *priv_nand = meminfo->priv;
+
+        priv_nand->block_bad = nand_block_bad_old;
+        priv_nand->scan_bbt(meminfo);
+    }
 
-	return 0;
+    return 0;
 }
 
-#define MAX_PAGE_SIZE	2048
-#define MAX_OOB_SIZE	64
+#define MAX_PAGE_SIZE   2048
+#define MAX_OOB_SIZE    64
 
 /*
  * buffer array used for writing data
@@ -253,454 +253,485 @@
 
 /* OOB layouts to pass into the kernel as default */
 static struct nand_oobinfo none_oobinfo = {
-	.useecc = MTD_NANDECC_OFF,
+    .useecc = MTD_NANDECC_OFF,
 };
 
 static struct nand_oobinfo jffs2_oobinfo = {
-	.useecc = MTD_NANDECC_PLACE,
-	.eccbytes = 6,
-	.eccpos = { 0, 1, 2, 3, 6, 7 }
+    .useecc = MTD_NANDECC_PLACE,
+    .eccbytes = 6,
+    .eccpos = { 0, 1, 2, 3, 6, 7 }
 };
 
 static struct nand_oobinfo yaffs_oobinfo = {
-	.useecc = MTD_NANDECC_PLACE,
-	.eccbytes = 6,
-	.eccpos = { 8, 9, 10, 13, 14, 15}
+    .useecc = MTD_NANDECC_PLACE,
+    .eccbytes = 6,
+    .eccpos = { 8, 9, 10, 13, 14, 15}
 };
 
 static struct nand_oobinfo autoplace_oobinfo = {
-	.useecc = MTD_NANDECC_AUTOPLACE
+    .useecc = MTD_NANDECC_AUTOPLACE
 };
 
 /**
  * nand_write_opts: - write image to NAND flash with support for various options
  *
- * @param meminfo	NAND device to erase
- * @param opts		write options (@see nand_write_options)
- * @return		0 in case of success
+ * @param meminfo   NAND device to erase
+ * @param opts      write options (@see nand_write_options)
+ * @return      0 in case of success
  *
  * This code is ported from nandwrite.c from Linux mtd utils by
  * Steven J. Hill and Thomas Gleixner.
  */
 int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
 {
-	int imglen = 0;
-	int pagelen;
-	int baderaseblock;
-	int blockstart = -1;
-	loff_t offs;
-	int readlen;
-	int oobinfochanged = 0;
-	int percent_complete = -1;
-	struct nand_oobinfo old_oobinfo;
-	ulong mtdoffset = opts->offset;
-	ulong erasesize_blockalign;
-	u_char *buffer = opts->buffer;
-	size_t written;
-	int result;
-
-	if (opts->pad && opts->writeoob) {
-		printf("Can't pad when oob data is present.\n");
-		return -1;
-	}
-
-	/* set erasesize to specified number of blocks - to match
-	 * jffs2 (virtual) block size */
-	if (opts->blockalign == 0) {
-		erasesize_blockalign = meminfo->erasesize;
-	} else {
-		erasesize_blockalign = meminfo->erasesize * opts->blockalign;
-	}
-
-	/* make sure device page sizes are valid */
-	if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
-	    && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
-	    && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
-		printf("Unknown flash (not normal NAND)\n");
-		return -1;
-	}
-
-	/* read the current oob info */
-	memcpy(&old_oobinfo, &meminfo->oobinfo, sizeof(old_oobinfo));
-
-	/* write without ecc? */
-	if (opts->noecc) {
-		memcpy(&meminfo->oobinfo, &none_oobinfo,
-		       sizeof(meminfo->oobinfo));
-		oobinfochanged = 1;
-	}
-
-	/* autoplace ECC? */
-	if (opts->autoplace && (old_oobinfo.useecc != MTD_NANDECC_AUTOPLACE)) {
-
-		memcpy(&meminfo->oobinfo, &autoplace_oobinfo,
-		       sizeof(meminfo->oobinfo));
-		oobinfochanged = 1;
-	}
-
-	/* force OOB layout for jffs2 or yaffs? */
-	if (opts->forcejffs2 || opts->forceyaffs) {
-		struct nand_oobinfo *oobsel =
-			opts->forcejffs2 ? &jffs2_oobinfo : &yaffs_oobinfo;
-
-		if (meminfo->oobsize == 8) {
-			if (opts->forceyaffs) {
-				printf("YAFSS cannot operate on "
-				       "256 Byte page size\n");
-				goto restoreoob;
-			}
-			/* Adjust number of ecc bytes */
-			jffs2_oobinfo.eccbytes = 3;
-		}
-
-		memcpy(&meminfo->oobinfo, oobsel, sizeof(meminfo->oobinfo));
-	}
-
-	/* get image length */
-	imglen = opts->length;
-	pagelen = meminfo->oobblock
-		+ ((opts->writeoob != 0) ? meminfo->oobsize : 0);
-
-	/* check, if file is pagealigned */
-	if ((!opts->pad) && ((imglen % pagelen) != 0)) {
-		printf("Input block length is not page aligned\n");
-		goto restoreoob;
-	}
-
-	/* check, if length fits into device */
-	if (((imglen / pagelen) * meminfo->oobblock)
-	     > (meminfo->size - opts->offset)) {
-		printf("Image %d bytes, NAND page %d bytes, "
-		       "OOB area %u bytes, device size %u bytes\n",
-		       imglen, pagelen, meminfo->oobblock, meminfo->size);
-		printf("Input block does not fit into device\n");
-		goto restoreoob;
-	}
-
-	if (!opts->quiet)
-		printf("\n");
-
-	/* get data from input and write to the device */
-	while (imglen && (mtdoffset < meminfo->size)) {
-
-		WATCHDOG_RESET ();
-
-		/*
-		 * new eraseblock, check for bad block(s). Stay in the
-		 * loop to be sure if the offset changes because of
-		 * a bad block, that the next block that will be
-		 * written to is also checked. Thus avoiding errors if
-		 * the block(s) after the skipped block(s) is also bad
-		 * (number of blocks depending on the blockalign
-		 */
-		while (blockstart != (mtdoffset & (~erasesize_blockalign+1))) {
-			blockstart = mtdoffset & (~erasesize_blockalign+1);
-			offs = blockstart;
-			baderaseblock = 0;
-
-			/* check all the blocks in an erase block for
-			 * bad blocks */
-			do {
-				int ret = meminfo->block_isbad(meminfo, offs);
-
-				if (ret < 0) {
-					printf("Bad block check failed\n");
-					goto restoreoob;
-				}
-				if (ret == 1) {
-					baderaseblock = 1;
-					if (!opts->quiet)
-						printf("\rBad block at 0x%lx "
-						       "in erase block from "
-						       "0x%x will be skipped\n",
-						       (long) offs,
-						       blockstart);
-				}
-
-				if (baderaseblock) {
-					mtdoffset = blockstart
-						+ erasesize_blockalign;
-				}
-				offs +=	 erasesize_blockalign
-					/ opts->blockalign;
-			} while (offs < blockstart + erasesize_blockalign);
-		}
-
-		readlen = meminfo->oobblock;
-		if (opts->pad && (imglen < readlen)) {
-			readlen = imglen;
-			memset(data_buf + readlen, 0xff,
-			       meminfo->oobblock - readlen);
-		}
-
-		/* read page data from input memory buffer */
-		memcpy(data_buf, buffer, readlen);
-		buffer += readlen;
-
-		if (opts->writeoob) {
-			/* read OOB data from input memory block, exit
-			 * on failure */
-			memcpy(oob_buf, buffer, meminfo->oobsize);
-			buffer += meminfo->oobsize;
-
-			/* write OOB data first, as ecc will be placed
-			 * in there*/
-			result = meminfo->write_oob(meminfo,
-						    mtdoffset,
-						    meminfo->oobsize,
-						    &written,
-						    (unsigned char *)
-						    &oob_buf);
-
-			if (result != 0) {
-				printf("\nMTD writeoob failure: %d\n",
-				       result);
-				goto restoreoob;
-			}
-			imglen -= meminfo->oobsize;
-		}
-
-		/* write out the page data */
-		result = meminfo->write(meminfo,
-					mtdoffset,
-					meminfo->oobblock,
-					&written,
-					(unsigned char *) &data_buf);
-
-		if (result != 0) {
-			printf("writing NAND page at offset 0x%lx failed\n",
-			       mtdoffset);
-			goto restoreoob;
-		}
-		imglen -= readlen;
-
-		if (!opts->quiet) {
-			int percent = (int)
-				((unsigned long long)
-				 (opts->length-imglen) * 100
-				 / opts->length);
-			/* output progress message only at whole percent
-			 * steps to reduce the number of messages printed
-			 * on (slow) serial consoles
-			 */
-			if (percent != percent_complete) {
-				printf("\rWriting data at 0x%x "
-				       "-- %3d%% complete.",
-				       mtdoffset, percent);
-				percent_complete = percent;
-			}
-		}
+    int imglen = 0;
+    int pagelen;
+    int baderaseblock;
+    int blockstart = -1;
+    loff_t offs;
+    int readlen;
+    int oobinfochanged = 0;
+    int percent_complete = -1;
+    struct nand_oobinfo old_oobinfo;
+    ulong mtdoffset = opts->offset;
+    ulong erasesize_blockalign;
+    u_char *buffer = opts->buffer;
+    size_t written;
+    int result;
+    int skipfirstblk = opts->skipfirstblk;
+
+    if (opts->pad && opts->writeoob) {
+        printf("Can't pad when oob data is present.\n");
+        return -1;
+    }
+
+    /* set erasesize to specified number of blocks - to match
+     * jffs2 (virtual) block size */
+    if (opts->blockalign == 0) {
+        erasesize_blockalign = meminfo->erasesize;
+    } else {
+        erasesize_blockalign = meminfo->erasesize * opts->blockalign;
+    }
+
+    /* make sure device page sizes are valid */
+    if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
+        && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
+        && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
+        printf("Unknown flash (not normal NAND)\n");
+        return -1;
+    }
+
+    /* read the current oob info */
+    memcpy(&old_oobinfo, &meminfo->oobinfo, sizeof(old_oobinfo));
+
+    /* write without ecc? */
+    if (opts->noecc) {
+        memcpy(&meminfo->oobinfo, &none_oobinfo,
+               sizeof(meminfo->oobinfo));
+        oobinfochanged = 1;
+    }
+
+    /* autoplace ECC? */
+    if (opts->autoplace && (old_oobinfo.useecc != MTD_NANDECC_AUTOPLACE)) {
+
+        memcpy(&meminfo->oobinfo, &autoplace_oobinfo,
+               sizeof(meminfo->oobinfo));
+        oobinfochanged = 1;
+    }
+
+    /* force OOB layout for jffs2 or yaffs? */
+    if (opts->forcejffs2 || opts->forceyaffs) {
+        struct nand_oobinfo *oobsel =
+            opts->forcejffs2 ? &jffs2_oobinfo : &yaffs_oobinfo;
+
+        if (meminfo->oobsize == 8) {
+            if (opts->forceyaffs) {
+                printf("YAFSS cannot operate on "
+                       "256 Byte page size\n");
+                goto restoreoob;
+            }
+            /* Adjust number of ecc bytes */
+            jffs2_oobinfo.eccbytes = 3;
+        }
+
+        memcpy(&meminfo->oobinfo, oobsel, sizeof(meminfo->oobinfo));
+		oobinfochanged = 1;   /* add by thisway.diy, www.100ask.net */
+    }
+
+    /* get image length */
+    imglen = opts->length;
+    pagelen = meminfo->oobblock
+        + ((opts->writeoob != 0) ? meminfo->oobsize : 0);
+
+    /* check, if file is pagealigned */
+    if ((!opts->pad) && ((imglen % pagelen) != 0)) {
+        printf("Input block length is not page aligned\n");
+        goto restoreoob;
+    }
+
+    /* check, if length fits into device */
+    if (((imglen / pagelen) * meminfo->oobblock)
+         > (meminfo->size - opts->offset)) {
+        printf("Image %d bytes, NAND page %d bytes, "
+               "OOB area %u bytes, device size %u bytes\n",
+               imglen, pagelen, meminfo->oobblock, meminfo->size);
+        printf("Input block does not fit into device\n");
+        goto restoreoob;
+    }
+
+    if (!opts->quiet)
+        printf("\n");
+
+    /* get data from input and write to the device */
+    while (imglen && (mtdoffset < meminfo->size)) {
+
+        WATCHDOG_RESET ();
+
+        /*
+         * new eraseblock, check for bad block(s). Stay in the
+         * loop to be sure if the offset changes because of
+         * a bad block, that the next block that will be
+         * written to is also checked. Thus avoiding errors if
+         * the block(s) after the skipped block(s) is also bad
+         * (number of blocks depending on the blockalign
+         */
+        while (blockstart != (mtdoffset & (~erasesize_blockalign+1))) {
+            blockstart = mtdoffset & (~erasesize_blockalign+1);
+            offs = blockstart;
+            baderaseblock = 0;
+
+            /* check all the blocks in an erase block for
+             * bad blocks */
+            if (!opts->nocheckbadblk) {
+                do {
+                    int ret = meminfo->block_isbad(meminfo, offs);
+
+                    if (ret < 0) {
+                        printf("Bad block check failed\n");
+                        goto restoreoob;
+                    }
+                    if (ret == 1) {
+                        baderaseblock = 1;
+                        if (!opts->quiet)
+                            printf("\rBad block at 0x%lx "
+                                   "in erase block from "
+                                   "0x%x will be skipped\n",
+                                   (long) offs,
+                                   blockstart);
+                    }
+
+                    if (baderaseblock) {
+                        mtdoffset = blockstart
+                            + erasesize_blockalign;
+                    }
+                    offs +=  erasesize_blockalign
+                        / opts->blockalign;
+                } while (offs < blockstart + erasesize_blockalign);
+            }
+        }
+
+        /* skip the first good block when wirte yaffs image, by www.100ask.net */
+        if (skipfirstblk) {
+            mtdoffset += erasesize_blockalign;
+            skipfirstblk = 0;
+            continue;
+        }
+
+        readlen = meminfo->oobblock;
+        if (opts->pad && (imglen < readlen)) {
+            readlen = imglen;
+            memset(data_buf + readlen, 0xff,
+                   meminfo->oobblock - readlen);
+        }
+
+        /* read page data from input memory buffer */
+        memcpy(data_buf, buffer, readlen);
+        buffer += readlen;
+
+        if (opts->writeoob) {
+            /* read OOB data from input memory block, exit
+             * on failure */
+            memcpy(oob_buf, buffer, meminfo->oobsize);
+            buffer += meminfo->oobsize;
+
+            /* write OOB data first, as ecc will be placed
+             * in there*/
+            result = meminfo->write_oob(meminfo,
+                            mtdoffset,
+                            meminfo->oobsize,
+                            &written,
+                            (unsigned char *)
+                            &oob_buf);
+
+            if (result != 0) {
+                printf("\nMTD writeoob failure: %d\n",
+                       result);
+                goto restoreoob;
+            }
+            imglen -= meminfo->oobsize;
+        }
+
+        /* write out the page data */
+        result = meminfo->write(meminfo,
+                    mtdoffset,
+                    meminfo->oobblock,
+                    &written,
+                    (unsigned char *) &data_buf);
+
+        if (result != 0) {
+            printf("writing NAND page at offset 0x%lx failed\n",
+                   mtdoffset);
+            goto restoreoob;
+        }
+        imglen -= readlen;
+
+        if (!opts->quiet) {
+            int percent = (int)
+                ((unsigned long )
+                 (opts->length-imglen) * 100
+                 / opts->length);
+            /* output progress message only at whole percent
+             * steps to reduce the number of messages printed
+             * on (slow) serial consoles
+             */
+            if (percent != percent_complete) {
+                printf("\rWriting data at 0x%x "
+                       "-- %3d%% complete.",
+                       mtdoffset, percent);
+                percent_complete = percent;
+            }
+        }
 
-		mtdoffset += meminfo->oobblock;
-	}
+        mtdoffset += meminfo->oobblock;
+    }
 
-	if (!opts->quiet)
-		printf("\n");
+    if (!opts->quiet)
+        printf("\n");
 
 restoreoob:
-	if (oobinfochanged) {
-		memcpy(&meminfo->oobinfo, &old_oobinfo,
-		       sizeof(meminfo->oobinfo));
-	}
-
-	if (imglen > 0) {
-		printf("Data did not fit into device, due to bad blocks\n");
-		return -1;
-	}
+    if (oobinfochanged) {
+        memcpy(&meminfo->oobinfo, &old_oobinfo,
+               sizeof(meminfo->oobinfo));
+    }
+
+    if (imglen > 0) {
+        printf("Data did not fit into device, due to bad blocks\n");
+        return -1;
+    }
 
-	/* return happy */
-	return 0;
+    /* return happy */
+    return 0;
 }
 
 /**
  * nand_read_opts: - read image from NAND flash with support for various options
  *
- * @param meminfo	NAND device to erase
- * @param opts		read options (@see struct nand_read_options)
- * @return		0 in case of success
+ * @param meminfo   NAND device to erase
+ * @param opts      read options (@see struct nand_read_options)
+ * @return      0 in case of success
  *
  */
 int nand_read_opts(nand_info_t *meminfo, const nand_read_options_t *opts)
 {
-	int imglen = opts->length;
-	int pagelen;
-	int baderaseblock;
-	int blockstart = -1;
-	int percent_complete = -1;
-	loff_t offs;
-	size_t readlen;
-	ulong mtdoffset = opts->offset;
-	u_char *buffer = opts->buffer;
-	int result;
-
-	/* make sure device page sizes are valid */
-	if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
-	    && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
-	    && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
-		printf("Unknown flash (not normal NAND)\n");
-		return -1;
-	}
-
-	pagelen = meminfo->oobblock
-		+ ((opts->readoob != 0) ? meminfo->oobsize : 0);
-
-	/* check, if length is not larger than device */
-	if (((imglen / pagelen) * meminfo->oobblock)
-	     > (meminfo->size - opts->offset)) {
-		printf("Image %d bytes, NAND page %d bytes, "
-		       "OOB area %u bytes, device size %u bytes\n",
-		       imglen, pagelen, meminfo->oobblock, meminfo->size);
-		printf("Input block is larger than device\n");
-		return -1;
-	}
-
-	if (!opts->quiet)
-		printf("\n");
-
-	/* get data from input and write to the device */
-	while (imglen && (mtdoffset < meminfo->size)) {
-
-		WATCHDOG_RESET ();
-
-		/*
-		 * new eraseblock, check for bad block(s). Stay in the
-		 * loop to be sure if the offset changes because of
-		 * a bad block, that the next block that will be
-		 * written to is also checked. Thus avoiding errors if
-		 * the block(s) after the skipped block(s) is also bad
-		 * (number of blocks depending on the blockalign
-		 */
-		while (blockstart != (mtdoffset & (~meminfo->erasesize+1))) {
-			blockstart = mtdoffset & (~meminfo->erasesize+1);
-			offs = blockstart;
-			baderaseblock = 0;
-
-			/* check all the blocks in an erase block for
-			 * bad blocks */
-			do {
-				int ret = meminfo->block_isbad(meminfo, offs);
-
-				if (ret < 0) {
-					printf("Bad block check failed\n");
-					return -1;
-				}
-				if (ret == 1) {
-					baderaseblock = 1;
-					if (!opts->quiet)
-						printf("\rBad block at 0x%lx "
-						       "in erase block from "
-						       "0x%x will be skipped\n",
-						       (long) offs,
-						       blockstart);
-				}
-
-				if (baderaseblock) {
-					mtdoffset = blockstart
-						+ meminfo->erasesize;
-				}
-				offs +=	 meminfo->erasesize;
-
-			} while (offs < blockstart + meminfo->erasesize);
-		}
-
-
-		/* read page data to memory buffer */
-		result = meminfo->read(meminfo,
-				       mtdoffset,
-				       meminfo->oobblock,
-				       &readlen,
-				       (unsigned char *) &data_buf);
-
-		if (result != 0) {
-			printf("reading NAND page at offset 0x%lx failed\n",
-			       mtdoffset);
-			return -1;
-		}
-
-		if (imglen < readlen) {
-			readlen = imglen;
-		}
-
-		memcpy(buffer, data_buf, readlen);
-		buffer += readlen;
-		imglen -= readlen;
-
-		if (opts->readoob) {
-			result = meminfo->read_oob(meminfo,
-						   mtdoffset,
-						   meminfo->oobsize,
-						   &readlen,
-						   (unsigned char *)
-						   &oob_buf);
-
-			if (result != 0) {
-				printf("\nMTD readoob failure: %d\n",
-				       result);
-				return -1;
-			}
-
-
-			if (imglen < readlen) {
-				readlen = imglen;
-			}
-
-			memcpy(buffer, oob_buf, readlen);
-
-			buffer += readlen;
-			imglen -= readlen;
-		}
-
-		if (!opts->quiet) {
-			int percent = (int)
-				((unsigned long long)
-				 (opts->length-imglen) * 100
-				 / opts->length);
-			/* output progress message only at whole percent
-			 * steps to reduce the number of messages printed
-			 * on (slow) serial consoles
-			 */
-			if (percent != percent_complete) {
-			if (!opts->quiet)
-				printf("\rReading data from 0x%x "
-				       "-- %3d%% complete.",
-				       mtdoffset, percent);
-				percent_complete = percent;
-			}
-		}
-
-		mtdoffset += meminfo->oobblock;
-	}
-
-	if (!opts->quiet)
-		printf("\n");
-
-	if (imglen > 0) {
-		printf("Could not read entire image due to bad blocks\n");
-		return -1;
-	}
+    int imglen = opts->length;
+    int pagelen;
+    int baderaseblock;
+    int blockstart = -1;
+    int percent_complete = -1;
+    loff_t offs;
+    size_t readlen;
+    ulong mtdoffset = opts->offset;
+    u_char *buffer = opts->buffer;
+    int result;
+    struct nand_oobinfo old_oobinfo;
+    int oobinfochanged = 0;
+
+    /* make sure device page sizes are valid */
+    if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
+        && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
+        && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
+        printf("Unknown flash (not normal NAND)\n");
+        return -1;
+    }
+
+    pagelen = meminfo->oobblock
+        + ((opts->readoob != 0) ? meminfo->oobsize : 0);
+
+    /* check, if length is not larger than device */
+    if (((imglen / pagelen) * meminfo->oobblock)
+         > (meminfo->size - opts->offset)) {
+        printf("Image %d bytes, NAND page %d bytes, "
+               "OOB area %u bytes, device size %u bytes\n",
+               imglen, pagelen, meminfo->oobblock, meminfo->size);
+        printf("Input block is larger than device\n");
+        return -1;
+    }
+
+    if (!opts->quiet)
+        printf("\n");
+
+    /* read the current oob info */
+    memcpy(&old_oobinfo, &meminfo->oobinfo, sizeof(old_oobinfo));
+
+    /* write without ecc? */
+    if (opts->noecc) {
+        memcpy(&meminfo->oobinfo, &none_oobinfo,
+               sizeof(meminfo->oobinfo));
+        oobinfochanged = 1;
+    }
+
+    /* get data from input and write to the device */
+    while (imglen && (mtdoffset < meminfo->size)) {
+
+        WATCHDOG_RESET ();
+
+        /*
+         * new eraseblock, check for bad block(s). Stay in the
+         * loop to be sure if the offset changes because of
+         * a bad block, that the next block that will be
+         * written to is also checked. Thus avoiding errors if
+         * the block(s) after the skipped block(s) is also bad
+         * (number of blocks depending on the blockalign
+         */
+        while (blockstart != (mtdoffset & (~meminfo->erasesize+1))) {
+            blockstart = mtdoffset & (~meminfo->erasesize+1);
+            offs = blockstart;
+            baderaseblock = 0;
+
+            /* check all the blocks in an erase block for
+             * bad blocks */
+            if (!opts->nocheckbadblk) {
+                do {
+                    int ret = meminfo->block_isbad(meminfo, offs);
+
+                    if (ret < 0) {
+                        printf("Bad block check failed\n");
+                        goto restoreoob;
+                    }
+                    if (ret == 1) {
+                        baderaseblock = 1;
+                        if (!opts->quiet)
+                            printf("\rBad block at 0x%lx "
+                                   "in erase block from "
+                                   "0x%x will be skipped\n",
+                                   (long) offs,
+                                   blockstart);
+                    }
+
+                    if (baderaseblock) {
+                        mtdoffset = blockstart
+                            + meminfo->erasesize;
+                    }
+                    offs +=  meminfo->erasesize;
+
+                } while (offs < blockstart + meminfo->erasesize);
+            }
+        }
+
+
+        /* read page data to memory buffer */
+        result = meminfo->read(meminfo,
+                       mtdoffset,
+                       meminfo->oobblock,
+                       &readlen,
+                       (unsigned char *) &data_buf);
+
+        if (result != 0) {
+            printf("reading NAND page at offset 0x%lx failed\n",
+                   mtdoffset);
+            goto restoreoob;
+        }
+
+        if (imglen < readlen) {
+            readlen = imglen;
+        }
+
+        memcpy(buffer, data_buf, readlen);
+        buffer += readlen;
+        imglen -= readlen;
+
+        if (opts->readoob) {
+            result = meminfo->read_oob(meminfo,
+                           mtdoffset,
+                           meminfo->oobsize,
+                           &readlen,
+                           (unsigned char *)
+                           &oob_buf);
+
+            if (result != 0) {
+                printf("\nMTD readoob failure: %d\n",
+                       result);
+                goto restoreoob;
+            }
+
+
+            if (imglen < readlen) {
+                readlen = imglen;
+            }
+
+            memcpy(buffer, oob_buf, readlen);
+
+            buffer += readlen;
+            imglen -= readlen;
+        }
+
+        if (!opts->quiet) {
+            int percent = (int)
+                ((unsigned long )
+                 (opts->length-imglen) * 100
+                 / opts->length);
+            /* output progress message only at whole percent
+             * steps to reduce the number of messages printed
+             * on (slow) serial consoles
+             */
+            if (percent != percent_complete) {
+            if (!opts->quiet)
+                printf("\rReading data from 0x%x "
+                       "-- %3d%% complete.",
+                       mtdoffset, percent);
+                percent_complete = percent;
+            }
+        }
 
-	/* return happy */
-	return 0;
+        mtdoffset += meminfo->oobblock;
+    }
+
+    if (!opts->quiet)
+        printf("\n");
+
+restoreoob:
+    if (oobinfochanged) {
+        memcpy(&meminfo->oobinfo, &old_oobinfo,
+               sizeof(meminfo->oobinfo));
+    }
+
+    if (imglen > 0) {
+        printf("Could not read entire image due to bad blocks\n");
+        return -1;
+    }
+
+    /* return happy */
+    return 0;
 }
 
 /******************************************************************************
  * Support for locking / unlocking operations of some NAND devices
  *****************************************************************************/
 
-#define NAND_CMD_LOCK		0x2a
-#define NAND_CMD_LOCK_TIGHT	0x2c
-#define NAND_CMD_UNLOCK1	0x23
-#define NAND_CMD_UNLOCK2	0x24
-#define NAND_CMD_LOCK_STATUS	0x7a
+#define NAND_CMD_LOCK       0x2a
+#define NAND_CMD_LOCK_TIGHT 0x2c
+#define NAND_CMD_UNLOCK1    0x23
+#define NAND_CMD_UNLOCK2    0x24
+#define NAND_CMD_LOCK_STATUS    0x7a
 
 /**
  * nand_lock: Set all pages of NAND flash chip to the LOCK or LOCK-TIGHT
- *	      state
+ *        state
  *
- * @param meminfo	nand mtd instance
- * @param tight		bring device in lock tight mode
+ * @param meminfo   nand mtd instance
+ * @param tight     bring device in lock tight mode
  *
- * @return		0 on success, -1 in case of error
+ * @return      0 on success, -1 in case of error
  *
  * The lock / lock-tight command only applies to the whole chip. To get some
  * parts of the chip lock and others unlocked use the following sequence:
@@ -716,147 +747,147 @@
  */
 int nand_lock(nand_info_t *meminfo, int tight)
 {
-	int ret = 0;
-	int status;
-	struct nand_chip *this = meminfo->priv;
-
-	/* select the NAND device */
-	this->select_chip(meminfo, 0);
-
-	this->cmdfunc(meminfo,
-		      (tight ? NAND_CMD_LOCK_TIGHT : NAND_CMD_LOCK),
-		      -1, -1);
-
-	/* call wait ready function */
-	status = this->waitfunc(meminfo, this, FL_WRITING);
-
-	/* see if device thinks it succeeded */
-	if (status & 0x01) {
-		ret = -1;
-	}
-
-	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
-	return ret;
+    int ret = 0;
+    int status;
+    struct nand_chip *this = meminfo->priv;
+
+    /* select the NAND device */
+    this->select_chip(meminfo, 0);
+
+    this->cmdfunc(meminfo,
+              (tight ? NAND_CMD_LOCK_TIGHT : NAND_CMD_LOCK),
+              -1, -1);
+
+    /* call wait ready function */
+    status = this->waitfunc(meminfo, this, FL_WRITING);
+
+    /* see if device thinks it succeeded */
+    if (status & 0x01) {
+        ret = -1;
+    }
+
+    /* de-select the NAND device */
+    this->select_chip(meminfo, -1);
+    return ret;
 }
 
 /**
  * nand_get_lock_status: - query current lock state from one page of NAND
- *			   flash
+ *             flash
  *
- * @param meminfo	nand mtd instance
- * @param offset	page address to query (muss be page aligned!)
+ * @param meminfo   nand mtd instance
+ * @param offset    page address to query (muss be page aligned!)
  *
- * @return		-1 in case of error
- *			>0 lock status:
- *			  bitfield with the following combinations:
- *			  NAND_LOCK_STATUS_TIGHT: page in tight state
- *			  NAND_LOCK_STATUS_LOCK:  page locked
- *			  NAND_LOCK_STATUS_UNLOCK: page unlocked
+ * @return      -1 in case of error
+ *          >0 lock status:
+ *            bitfield with the following combinations:
+ *            NAND_LOCK_STATUS_TIGHT: page in tight state
+ *            NAND_LOCK_STATUS_LOCK:  page locked
+ *            NAND_LOCK_STATUS_UNLOCK: page unlocked
  *
  */
 int nand_get_lock_status(nand_info_t *meminfo, ulong offset)
 {
-	int ret = 0;
-	int chipnr;
-	int page;
-	struct nand_chip *this = meminfo->priv;
-
-	/* select the NAND device */
-	chipnr = (int)(offset >> this->chip_shift);
-	this->select_chip(meminfo, chipnr);
-
-
-	if ((offset & (meminfo->oobblock - 1)) != 0) {
-		printf ("nand_get_lock_status: "
-			"Start address must be beginning of "
-			"nand page!\n");
-		ret = -1;
-		goto out;
-	}
-
-	/* check the Lock Status */
-	page = (int)(offset >> this->page_shift);
-	this->cmdfunc(meminfo, NAND_CMD_LOCK_STATUS, -1, page & this->pagemask);
-
-	ret = this->read_byte(meminfo) & (NAND_LOCK_STATUS_TIGHT
-					  | NAND_LOCK_STATUS_LOCK
-					  | NAND_LOCK_STATUS_UNLOCK);
+    int ret = 0;
+    int chipnr;
+    int page;
+    struct nand_chip *this = meminfo->priv;
+
+    /* select the NAND device */
+    chipnr = (int)(offset >> this->chip_shift);
+    this->select_chip(meminfo, chipnr);
+
+
+    if ((offset & (meminfo->oobblock - 1)) != 0) {
+        printf ("nand_get_lock_status: "
+            "Start address must be beginning of "
+            "nand page!\n");
+        ret = -1;
+        goto out;
+    }
+
+    /* check the Lock Status */
+    page = (int)(offset >> this->page_shift);
+    this->cmdfunc(meminfo, NAND_CMD_LOCK_STATUS, -1, page & this->pagemask);
+
+    ret = this->read_byte(meminfo) & (NAND_LOCK_STATUS_TIGHT
+                      | NAND_LOCK_STATUS_LOCK
+                      | NAND_LOCK_STATUS_UNLOCK);
 
  out:
-	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
-	return ret;
+    /* de-select the NAND device */
+    this->select_chip(meminfo, -1);
+    return ret;
 }
 
 /**
  * nand_unlock: - Unlock area of NAND pages
- *		  only one consecutive area can be unlocked at one time!
+ *        only one consecutive area can be unlocked at one time!
  *
- * @param meminfo	nand mtd instance
- * @param start		start byte address
- * @param length	number of bytes to unlock (must be a multiple of
- *			page size nand->oobblock)
+ * @param meminfo   nand mtd instance
+ * @param start     start byte address
+ * @param length    number of bytes to unlock (must be a multiple of
+ *          page size nand->oobblock)
  *
- * @return		0 on success, -1 in case of error
+ * @return      0 on success, -1 in case of error
  */
 int nand_unlock(nand_info_t *meminfo, ulong start, ulong length)
 {
-	int ret = 0;
-	int chipnr;
-	int status;
-	int page;
-	struct nand_chip *this = meminfo->priv;
-	printf ("nand_unlock: start: %08x, length: %d!\n",
-		(int)start, (int)length);
-
-	/* select the NAND device */
-	chipnr = (int)(start >> this->chip_shift);
-	this->select_chip(meminfo, chipnr);
-
-	/* check the WP bit */
-	this->cmdfunc(meminfo, NAND_CMD_STATUS, -1, -1);
-	if ((this->read_byte(meminfo) & 0x80) == 0) {
-		printf ("nand_unlock: Device is write protected!\n");
-		ret = -1;
-		goto out;
-	}
-
-	if ((start & (meminfo->oobblock - 1)) != 0) {
-		printf ("nand_unlock: Start address must be beginning of "
-			"nand page!\n");
-		ret = -1;
-		goto out;
-	}
-
-	if (length == 0 || (length & (meminfo->oobblock - 1)) != 0) {
-		printf ("nand_unlock: Length must be a multiple of nand page "
-			"size!\n");
-		ret = -1;
-		goto out;
-	}
-
-	/* submit address of first page to unlock */
-	page = (int)(start >> this->page_shift);
-	this->cmdfunc(meminfo, NAND_CMD_UNLOCK1, -1, page & this->pagemask);
-
-	/* submit ADDRESS of LAST page to unlock */
-	page += (int)(length >> this->page_shift) - 1;
-	this->cmdfunc(meminfo, NAND_CMD_UNLOCK2, -1, page & this->pagemask);
-
-	/* call wait ready function */
-	status = this->waitfunc(meminfo, this, FL_WRITING);
-	/* see if device thinks it succeeded */
-	if (status & 0x01) {
-		/* there was an error */
-		ret = -1;
-		goto out;
-	}
+    int ret = 0;
+    int chipnr;
+    int status;
+    int page;
+    struct nand_chip *this = meminfo->priv;
+    printf ("nand_unlock: start: %08x, length: %d!\n",
+        (int)start, (int)length);
+
+    /* select the NAND device */
+    chipnr = (int)(start >> this->chip_shift);
+    this->select_chip(meminfo, chipnr);
+
+    /* check the WP bit */
+    this->cmdfunc(meminfo, NAND_CMD_STATUS, -1, -1);
+    if ((this->read_byte(meminfo) & 0x80) == 0) {
+        printf ("nand_unlock: Device is write protected!\n");
+        ret = -1;
+        goto out;
+    }
+
+    if ((start & (meminfo->oobblock - 1)) != 0) {
+        printf ("nand_unlock: Start address must be beginning of "
+            "nand page!\n");
+        ret = -1;
+        goto out;
+    }
+
+    if (length == 0 || (length & (meminfo->oobblock - 1)) != 0) {
+        printf ("nand_unlock: Length must be a multiple of nand page "
+            "size!\n");
+        ret = -1;
+        goto out;
+    }
+
+    /* submit address of first page to unlock */
+    page = (int)(start >> this->page_shift);
+    this->cmdfunc(meminfo, NAND_CMD_UNLOCK1, -1, page & this->pagemask);
+
+    /* submit ADDRESS of LAST page to unlock */
+    page += (int)(length >> this->page_shift) - 1;
+    this->cmdfunc(meminfo, NAND_CMD_UNLOCK2, -1, page & this->pagemask);
+
+    /* call wait ready function */
+    status = this->waitfunc(meminfo, this, FL_WRITING);
+    /* see if device thinks it succeeded */
+    if (status & 0x01) {
+        /* there was an error */
+        ret = -1;
+        goto out;
+    }
 
  out:
-	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
-	return ret;
+    /* de-select the NAND device */
+    this->select_chip(meminfo, -1);
+    return ret;
 }
 
 #endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) && !defined(CFG_NAND_LEGACY) */
diff -urN u-boot-1.1.6/drivers/nand_legacy/nand_legacy.c u-boot-1.1.6_fdt/drivers/nand_legacy/nand_legacy.c
--- u-boot-1.1.6/drivers/nand_legacy/nand_legacy.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/nand_legacy/nand_legacy.c	2018-10-22 15:53:21.553641225 +0800
@@ -60,6 +60,7 @@
 #define NANDRW_WRITE	0x00
 #define NANDRW_JFFS2	0x02
 #define NANDRW_JFFS2_SKIP	0x04
+#define NANDRW_YAFFS	0x08    /* to write yaffs image, www.100ask.net */
 
 
 /*
@@ -185,6 +186,31 @@
 	 */
 	unsigned long eblk = ~0;	/* force mismatch on first pass */
 	unsigned long erasesize = nand->erasesize;
+    int bfirstyaffsblk = 1;
+    int page;
+    unsigned long badblk=0, prgmblk=0;
+    unsigned long badblks=0, prgmblks = 0;
+    unsigned long allblks;
+
+    allblks = (erasesize/nand->oobblock)*(nand->oobblock+nand->oobsize);
+    allblks = (len + allblks - 1) / allblks;
+    
+	if ((cmd & NANDRW_YAFFS) && (len % (nand->oobblock + nand->oobsize))) {
+        printf("Length of the yaffs image should be times of (%d +%d), now it is %d\n", nand->oobblock, nand->oobsize, len);
+        return -1;
+    }
+
+    if ((cmd & NANDRW_YAFFS) && (start % erasesize)) {
+        printf("Start address of the flash should be %d align\n", erasesize);
+        return -1;
+    }
+
+	if (cmd & (NANDRW_WRITE | NANDRW_YAFFS)) {
+        printf("Flash params: oobblock = %d, oobsize = %d, erasesize = %d\n", nand->oobblock, nand->oobsize, nand->erasesize);
+    	printf("Programming NAND with yaffs image, length = %d\n", len);
+        printf(" Block Programming(addr/count) --- Block bad(addr/count) --- Block programed/All(%%)\n");
+        printf("------------------------------------------------------------------------------------\n");
+	}
 
 	while (len) {
 		if ((start & (-erasesize)) != eblk) {
@@ -193,6 +219,8 @@
 			 */
 			eblk = start & (-erasesize); /* start of block */
 			if (check_block(nand, eblk)) {
+                badblk = eblk;
+                badblks++;
 				if (cmd == (NANDRW_READ | NANDRW_JFFS2)) {
 					while (len > 0 &&
 					       start - eblk < erasesize) {
@@ -209,6 +237,12 @@
 					/* skip bad block */
 					start += erasesize;
 					continue;
+				} else if (cmd == (NANDRW_WRITE | NANDRW_YAFFS)) {
+				    /* by www.100ask.net */
+                    printf("       0x%08x/%05d               0x%08x/%05d          %05d/%05d=%02d%%\r", prgmblk, prgmblks, badblk, badblks, prgmblks, allblks, prgmblks*100/allblks);
+					/* skip bad block */
+					start += erasesize;
+					continue;
 				} else {
 					ret = 1;
 					break;
@@ -221,7 +255,33 @@
 		if((start != ROUND_DOWN(start, 0x200)) || (len < 0x200))
 			printf("Warning block writes should be at least 512 bytes and start on a 512 byte boundry\n");
 
-		if (cmd & NANDRW_READ) {
+        /* for yaffs, by www.100ask.net */
+		if (cmd & (NANDRW_WRITE | NANDRW_YAFFS)) {
+			/* Do some programming, but not in the first block */			
+            if (!bfirstyaffsblk) {
+                prgmblk = start;
+                prgmblks++;
+                printf("       0x%08x/%05d               0x%08x/%05d          %05d/%05d=%02d%%\r", prgmblk, prgmblks, badblk, badblks, prgmblks, allblks, prgmblks*100/allblks);
+                for (page = 0; (page < erasesize/nand->oobblock) && (len - page*(nand->oobblock+nand->oobsize) > 0); page++) {
+        			ret = nand_write_ecc(nand, start+page*nand->oobblock,
+        					    nand->oobblock, (size_t *)&n,
+        					    (u_char*)buf+page*(nand->oobblock+nand->oobsize), (u_char *)0); /* without ecc */
+                    if (!ret) 
+                        ret = nand_write_oob(nand, start+page*nand->oobblock,
+    						     nand->oobsize, (size_t *)&n,
+    						     (u_char*)buf+page*(nand->oobblock+nand->oobsize)+nand->oobblock);
+                    if (ret)
+                        break;
+                }
+                n = page * (nand->oobblock+nand->oobsize);
+            } else {
+                bfirstyaffsblk = 0;
+                n = 0;
+                start += erasesize;     /* skip first block */
+                ret = 0;
+                page = 0;
+            }
+		} else if (cmd & NANDRW_READ) {
 			ret = nand_read_ecc(nand, start,
 					   min(len, eblk + erasesize - start),
 					   (size_t *)&n, (u_char*)buf, (u_char *)eccbuf);
@@ -234,14 +294,18 @@
 		if (ret)
 			break;
 
-		start  += n;
+		if (cmd & (NANDRW_WRITE | NANDRW_YAFFS))
+    		start  += page * nand->oobblock;
+        else
+    		start  += n;
+        
 		buf   += n;
 		total += n;
 		len   -= n;
 	}
 	if (retlen)
 		*retlen = total;
-
+    printf("\n");
 	return ret;
 }
 
@@ -759,6 +823,7 @@
 
 /*
  *	Nand_page_program function is used for write and writev !
+ *  Change By www.100ask.net, if ecc_code is null, write without ECC
  */
 static int nand_write_page (struct nand_chip *nand,
 			    int page, int col, int last, u_char * ecc_code)
@@ -766,6 +831,7 @@
 
 	int i;
 	unsigned long nandptr = nand->IO_ADDR;
+    int writecnt;
 
 #ifdef CONFIG_MTD_NAND_ECC
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
@@ -778,8 +844,9 @@
 
 #ifdef CONFIG_MTD_NAND_ECC
 	/* Zero out the ECC array */
-	for (i = 0; i < 6; i++)
-		ecc_code[i] = 0x00;
+    if (ecc_code)   /* www.100ask.net */
+    	for (i = 0; i < 6; i++)
+    		ecc_code[i] = 0x00;
 
 	/* Read back previous written data, if col > 0 */
 	if (col) {
@@ -807,7 +874,9 @@
 	}
 
 	/* Calculate and write the ECC if we have enough data */
-	if ((col < nand->eccsize) && (last >= nand->eccsize)) {
+	//if ((col < nand->eccsize) && (last >= nand->eccsize)) {
+    /* if ecc_code is null, write without ecc, www.100ask.net */
+	if (ecc_code && (col < nand->eccsize) && (last >= nand->eccsize)) {
 		nand_calculate_ecc (&nand->data_buf[0], &(ecc_code[0]));
 		for (i = 0; i < 3; i++) {
 			nand->data_buf[(nand->oobblock +
@@ -820,7 +889,9 @@
 	}
 
 	/* Calculate and write the second ECC if we have enough data */
-	if ((nand->oobblock == 512) && (last == nand->oobblock)) {
+	//if ((nand->oobblock == 512) && (last == nand->oobblock)) {
+    /* if ecc_code is null, write without ecc, www.100ask.net */
+	if (ecc_code && (nand->oobblock == 512) && (last == nand->oobblock)) {
 		nand_calculate_ecc (&nand->data_buf[256], &(ecc_code[3]));
 		for (i = 3; i < 6; i++) {
 			nand->data_buf[(nand->oobblock +
@@ -851,15 +922,21 @@
 			      (page << nand->page_shift) + col);
 	}
 
+    /* if ecc_code is null, write without ecc, www.100ask.net */
+    if (ecc_code)
+        writecnt = nand->oobblock + nand->oobsize;
+    else
+        writecnt = nand->oobblock;
+
 	/* Write out complete page of data */
 	if (nand->bus16) {
-		for (i = 0; i < (nand->oobblock + nand->oobsize); i += 2) {
+		for (i = 0; i < writecnt; i += 2) {
 			WRITE_NAND (nand->data_buf[i] +
 				    (nand->data_buf[i + 1] << 8),
 				    nand->IO_ADDR);
 		}
 	} else {
-		for (i = 0; i < (nand->oobblock + nand->oobsize); i++)
+		for (i = 0; i < writecnt; i++)
 			WRITE_NAND (nand->data_buf[i], nand->IO_ADDR);
 	}
 
@@ -933,35 +1010,38 @@
 	 * We also want to check that the ECC bytes wrote
 	 * correctly for the same reasons stated above.
 	 */
-	NanD_Command (nand, NAND_CMD_READOOB);
-	if (nand->bus16) {
-		NanD_Address (nand, ADDR_COLUMN_PAGE,
-			      (page << nand->page_shift) + (col >> 1));
-	} else {
-		NanD_Address (nand, ADDR_COLUMN_PAGE,
-			      (page << nand->page_shift) + col);
-	}
-	if (nand->bus16) {
-		for (i = 0; i < nand->oobsize; i += 2) {
-			u16 val;
-
-			val = READ_NAND (nand->IO_ADDR);
-			nand->data_buf[i] = val & 0xff;
-			nand->data_buf[i + 1] = val >> 8;
-		}
-	} else {
-		for (i = 0; i < nand->oobsize; i++) {
-			nand->data_buf[i] = READ_NAND (nand->IO_ADDR);
-		}
-	}
-	for (i = 0; i < ecc_bytes; i++) {
-		if ((nand->data_buf[(oob_config.ecc_pos[i])] != ecc_code[i]) && ecc_code[i]) {
-			printf ("%s: Failed ECC write "
-				"verify, page 0x%08x, "
-				"%6i bytes were succesful\n",
-				__FUNCTION__, page, i);
-			return -1;
-		}
+    /* if ecc_code is null, write without ecc, www.100ask.net */
+	if (ecc_code) {
+    	NanD_Command (nand, NAND_CMD_READOOB);
+    	if (nand->bus16) {
+    		NanD_Address (nand, ADDR_COLUMN_PAGE,
+    			      (page << nand->page_shift) + (col >> 1));
+    	} else {
+    		NanD_Address (nand, ADDR_COLUMN_PAGE,
+    			      (page << nand->page_shift) + col);
+    	}
+    	if (nand->bus16) {
+    		for (i = 0; i < nand->oobsize; i += 2) {
+    			u16 val;
+
+    			val = READ_NAND (nand->IO_ADDR);
+    			nand->data_buf[i] = val & 0xff;
+    			nand->data_buf[i + 1] = val >> 8;
+    		}
+    	} else {
+    		for (i = 0; i < nand->oobsize; i++) {
+    			nand->data_buf[i] = READ_NAND (nand->IO_ADDR);
+    		}
+    	}
+    	for (i = 0; i < ecc_bytes; i++) {
+    		if ((nand->data_buf[(oob_config.ecc_pos[i])] != ecc_code[i]) && ecc_code[i]) {
+    			printf ("%s: Failed ECC write "
+    				"verify, page 0x%08x, "
+    				"%6i bytes were succesful\n",
+    				__FUNCTION__, page, i);
+    			return -1;
+    		}
+    	}
 	}
 #endif	/* CONFIG_MTD_NAND_ECC */
 #endif	/* CONFIG_MTD_NAND_VERIFY_WRITE */
@@ -1053,6 +1133,7 @@
 	return ret;
 }
 
+
 /* read from the 16 bytes of oob data that correspond to a 512 byte
  * page or 2 256-byte pages.
  */
@@ -1132,6 +1213,17 @@
 
 	/* issue the Read2 command to set the pointer to the Spare Data Area. */
 	NanD_Command(nand, NAND_CMD_READOOB);
+
+/* bug fixed by www.100ask.net
+ * write oob sequence: 
+ *  1. NAND_CMD_READOOB
+ *  2. NAND_CMD_SEQIN
+ *  3. Address
+ *  4. Data
+ *  5. NAND_CMD_PAGEPROG
+ *  6. NAND_CMD_STATUS
+ */
+#if 0   
 	if (nand->bus16) {
  		NanD_Address(nand, ADDR_COLUMN_PAGE,
 			     ((ofs >> nand->page_shift) << nand->page_shift) +
@@ -1139,7 +1231,7 @@
 	} else {
  		NanD_Address(nand, ADDR_COLUMN_PAGE, ofs);
 	}
-
+#endif
 	/* update address for 2M x 8bit devices. OOB starts on the second */
 	/* page to maintain compatibility with nand_read_ecc. */
 	if (nand->page256) {
diff -urN u-boot-1.1.6/drivers/usb/2440usb.h u-boot-1.1.6_fdt/drivers/usb/2440usb.h
--- u-boot-1.1.6/drivers/usb/2440usb.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/2440usb.h	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,117 @@
+/*********************************************
+  NAME: 2440usb.h
+  DESC: 
+  HISTORY:
+  03.23.2002:purnnamu: first release for 2410
+ *********************************************/
+#ifndef __24XUSB_H__
+#define __24XUSB_H__
+
+//*************************************************************************
+// USB definitons
+//*************************************************************************
+
+/* Power Management Register */
+#define DISABLE_SUSPEND          0x00   
+#define ENABLE_SUSPEND           0x01
+#define SUSPEND_MODE		 0x02
+#define MCU_RESUME               0x04
+#define ISO_UPDATE		 (1<<7)
+
+/* MAXP Register */
+#define FIFO_SIZE_0              0x00  /* 0x00 * 8 = 0  */
+#define FIFO_SIZE_8              0x01  /* 0x01 * 8 = 8  */
+#define FIFO_SIZE_16             0x02  /* 0x02 * 8 = 16 */
+#define FIFO_SIZE_32             0x04  /* 0x04 * 8 = 32 */
+#define FIFO_SIZE_64             0x08  /* 0x08 * 8 = 64 */
+
+/* ENDPOINT0 CSR (Control Status Register) : Mapped to IN CSR1 */
+#define EP0_OUT_PKT_READY        0x01  /* USB sets, MCU clears by setting SERVICED_OUT_PKT_RDY */
+#define EP0_IN_PKT_READY         0x02  /* MCU sets, USB clears after sending FIFO */
+#define EP0_SENT_STALL           0x04  /* USB sets */       
+#define EP0_DATA_END             0x08  /* MCU sets */
+#define EP0_SETUP_END            0x10  /* USB sets, MCU clears by setting SERVICED_SETUP_END */
+#define EP0_SEND_STALL           0x20  /* MCU sets */
+#define EP0_SERVICED_OUT_PKT_RDY 0x40  /* MCU writes 1 to clear OUT_PKT_READY */
+#define EP0_SERVICED_SETUP_END   0x80  /* MCU writes 1 to clear SETUP_END        */
+
+#define EP0_WR_BITS              0xc0  
+
+//EP_INT_REG / EP_INT_EN_REG
+#define EP0_INT                	 0x01  // Endpoint 0, Control   
+#define EP1_INT                  0x02  // Endpoint 1, (Bulk-In) 
+#define EP2_INT                  0x04  // Endpoint 2 
+#define EP3_INT			 0x08  // Endpoint 3, (Bulk-Out)   
+#define EP4_INT			 0x10  // Endpoint 4
+
+//USB_INT_REG / USB_INT_EN_REG
+#define SUSPEND_INT            	 0x01  
+#define RESUME_INT               0x02  
+#define RESET_INT                0x04  
+
+//IN_CSR1
+#define EPI_IN_PKT_READY         0x01  
+#define EPI_UNDER_RUN		 0x04
+#define EPI_FIFO_FLUSH		 0x08
+#define EPI_SEND_STALL           0x10  
+#define EPI_SENT_STALL           0x20  
+#define EPI_CDT			 0x40	
+#define EPI_WR_BITS              (EPI_FIFO_FLUSH|EPI_IN_PKT_READY|EPI_CDT) 
+					//(EPI_FIFO_FLUSH) is preferred  (???)
+//IN_CSR2
+#define EPI_IN_DMA_INT_MASK	(1<<4)
+#define EPI_MODE_IN		(1<<5)
+#define EPI_MODE_OUT		(0<<5)
+#define EPI_ISO			(1<<6)
+#define EPI_BULK		(0<<6)
+#define EPI_AUTO_SET		(1<<7)
+
+//OUT_CSR1
+#define EPO_OUT_PKT_READY        0x01  
+#define EPO_OVER_RUN		 0x04  
+#define EPO_DATA_ERROR		 0x08  
+#define EPO_FIFO_FLUSH		 0x10
+#define EPO_SEND_STALL           0x20  
+#define EPO_SENT_STALL           0x40
+#define EPO_CDT			 0x80	
+#define EPO_WR_BITS              (EPO_FIFO_FLUSH|EPO_SEND_STALL|EPO_CDT)
+					//(EPO_FIFO_FLUSH) is preferred (???)
+
+//OUT_CSR2
+#define EPO_OUT_DMA_INT_MASK	(1<<5)
+#define EPO_ISO		 	(1<<6)
+#define EPO_BULK	 	(0<<6)
+#define EPO_AUTO_CLR		(1<<7)
+
+//USB DMA control register
+#define UDMA_IN_RUN_OB		(1<<7)
+#define UDMA_IGNORE_TTC		(1<<7)
+#define UDMA_DEMAND_MODE	(1<<3)
+#define UDMA_OUT_RUN_OB		(1<<2)
+#define UDMA_OUT_DMA_RUN	(1<<2)
+#define UDMA_IN_DMA_RUN		(1<<1)
+#define UDMA_DMA_MODE_EN	(1<<0)
+
+#define rEP1_DMA_TTC	(rEP1_DMA_TTC_L+(rEP1_DMA_TTC_M<<8)+(rEP1_DMA_TTC_H<<16))
+#define rEP2_DMA_TTC	(rEP2_DMA_TTC_L+(rEP2_DMA_TTC_M<<8)+(rEP2_DMA_TTC_H<<16))
+#define rEP3_DMA_TTC	(rEP3_DMA_TTC_L+(rEP3_DMA_TTC_M<<8)+(rEP3_DMA_TTC_H<<16))
+#define rEP4_DMA_TTC	(rEP4_DMA_TTC_L+(rEP4_DMA_TTC_M<<8)+(rEP4_DMA_TTC_H<<16))
+
+#define ADDR_EP0_FIFO 		(0x520001c0) //Endpoint 0 FIFO
+#define ADDR_EP1_FIFO		(0x520001c4) //Endpoint 1 FIFO
+#define ADDR_EP2_FIFO		(0x520001c8) //Endpoint 2 FIFO
+#define ADDR_EP3_FIFO		(0x520001cc) //Endpoint 3 FIFO
+#define ADDR_EP4_FIFO		(0x520001d0) //Endpoint 4 FIFO
+
+//If you chane the packet size, the source code should be changed!!!
+//USB Device Options
+#define USBDMA		TRUE
+//#define USBDMA		FALSE
+#define USBDMA_DEMAND 	FALSE	//the downloadFileSize should be (64*n)
+#define BULK_PKT_SIZE	32
+
+#define EP0_PKT_SIZE             8	
+#define EP1_PKT_SIZE             BULK_PKT_SIZE
+#define EP3_PKT_SIZE             BULK_PKT_SIZE
+
+#endif //__24XUSB_H__
diff -urN u-boot-1.1.6/drivers/usb/Makefile u-boot-1.1.6_fdt/drivers/usb/Makefile
--- u-boot-1.1.6/drivers/usb/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/Makefile	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,45 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB 	:= $(obj)libusb.a
+
+COBJS 	:= usbin.o  usblib.o  usbmain.o  usbout.o  usbsetup.o usbinit.o
+
+SRCS 	:= $(COBJS:.o=.c)
+OBJS 	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-1.1.6/drivers/usb/mrgtmp0 u-boot-1.1.6_fdt/drivers/usb/mrgtmp0
--- u-boot-1.1.6/drivers/usb/mrgtmp0	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/mrgtmp0	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,537 @@
+/****************************************************************
+ NAME: u2440mon.c
+ DESC: u2440mon entry point,menu,download
+ HISTORY:
+ Mar.25.2002:purnnamu: S3C2400X profile.c is ported for S3C2410X.
+ Mar.27.2002:purnnamu: DMA is enabled.
+ Apr.01.2002:purnnamu: isDownloadReady flag is added.
+ Apr.10.2002:purnnamu: - Selecting menu is available in the waiting loop. 
+                         So, isDownloadReady flag gets not needed
+                       - UART ch.1 can be selected for the console.
+ Aug.20.2002:purnnamu: revision number change 0.2 -> R1.1       
+ Sep.03.2002:purnnamu: To remove the power noise in the USB signal, the unused CLKOUT0,1 is disabled.
+ ****************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+#include "def.h"
+#include "option.h"
+#include "2440addr.h"
+#include "2440lib.h"
+#include "2440slib.h"
+#include "mmu.h"
+#include "profile.h"
+#include "memtest.h"
+
+#include "usbmain.h"
+#include "usbout.h"
+#include "usblib.h"
+#include "2440usb.h"
+#include "printk.h"
+#include "types.h"
+
+
+#include "platform/smdk2440.h"
+
+
+void Isr_Init(void);
+void HaltUndef(void);
+void HaltSwi(void);
+void HaltPabort(void);
+void HaltDabort(void);
+void Lcd_Off(void);
+void WaitDownload(void);
+void Menu(void);
+void ClearMemory(void);
+
+
+void Clk0_Enable(int clock_sel);	
+void Clk1_Enable(int clock_sel);
+void Clk0_Disable(void);
+void Clk1_Disable(void);
+
+//#define DOWNLOAD_ADDRESS _RAM_STARTADDRESS
+volatile U32 downloadAddress;
+
+void (*restart)(void)=(void (*)(void))0x0;
+void (*run)(void);
+
+
+volatile unsigned char *downPt;
+volatile U32 downloadFileSize;
+volatile U16 checkSum;
+volatile unsigned int err=0;
+volatile U32 totalDmaCount;
+
+volatile int isUsbdSetConfiguration;
+
+int download_run=0;
+U32 tempDownloadAddress;
+int menuUsed=0;
+
+extern char Image$$RW$$Limit[];
+U32 *pMagicNum=(U32 *)Image$$RW$$Limit;
+int consoleNum;
+
+void usb_init(void)
+{
+	char *mode;
+	int i;
+	U8 key;
+	U32 mpll_val, divn_upll=0;
+    
+	#if ADS10   
+	__rt_lib_init(); //for ADS 1.0
+	#endif
+
+	Port_Init();
+	// USB device detection control
+	rGPGCON &= ~(3<<24);
+	rGPGCON |=  (1<<24); // output
+	rGPGUP  |=  (1<<12); // pullup disable
+	rGPGDAT |=  (1<<12); // output	
+	
+
+	//ChangeUPllValue(60,4,2);		// 48MHz
+	//for(i=0; i<7; i++);
+	//ChangeClockDivider(13,12);
+	//ChangeMPllValue(97,1,2);		//296Mhz
+
+	Isr_Init();
+
+	consoleNum=1;		// Uart 1 select for debug.
+	Uart_Init(0,115200);
+	Uart_Select(consoleNum);
+
+	rMISCCR=rMISCCR&~(1<<3); // USBD is selected instead of USBH1 
+	rMISCCR=rMISCCR&~(1<<13); // USB port 1 is enabled.
+
+
+//
+//  USBD should be initialized first of all.
+//
+	isUsbdSetConfiguration=0;
+
+#if 0
+	UsbdMain(); 
+	MMU_Init(); //MMU should be reconfigured or turned off for the debugger, 
+	//After downloading, MMU should be turned off for the MMU based program,such as WinCE.	
+#else
+	MMU_EnableICache();  
+	UsbdMain(); 
+#endif
+	Delay(0);  //calibrate Delay()
+	
+	pISR_SWI=(_ISR_STARTADDRESS+0xf0);	//for pSOS
+
+	Led_Display(0x6);
+
+#if USBDMA
+	mode="DMA";
+#else
+	mode="Int";
+#endif
+
+	// CLKOUT0/1 select.
+	//Uart_Printf("CLKOUT0:MPLL in, CLKOUT1:RTC clock.\n");
+	//Clk0_Enable(0);	// 0:MPLLin, 1:UPLL, 2:FCLK, 3:HCLK, 4:PCLK, 5:DCLK0
+	//Clk1_Enable(2);	// 0:MPLLout, 1:UPLL, 2:RTC, 3:HCLK, 4:PCLK, 5:DCLK1	
+	Clk0_Disable();
+	Clk1_Disable();
+	
+	mpll_val = rMPLLCON;
+	Uart_Printf("DIVN_UPLL%x\n", divn_upll);
+	Uart_Printf("MPLLVal [M:%xh,P:%xh,S:%xh]\n", (mpll_val&(0xff<<12))>>12,(mpll_val&(0x3f<<4))>>4,(mpll_val&0x3));
+	Uart_Printf("CLKDIVN:%xh\n", rCLKDIVN);
+
+	Uart_Printf("\n\n");
+	Uart_Printf("+---------------------------------------------+\n");
+	Uart_Printf("| S3C2440A USB Downloader ver R0.03 2004 Jan  |\n");
+	Uart_Printf("+---------------------------------------------+\n");
+	Uart_Printf("FCLK=%4.1fMHz,%s mode\n",FCLK/1000000.,mode); 
+	Uart_Printf("USB: IN_ENDPOINT:1 OUT_ENDPOINT:3\n"); 
+	Uart_Printf("FORMAT: <ADDR(DATA):4>+<SIZE(n+10):4>+<DATA:n>+<CS:2>\n");
+	Uart_Printf("NOTE: 1. Power off/on or press the reset button for 1 sec\n");
+	Uart_Printf("		 in order to get a valid USB device address.\n");
+	Uart_Printf("	  2. For additional menu, Press any key. \n");
+	Uart_Printf("\n");
+
+	download_run=1; //The default menu is the Download & Run mode.
+
+	while(1)
+	{
+		if(menuUsed==1)Menu();
+		WaitDownload();	
+	}
+
+}
+
+
+
+void Menu(void)
+{
+	int i;
+	U8 key;
+	menuUsed=1;
+	while(1)
+	{
+		Uart_Printf("\n###### Select Menu ######\n");
+		Uart_Printf(" [0] Download & Run\n");
+		Uart_Printf(" [1] Download Only\n");
+		Uart_Printf(" [2] Test SDRAM \n");
+		Uart_Printf(" [3] Change The Console UART Ch.\n");
+		Uart_Printf(" [4] Clear unused area in SDRAM \n");		
+		key=Uart_Getch();
+		
+		switch(key)
+		{
+		case '0':
+			Uart_Printf("\nDownload&Run is selected.\n\n");
+			download_run=1;
+			return;
+		case '1':
+			Uart_Printf("\nDownload Only is selected.\n");
+			Uart_Printf("Enter a new temporary download address(0x3...):");
+			tempDownloadAddress=Uart_GetIntNum();
+			download_run=0;
+			Uart_Printf("The temporary download address is 0x%x.\n\n",tempDownloadAddress);
+			return;
+		case '2':
+			Uart_Printf("\nMemory Test is selected.\n");
+		MemoryTest();
+		Menu();
+		return;
+			break;
+		case '3':
+			Uart_Printf("\nWhich UART channel do you want to use for the console?[0/1]\n");
+			if(Uart_Getch()!='1')
+			{
+			*pMagicNum=0x0;
+		Uart_Printf("UART ch.0 will be used for console at next boot.\n");					
+		}
+		else
+		{
+			*pMagicNum=0x12345678;
+ 		Uart_Printf("UART ch.1 will be used for console at next boot.\n");		
+				Uart_Printf("UART ch.0 will be used after long power-off.\n");
+		}
+			Uart_Printf("System is waiting for a reset. Please, Reboot!!!\n");
+			while(1);
+			break;
+		case '4':
+			Uart_Printf("\nMemory clear is selected.\n");
+			ClearMemory();
+		break;
+		default:
+			break;
+	}	
+	}		
+
+}
+
+
+
+void WaitDownload(void)
+{
+	U32 i;
+	U32 j;
+	U16 cs;
+	U32 temp;
+	U16 dnCS;
+	int first=1;
+	float time;
+	U8 tempMem[16];
+	U8 key;
+	
+	checkSum=0;
+	downloadAddress=(U32)tempMem; //_RAM_STARTADDRESS; 
+	downPt=(unsigned char *)downloadAddress;
+	//This address is used for receiving first 8 byte.
+	downloadFileSize=0;
+	
+#if 0
+	MMU_DisableICache(); 
+		//For multi-ICE. 
+		//If ICache is not turned-off, debugging is started with ICache-on.
+#endif
+
+	/*******************************/
+	/*	Test program download	*/
+	/*******************************/
+	j=0;
+
+	if(isUsbdSetConfiguration==0)
+	{
+	Uart_Printf("USB host is not connected yet.\n");
+	}
+
+	while(downloadFileSize==0)
+	{
+		if(first==1 && isUsbdSetConfiguration!=0)
+		{
+			Uart_Printf("USB host is connected. Waiting a download.\n");
+			first=0;
+		}
+
+	if(j%0x50000==0)Led_Display(0x6);
+	if(j%0x50000==0x28000)Led_Display(0x9);
+	j++;
+
+	key=Uart_GetKey();
+	if(key!=0)
+	{
+		Menu();
+			first=1; //To display the message,"USB host ...."
+	}
+
+	}
+
+	Timer_InitEx();	  
+	Timer_StartEx();  
+
+#if USBDMA	
+
+	rINTMSK&=~(BIT_DMA2);  
+
+	ClearEp3OutPktReady(); 
+		// indicate the first packit is processed.
+		// has been delayed for DMA2 cofiguration.
+
+	if(downloadFileSize>EP3_PKT_SIZE)
+	{
+		if(downloadFileSize<=(0x80000))
+		{
+	  		ConfigEp3DmaMode(downloadAddress+EP3_PKT_SIZE-8,downloadFileSize-EP3_PKT_SIZE);	
+ 
+	  		//will not be used.
+/*	   rDIDST2=(downloadAddress+downloadFileSize-EP3_PKT_SIZE);  
+		   rDIDSTC2=(0<<1)|(0<<0);  
+		rDCON2=rDCON2&~(0xfffff)|(0);				
+*/
+		}
+	  	else
+	  	{
+	  		ConfigEp3DmaMode(downloadAddress+EP3_PKT_SIZE-8,0x80000-EP3_PKT_SIZE);
+	   		
+			if(downloadFileSize>(0x80000*2))//for 1st autoreload
+			{
+				rDIDST2=(downloadAddress+0x80000-8);  //for 1st autoreload.
+			 rDIDSTC2=(1<<2)|(0<<1)|(0<<0);  
+				rDCON2=rDCON2&~(0xfffff)|(0x80000);			  
+
+  		while(rEP3_DMA_TTC<0xfffff)
+  		{
+  			rEP3_DMA_TTC_L=0xff; 
+  			rEP3_DMA_TTC_M=0xff;
+  			rEP3_DMA_TTC_H=0xf;
+  		}
+			}	
+ 		else
+ 		{
+ 			rDIDST2=(downloadAddress+0x80000-8);  //for 1st autoreload.
+	  			rDIDSTC2=(1<<2)|(0<<1)|(0<<0);  
+ 			rDCON2=rDCON2&~(0xfffff)|(downloadFileSize-0x80000); 		
+
+  		while(rEP3_DMA_TTC<0xfffff)
+  		{
+  			rEP3_DMA_TTC_L=0xff; 
+  			rEP3_DMA_TTC_M=0xff;
+  			rEP3_DMA_TTC_H=0xf;
+  		}
+		}
+	}
+ 	totalDmaCount=0;
+	}
+	else
+	{
+	totalDmaCount=downloadFileSize;
+	}
+#endif
+
+	Uart_Printf("\nNow, Downloading [ADDRESS:%xh,TOTAL:%d]\n",
+			downloadAddress,downloadFileSize);
+	Uart_Printf("RECEIVED FILE SIZE:%8d",0);
+   
+#if USBDMA	
+	j=0x10000;
+
+	while(1)
+	{
+		if( (rDCDST2-(U32)downloadAddress+8)>=j)
+	{
+		Uart_Printf("\b\b\b\b\b\b\b\b%8d",j);
+   		j+=0x10000;
+		}
+	if(totalDmaCount>=downloadFileSize)break;
+	}
+
+#else
+	j=0x10000;
+
+	while(((U32)downPt-downloadAddress)<(downloadFileSize-8))
+	{
+	if( ((U32)downPt-downloadAddress)>=j)
+	{
+		Uart_Printf("\b\b\b\b\b\b\b\b%8d",j);
+   		j+=0x10000;
+	}
+	}
+#endif
+
+	time=Timer_StopEx();
+	
+	Uart_Printf("\b\b\b\b\b\b\b\b%8d",downloadFileSize);	
+	Uart_Printf("\n(%5.1fKB/S,%3.1fS)\n",(float)(downloadFileSize/time/1000.),time);
+	
+#if USBDMA	
+	/*******************************/
+	/*	 Verify check sum		*/
+	/*******************************/
+
+	Uart_Printf("Now, Checksum calculation\n");
+
+	cs=0;	
+	i=(downloadAddress);
+	j=(downloadAddress+downloadFileSize-10)&0xfffffffc;
+	while(i<j)
+	{
+		temp=*((U32 *)i);
+		i+=4;
+		cs+=(U16)(temp&0xff);
+		cs+=(U16)((temp&0xff00)>>8);
+		cs+=(U16)((temp&0xff0000)>>16);
+		cs+=(U16)((temp&0xff000000)>>24);
+	}
+
+	i=(downloadAddress+downloadFileSize-10)&0xfffffffc;
+	j=(downloadAddress+downloadFileSize-10);
+	while(i<j)
+	{
+  	cs+=*((U8 *)i++);
+	}
+	
+	checkSum=cs;
+#else
+	//checkSum was calculated including dnCS. So, dnCS should be subtracted.
+	checkSum=checkSum - *((unsigned char *)(downloadAddress+downloadFileSize-8-2))
+		 - *( (unsigned char *)(downloadAddress+downloadFileSize-8-1) );	
+#endif	  
+
+	dnCS=*((unsigned char *)(downloadAddress+downloadFileSize-8-2))+
+	(*( (unsigned char *)(downloadAddress+downloadFileSize-8-1) )<<8);
+
+	if(checkSum!=dnCS)
+	{
+	Uart_Printf("Checksum Error!!! MEM:%x DN:%x\n",checkSum,dnCS);
+	return;
+	}
+
+	Uart_Printf("Download O.K.\n\n");
+	Uart_TxEmpty(consoleNum);
+
+
+	if(download_run==1)
+	{
+		rINTMSK=BIT_ALLMSK;
+		run=(void (*)(void))downloadAddress;
+	run();
+	}
+}
+
+
+
+
+void Isr_Init(void)
+{
+	pISR_UNDEF=(unsigned)HaltUndef;
+	pISR_SWI  =(unsigned)HaltSwi;
+	pISR_PABORT=(unsigned)HaltPabort;
+	pISR_DABORT=(unsigned)HaltDabort;
+	rINTMOD=0x0;	  // All=IRQ mode
+	rINTMSK=BIT_ALLMSK;	  // All interrupt is masked.
+
+	//pISR_URXD0=(unsigned)Uart0_RxInt;	
+	//rINTMSK=~(BIT_URXD0);   //enable UART0 RX Default value=0xffffffff
+
+#if 1
+	pISR_USBD =(unsigned)IsrUsbd;
+	pISR_DMA2 =(unsigned)IsrDma2;
+#else
+	pISR_IRQ =(unsigned)IsrUsbd;	
+		//Why doesn't it receive the big file if use this. (???)
+		//It always stops when 327680 bytes are received.
+#endif	
+	ClearPending(BIT_DMA2);
+	ClearPending(BIT_USBD);
+	//rINTMSK&=~(BIT_USBD);  
+   
+	//pISR_FIQ,pISR_IRQ must be initialized
+}
+
+
+void HaltUndef(void)
+{
+	Uart_Printf("Undefined instruction exception!!!\n");
+	while(1);
+}
+
+void HaltSwi(void)
+{
+	Uart_Printf("SWI exception!!!\n");
+	while(1);
+}
+
+void HaltPabort(void)
+{
+	Uart_Printf("Pabort exception!!!\n");
+	while(1);
+}
+
+void HaltDabort(void)
+{
+	Uart_Printf("Dabort exception!!!\n");
+	while(1);
+}
+
+
+void ClearMemory(void)
+{
+	int i;
+	U32 data;
+	int memError=0;
+	U32 *pt;
+	
+	//
+	// memory clear
+	//
+	Uart_Printf("Clear Memory (%xh-%xh):WR",_RAM_STARTADDRESS,HEAPEND);
+
+	pt=(U32 *)_RAM_STARTADDRESS;
+	while((U32)pt < HEAPEND)
+	{
+		*pt=(U32)0x0;
+		pt++;
+	}
+	
+	if(memError==0)Uart_Printf("\b\bO.K.\n");
+}
+
+void Clk0_Enable(int clock_sel)	
+{	// 0:MPLLin, 1:UPLL, 2:FCLK, 3:HCLK, 4:PCLK, 5:DCLK0
+	rMISCCR = rMISCCR&~(7<<4) | (clock_sel<<4);
+	rGPHCON = rGPHCON&~(3<<18) | (2<<18);
+}
+void Clk1_Enable(int clock_sel)
+{	// 0:MPLLout, 1:UPLL, 2:RTC, 3:HCLK, 4:PCLK, 5:DCLK1	
+	rMISCCR = rMISCCR&~(7<<8) | (clock_sel<<8);
+	rGPHCON = rGPHCON&~(3<<20) | (2<<20);
+}
+void Clk0_Disable(void)
+{
+	rGPHCON = rGPHCON&~(3<<18);	// GPH9 Input
+}
+void Clk1_Disable(void)
+{
+	rGPHCON = rGPHCON&~(3<<20);	// GPH10 Input
+}
+
diff -urN u-boot-1.1.6/drivers/usb/usb.h u-boot-1.1.6_fdt/drivers/usb/usb.h
--- u-boot-1.1.6/drivers/usb/usb.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usb.h	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,169 @@
+/****************************************************************
+ NAME: usb.h
+ DESC: definitions(USB data structure) for USB setup operation.
+       Because It's h/w independent file, it may be used without any change in future.
+       Reuse the source of S3C2400X u24xmon 
+ HISTORY:
+ Apr.07.2000:purnnamu: first release. 
+ ****************************************************************/
+#ifndef __USB_H__
+#define __USB_H__
+
+//************************
+//       Endpoint 0      
+//************************
+
+// Standard bmRequestTyje (Direction) 
+#define HOST_TO_DEVICE              (0x00)
+#define DEVICE_TO_HOST              (0x80)    
+
+// Standard bmRequestType (Type) 
+#define STANDARD_TYPE               (0x00)
+#define CLASS_TYPE                  (0x20)
+#define VENDOR_TYPE                 (0x40)
+#define RESERVED_TYPE               (0x60)
+
+// Standard bmRequestType (Recipient) 
+#define DEVICE_RECIPIENT            (0)
+#define INTERFACE_RECIPIENT         (1)
+#define ENDPOINT_RECIPIENT          (2)
+#define OTHER_RECIPIENT             (3)
+
+// Feature Selectors 
+#define DEVICE_REMOTE_WAKEUP        (1)
+#define EP_STALL                    (0)
+
+// Standard Request Codes 
+#define GET_STATUS                  (0)
+#define CLEAR_FEATURE               (1)
+#define SET_FEATURE                 (3)
+#define SET_ADDRESS                 (5)
+#define GET_DESCRIPTOR              (6)
+#define SET_DESCRIPTOR              (7)
+#define GET_CONFIGURATION           (8)
+#define SET_CONFIGURATION           (9)
+#define GET_INTERFACE               (10)
+#define SET_INTERFACE               (11)
+#define SYNCH_FRAME                 (12)
+
+// Class-specific Request Codes 
+#define GET_DEVICE_ID               (0)
+#define GET_PORT_STATUS             (1)
+#define SOFT_RESET                  (2)
+
+// Descriptor Types
+#define DEVICE_TYPE                 (1)
+#define CONFIGURATION_TYPE          (2)
+#define STRING_TYPE                 (3)
+#define INTERFACE_TYPE              (4)
+#define ENDPOINT_TYPE               (5)
+
+//configuration descriptor: bmAttributes 
+#define CONF_ATTR_DEFAULT	    (0x80) //Spec 1.0 it was BUSPOWERED bit.
+#define CONF_ATTR_REMOTE_WAKEUP     (0x20)
+#define CONF_ATTR_SELFPOWERED       (0x40)
+
+//endpoint descriptor
+#define EP_ADDR_IN		    (0x80)	
+#define EP_ADDR_OUT		    (0x00)
+
+#define EP_ATTR_CONTROL		    (0x0)	
+#define EP_ATTR_ISOCHRONOUS	    (0x1)
+#define EP_ATTR_BULK		    (0x2)
+#define EP_ATTR_INTERRUPT	    (0x3)	
+
+
+//string descriptor
+#define LANGID_US_L 		    (0x09)  
+#define LANGID_US_H 		    (0x04)
+
+
+struct USB_SETUP_DATA{
+    U8 bmRequestType;    
+    U8 bRequest;         
+    U8 bValueL;          
+    U8 bValueH;          
+    U8 bIndexL;          
+    U8 bIndexH;          
+    U8 bLengthL;         
+    U8 bLengthH;         
+};
+
+
+struct USB_DEVICE_DESCRIPTOR{
+    U8 bLength;    
+    U8 bDescriptorType;         
+    U8 bcdUSBL;
+    U8 bcdUSBH;
+    U8 bDeviceClass;          
+    U8 bDeviceSubClass;          
+    U8 bDeviceProtocol;          
+    U8 bMaxPacketSize0;         
+    U8 idVendorL;
+    U8 idVendorH;
+    U8 idProductL;
+    U8 idProductH;
+    U8 bcdDeviceL;
+    U8 bcdDeviceH;
+    U8 iManufacturer;
+    U8 iProduct;
+    U8 iSerialNumber;
+    U8 bNumConfigurations;
+};
+
+
+struct USB_CONFIGURATION_DESCRIPTOR{
+    U8 bLength;    
+    U8 bDescriptorType;         
+    U8 wTotalLengthL;
+    U8 wTotalLengthH;
+    U8 bNumInterfaces;
+    U8 bConfigurationValue;
+    U8 iConfiguration;
+    U8 bmAttributes;
+    U8 maxPower;          
+};
+    
+
+struct USB_INTERFACE_DESCRIPTOR{
+    U8 bLength;    
+    U8 bDescriptorType;         
+    U8 bInterfaceNumber;
+    U8 bAlternateSetting;
+    U8 bNumEndpoints;
+    U8 bInterfaceClass;
+    U8 bInterfaceSubClass;
+    U8 bInterfaceProtocol;
+    U8 iInterface;
+};
+
+
+struct USB_ENDPOINT_DESCRIPTOR{
+    U8 bLength;    
+    U8 bDescriptorType;         
+    U8 bEndpointAddress;
+    U8 bmAttributes;
+    U8 wMaxPacketSizeL;
+    U8 wMaxPacketSizeH;
+    U8 bInterval;
+};
+
+ struct USB_CONFIGURATION_SET{
+     U8 ConfigurationValue;
+ };
+
+ struct USB_GET_STATUS{
+     U8 Device;
+     U8 Interface;
+     U8 Endpoint0;
+     U8 Endpoint1;
+     U8 Endpoint3;
+ };
+
+ struct USB_INTERFACE_GET{
+     U8 AlternateSetting;
+ };
+
+
+ 
+#endif /*__USB_H__*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
diff -urN u-boot-1.1.6/drivers/usb/usbin.c u-boot-1.1.6_fdt/drivers/usb/usbin.c
--- u-boot-1.1.6/drivers/usb/usbin.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usbin.c	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,111 @@
+/****************************************************************
+ NAME: usbin.c
+ DESC: usb bulk-IN operation
+ HISTORY:
+ Mar.25.2002:purnnamu: ported for S3C2410X.
+ ****************************************************************/
+#include <common.h>
+#if defined(CONFIG_S3C2400)
+#include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+#endif
+
+#include <def.h>
+
+#include "2440usb.h"
+#include "usbmain.h"
+#include "usb.h"
+#include "usblib.h"
+#include "usbsetup.h"
+#include "usbin.h"
+
+extern S3C24X0_USB_DEVICE * usbdevregs;
+extern S3C24X0_DMAS * dmaregs;
+
+static void PrintEpiPkt(U8 *pt,int cnt);
+
+
+// ===================================================================
+// All following commands will operate in case 
+// - in_csr1 is valid.
+// ===================================================================
+
+#define SET_EP1_IN_PKT_READY()  usbdevregs->EP0_CSR_IN_CSR1_REG= ( in_csr1 &(~ EPI_WR_BITS)\
+					| EPI_IN_PKT_READY )	 
+#define SET_EP1_SEND_STALL()	usbdevregs->EP0_CSR_IN_CSR1_REG= ( in_csr1 & (~EPI_WR_BITS)\
+					| EPI_SEND_STALL) )
+#define CLR_EP1_SENT_STALL()	usbdevregs->EP0_CSR_IN_CSR1_REG= ( in_csr1 & (~EPI_WR_BITS)\
+					&(~EPI_SENT_STALL) )
+#define FLUSH_EP1_FIFO() 	usbdevregs->EP0_CSR_IN_CSR1_REG= ( in_csr1 & (~EPI_WR_BITS)\
+					| EPI_FIFO_FLUSH) )
+
+
+// ***************************
+// *** VERY IMPORTANT NOTE ***
+// ***************************
+// Prepare the code for the packit size constraint!!!
+
+// EP1 = IN end point. 
+
+U8 ep1Buf[EP1_PKT_SIZE];
+int transferIndex=0;
+
+
+
+void PrepareEp1Fifo(void) 
+{
+    int i;
+    U8 in_csr1;
+    usbdevregs->INDEX_REG=1;
+    in_csr1=usbdevregs->EP0_CSR_IN_CSR1_REG;
+    
+    for(i=0;i<EP1_PKT_SIZE;i++)ep1Buf[i]=(U8)(transferIndex+i);
+    WrPktEp1(ep1Buf,EP1_PKT_SIZE);
+    SET_EP1_IN_PKT_READY(); 
+}
+
+
+void Ep1Handler(void)
+{
+    U8 in_csr1;
+    int i;
+    usbdevregs->INDEX_REG=1;
+    in_csr1=usbdevregs->EP0_CSR_IN_CSR1_REG;
+    
+    DbgPrintf("<1:%x]",in_csr1);
+
+    //I think that EPI_SENT_STALL will not be set to 1.
+    if(in_csr1 & EPI_SENT_STALL)
+    {   
+   	DbgPrintf("[STALL]");
+   	CLR_EP1_SENT_STALL();
+   	return;
+    }	
+
+    //IN_PKT_READY is cleared
+    
+    //The data transfered was ep1Buf[] which was already configured 
+
+    PrintEpiPkt(ep1Buf,EP1_PKT_SIZE); 
+    
+    transferIndex++;
+
+    PrepareEp1Fifo(); 
+    	//IN_PKT_READY is set   
+    	//This packit will be used for next IN packit.	
+
+    return;
+}
+
+
+    
+void PrintEpiPkt(U8 *pt,int cnt)
+{
+    int i;
+    DbgPrintf("[B_IN:%d:",cnt);
+    for(i=0;i<cnt;i++)
+    	DbgPrintf("%x,",pt[i]);
+    DbgPrintf("]");
+}
+
diff -urN u-boot-1.1.6/drivers/usb/usbin.h u-boot-1.1.6_fdt/drivers/usb/usbin.h
--- u-boot-1.1.6/drivers/usb/usbin.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usbin.h	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,13 @@
+/****************************************************************
+ NAME: usbin.h
+ DESC: 
+ HISTORY:
+ Mar.25.2002:purnnamu: reuse the source of S3C2400X u24xmon 
+ ****************************************************************/
+#ifndef __USBIN_H__
+#define __USBIN_H__
+
+void Ep1Handler(void);
+void PrepareEp1Fifo(void);
+
+#endif /*__USBIN_H__*/
diff -urN u-boot-1.1.6/drivers/usb/usbinit.c u-boot-1.1.6_fdt/drivers/usb/usbinit.c
--- u-boot-1.1.6/drivers/usb/usbinit.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usbinit.c	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,476 @@
+/****************************************************************
+ NAME: u2440mon.c
+ DESC: u2440mon entry point,menu,download
+ HISTORY:
+ Mar.25.2002:purnnamu: S3C2400X profile.c is ported for S3C2410X.
+ Mar.27.2002:purnnamu: DMA is enabled.
+ Apr.01.2002:purnnamu: isDownloadReady flag is added.
+ Apr.10.2002:purnnamu: - Selecting menu is available in the waiting loop. 
+                         So, isDownloadReady flag gets not needed
+                       - UART ch.1 can be selected for the console.
+ Aug.20.2002:purnnamu: revision number change 0.2 -> R1.1       
+ Sep.03.2002:purnnamu: To remove the power noise in the USB signal, the unused CLKOUT0,1 is disabled.
+ ****************************************************************/
+#include <common.h>
+#if defined(CONFIG_S3C2400)
+#include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+#endif
+
+#include "usbmain.h"
+#include "usbout.h"
+#include "usblib.h"
+#include "2440usb.h"
+
+extern S3C24X0_INTERRUPT * intregs;
+S3C24X0_USB_DEVICE * usbdevregs;
+S3C24X0_DMAS * dmaregs;
+S3C24X0_CLOCK_POWER * clk_powerregs;
+S3C24X0_GPIO * gpioregs;
+
+void Isr_Init(void);
+void HaltUndef(void);
+void HaltSwi(void);
+void HaltPabort(void);
+void HaltDabort(void);
+void Lcd_Off(void);
+//void WaitDownload(void);
+__u32 usb_receive(char *buf, size_t len, U32 wait);
+void Menu(void);
+
+extern void Timer_InitEx(void);
+extern void Timer_StartEx(void);
+extern unsigned int Timer_StopEx(void);
+
+extern void (*isr_handle_array[])(void);
+
+/*
+ * Reads and returns a character from the serial port
+ *   - Times out after delay iterations checking for presence of character
+ *   - Sets *error_p to UART error bits or - on timeout
+ *   - On timeout, sets *error_p to -1 and returns 0
+ */
+char awaitkey(unsigned long delay, int* error_p)
+{
+    int i;
+    char c;
+
+    if (delay == -1) {
+        while (1) {
+            if (tstc()) /* we got a key press	*/
+                return getc();
+        }
+    }
+    else {        
+        for (i = 0; i < delay; i++) {
+    		if (tstc()) /* we got a key press	*/
+    			return getc();
+            udelay (10*1000);
+        }
+    }
+    
+    if (error_p)
+        *error_p = -1;
+    return 0;
+}
+
+#define CTRL(x)   (x & 0x1f)
+#define INTR      CTRL('C')
+
+void Clk0_Enable(int clock_sel);	
+void Clk1_Enable(int clock_sel);
+void Clk0_Disable(void);
+void Clk1_Disable(void);
+
+//#define DOWNLOAD_ADDRESS _RAM_STARTADDRESS
+volatile U32 downloadAddress;
+
+void (*restart)(void)=(void (*)(void))0x0;
+void (*run)(void);
+
+
+volatile unsigned char *downPt;
+volatile U32 downloadFileSize;
+volatile U16 checkSum;
+volatile unsigned int err=0;
+volatile U32 totalDmaCount;
+
+volatile int isUsbdSetConfiguration;
+
+int download_run=0;
+volatile U32 tempDownloadAddress;
+int menuUsed=0;
+
+volatile U32 dwUSBBufReadPtr;
+volatile U32 dwUSBBufWritePtr;
+volatile U32 dwWillDMACnt;
+volatile U32 bDMAPending;
+volatile U32 dwUSBBufBase;
+volatile U32 dwUSBBufSize;
+
+int consoleNum;
+
+
+//***************************[ PORTS ]****************************************************
+void Port_Init(void)
+{    
+    gpioregs = S3C24X0_GetBase_GPIO();
+    //CAUTION:Follow the configuration order for setting the ports. 
+    // 1) setting value(GPnDAT) 
+    // 2) setting control register  (GPnCON)
+    // 3) configure pull-up resistor(GPnUP)  
+
+    //32bit data bus configuration  
+    //*** PORT A GROUP
+    //Ports  : GPA22 GPA21  GPA20 GPA19 GPA18 GPA17 GPA16 GPA15 GPA14 GPA13 GPA12  
+    //Signal : nFCE nRSTOUT nFRE   nFWE  ALE   CLE  nGCS5 nGCS4 nGCS3 nGCS2 nGCS1 
+    //Binary :  1     1      1  , 1   1   1    1   ,  1     1     1     1
+    //Ports  : GPA11   GPA10  GPA9   GPA8   GPA7   GPA6   GPA5   GPA4   GPA3   GPA2   GPA1  GPA0
+    //Signal : ADDR26 ADDR25 ADDR24 ADDR23 ADDR22 ADDR21 ADDR20 ADDR19 ADDR18 ADDR17 ADDR16 ADDR0 
+    //Binary :  1       1      1      1   , 1       1      1      1   ,  1       1     1      1         
+    gpioregs->GPACON = 0x7fffff; 
+
+    //**** PORT B GROUP
+    //Ports  : GPB10    GPB9    GPB8    GPB7    GPB6     GPB5    GPB4   GPB3   GPB2     GPB1      GPB0
+    //Signal : nXDREQ0 nXDACK0 nXDREQ1 nXDACK1 nSS_KBD nDIS_OFF L3CLOCK L3DATA L3MODE nIrDATXDEN Keyboard
+    //Setting: INPUT  OUTPUT   INPUT  OUTPUT   INPUT   OUTPUT   OUTPUT OUTPUT OUTPUT   OUTPUT    OUTPUT 
+    //Binary :   00  ,  01       00  ,   01      00   ,  01       01  ,   01     01   ,  01        01  
+    gpioregs->GPBCON = 0x044555;
+    gpioregs->GPBUP  = 0x7ff;     // The pull up function is disabled GPB[10:0]
+	gpioregs->GPBDAT &= ~(1<<0);	/* 禁止蜂鸣器 */
+	gpioregs->GPBDAT &= ~(1<<9);	/* disable USB Device, enable later, thisway.diy */
+
+    //*** PORT C GROUP
+    //Ports  : GPC15 GPC14 GPC13 GPC12 GPC11 GPC10 GPC9 GPC8  GPC7    GPC6     GPC5     GPC4 GPC3     GPC2  GPC1 GPC0
+    //Signal : VD7    VD6    VD5     VD4     VD3     VD2     VD1  VD0    LCDVF2 LCDVF1 OUTPUT VM    VFRAME VLINE VCLK LEND  
+    //Binary :  10     10  ,    10       10  ,     10       10  ,    10     10  ,   10         10  ,      01          10 ,   10         10 ,     10     10
+    gpioregs->GPCCON = 0xaaaaa6aa;       
+    gpioregs->GPCUP  = 0xffff;     // The pull up function is disabled GPC[15:0] 
+	gpioregs->GPCDAT &= ~(1<<5);	/* disable USB Device, enable later, thisway.diy */
+
+    //*** PORT D GROUP
+    //Ports  : GPD15 GPD14 GPD13 GPD12 GPD11 GPD10 GPD9 GPD8 GPD7 GPD6 GPD5 GPD4 GPD3 GPD2 GPD1 GPD0
+    //Signal : VD23  VD22  VD21  VD20  VD19  VD18  VD17 VD16 VD15 VD14 VD13 VD12 VD11 VD10 VD9  VD8
+    //Binary : 10    10  , 10    10  , 10    10  , 10   10 , 10   10 , 10   10 , 10   10 ,10   10
+    gpioregs->GPDCON = 0xaaaaaaaa;       
+    gpioregs->GPDUP  = 0xffff;     // The pull up function is disabled GPD[15:0]
+
+    //*** PORT E GROUP
+    //Ports  : GPE15  GPE14 GPE13   GPE12   GPE11   GPE10   GPE9    GPE8     GPE7  GPE6  GPE5   GPE4  
+    //Signal : IICSDA IICSCL SPICLK SPIMOSI SPIMISO SDDATA3 SDDATA2 SDDATA1 SDDATA0 SDCMD SDCLK IN 
+    //Binary :  10     10  ,  10      10  ,  10      10   ,  10      10   ,   10    10  , 10     00  ,     
+    //-------------------------------------------------------------------------------------------------------
+    //Ports  :  GPE3   GPE2  GPE1    GPE0    
+    //Signal :  IN     IN    IN      IN  
+    //Binary :  00     00  ,  00      00 
+    //rGPECON = 0xaaaaaaaa;       
+    //rGPEUP  = 0xffff;     // The pull up function is disabled GPE[15:0]
+	gpioregs->GPECON = 0xaaaaa800; // For added AC97 setting      
+    gpioregs->GPEUP  = 0xffff;     
+
+     //*** PORT F GROUP
+    //Ports  : GPF7   GPF6   GPF5   GPF4      GPF3     GPF2  GPF1   GPF0
+    //Signal : nLED_8 nLED_4 nLED_2 nLED_1 nIRQ_PCMCIA EINT2 KBDINT EINT0
+    //Setting: Output Output Output Output    EINT3    EINT2 EINT1  EINT0
+    //Binary :  01      01 ,  01     01  ,     10       10  , 10     10
+    gpioregs->GPFCON = 0x55aa;
+    gpioregs->GPFUP  = 0xff;     // The pull up function is disabled GPF[7:0]
+
+    //*** PORT G GROUP
+    //Ports  : GPG15 GPG14 GPG13 GPG12 GPG11    GPG10    GPG9     GPG8     GPG7      GPG6    
+    //Signal : nYPON  YMON nXPON XMON  EINT19 DMAMODE1 DMAMODE0 DMASTART KBDSPICLK KBDSPIMOSI
+    //Setting: nYPON  YMON nXPON Output EINT19  Output   Output   Output   SPICLK1    SPIMOSI1
+    //Binary :   11    11 , 11    01  , 10      01    ,   01       01   ,    11         11
+    //-----------------------------------------------------------------------------------------
+    //Ports  :    GPG5       GPG4    GPG3    GPG2    GPG1    GPG0    
+    //Signal : KBDSPIMISO LCD_PWREN EINT11 nSS_SPI IRQ_LAN IRQ_PCMCIA
+    //Setting:  SPIMISO1  LCD_PWRDN EINT11   nSS0   EINT9    EINT8
+    //Binary :     11         11   ,  10      11  ,  10        10
+    //rGPGCON = 0xff95ffba;
+    gpioregs->GPGCON = 0xfd95ffba;	/* thisway.diy, GPG12-->OUTPUT, GPG9-->OUTPUT for FS2410, as USB Device enable */
+    gpioregs->GPGUP  = 0xffff;    // The pull up function is disabled GPG[15:0]
+	gpioregs->GPGDAT &= ~((1<<9) | (1<<12));	/* disable USB Device, enable later, thisway.diy */
+
+    //*** PORT H GROUP
+    //Ports  :  GPH10    GPH9  GPH8 GPH7  GPH6  GPH5 GPH4 GPH3 GPH2 GPH1  GPH0 
+    //Signal : CLKOUT1 CLKOUT0 UCLK nCTS1 nRTS1 RXD1 TXD1 RXD0 TXD0 nRTS0 nCTS0
+    //Binary :   10   ,  10     10 , 11    11  , 10   10 , 10   10 , 10    10
+    gpioregs->GPHCON = 0x2afaaa;
+    gpioregs->GPHUP  = 0x7ff;    // The pull up function is disabled GPH[10:0]
+
+	// Added for S3C2440X, DonGo
+	//*** PORT J GROUP
+    //Ports  : GPJ12   GPJ11       GPJ10    GPJ9    GPJ8      GPJ7      GPJ6      GPJ5      GPJ4      GPJ3      GPJ2      GPJ1     GPJ0 
+    //Signal : CAMRESET CAMPCLKOUT CAMHREF CAMVSYNC CAMPCLKIN CAMDAT[7] CAMDAT[6] CAMDAT[5] CAMDAT[4] CAMDAT[3] CAMDAT[2] CAMDAT[1] CAMDAT[0] 
+    //Binary :   10      10       10        10       10        10        10        10       10         10        10        10      10
+    gpioregs->GPJCON = 0x02aaaaaa;
+    gpioregs->GPJUP  = 0x1fff;    // The pull up function is disabled GPH[10:0]
+    
+    //External interrupt will be falling edge triggered. 
+    gpioregs->EXTINT0 = 0x22222222;    // EINT[7:0]
+    gpioregs->EXTINT1 = 0x22222222;    // EINT[15:8]
+    gpioregs->EXTINT2 = 0x22222222;    // EINT[23:16]
+}
+
+
+void usb_init(void)
+{
+	char *mode;
+	int i;
+	U8 key;
+	U32 mpll_val, upll_val, divn_upll=0;
+    extern int bBootFrmNORFlash(void);
+
+    clk_powerregs = S3C24X0_GetBase_CLOCK_POWER();
+
+    usbdevregs = S3C24X0_GetBase_USB_DEVICE();
+    dmaregs = S3C24X0_GetBase_DMAS();
+
+    udelay(100000);
+#if 0	
+	// USB device detection control
+	rGPGCON &= ~(3<<24);
+	rGPGCON |=  (1<<24); // output
+	rGPGUP  |=  (1<<12); // pullup disable
+	rGPGDAT |=  (1<<12); // output	
+#endif
+
+	//ChangeUPllValue(60,4,2);		// 48MHz
+	//for(i=0; i<7; i++);
+	//ChangeClockDivider(13,12);
+	//ChangeMPllValue(97,1,2);		//296Mhz
+
+	isUsbdSetConfiguration=0;
+
+	Isr_Init();
+
+	gpioregs->MISCCR=gpioregs->MISCCR&~(1<<3); // USBD is selected instead of USBH1 
+	gpioregs->MISCCR=gpioregs->MISCCR&~(1<<13); // USB port 1 is enabled.
+
+//
+//  USBD should be initialized first of all.
+//
+
+#if 0
+	UsbdMain(); 
+	MMU_Init(); //MMU should be reconfigured or turned off for the debugger, 
+	//After downloading, MMU should be turned off for the MMU based program,such as WinCE.	
+#else
+//thisway.diy    MMU_EnableICache();  
+	UsbdMain(); 
+    udelay(100000);
+    gpioregs->GPGDAT |= ((1<<9) | (1<<12));  /* enable USB Device, thisway.diy */
+    gpioregs->GPBDAT |= (1<<9);   /* enable USB Device, thisway.diy */
+    gpioregs->GPCDAT |= (1<<5);   /* enable USB Device, thisway.diy */
+#endif
+
+#if USBDMA
+	mode="DMA";
+#else
+	mode="Int";
+#endif
+
+	// CLKOUT0/1 select.
+	//printf("CLKOUT0:MPLL in, CLKOUT1:RTC clock.\n");
+	//Clk0_Enable(0);	// 0:MPLLin, 1:UPLL, 2:FCLK, 3:HCLK, 4:PCLK, 5:DCLK0
+	//Clk1_Enable(2);	// 0:MPLLout, 1:UPLL, 2:RTC, 3:HCLK, 4:PCLK, 5:DCLK1	
+//	Clk0_Disable();
+//	Clk1_Disable();
+	
+	mpll_val = clk_powerregs->MPLLCON;
+	upll_val = clk_powerregs->UPLLCON; 
+
+
+    if (1) //(!bBootFrmNORFlash())
+    {
+    	printf("UPLLVal [M:%xh,P:%xh,S:%xh]\n", (upll_val&(0xff<<12))>>12,(upll_val&(0x3f<<4))>>4,(upll_val&0x3));
+    	printf("MPLLVal [M:%xh,P:%xh,S:%xh]\n", (mpll_val&(0xff<<12))>>12,(mpll_val&(0x3f<<4))>>4,(mpll_val&0x3));
+    	printf("CLKDIVN:%xh\n", clk_powerregs->CLKDIVN);
+
+    	printf("\n\n");
+    	printf("+---------------------------------------------+\n");
+    	printf("| S3C2440A USB Downloader ver R0.03 2004 Jan  |\n");
+    	printf("+---------------------------------------------+\n");
+    //	printf("FCLK=%4.1fMHz,%s mode\n",FCLK/1000000.,mode); 
+    	printf("USB: IN_ENDPOINT:1 OUT_ENDPOINT:3\n"); 
+    	printf("FORMAT: <ADDR(DATA):4>+<SIZE(n+10):4>+<DATA:n>+<CS:2>\n");
+    	printf("NOTE: Power off/on or press the reset button for 1 sec\n");
+    	printf("      in order to get a valid USB device address.\n");
+    	printf("\n");
+    }
+	download_run=0; //The default menu is the Download & Run mode.
+
+//	WaitDownload();    
+
+}
+
+
+//void WaitDownload(void)
+__u32 usb_receive(char *buf, size_t len, U32 wait)
+{
+    int first=1;
+    U8 tempMem[16];
+    U32 j;
+    unsigned int dwRecvTimeSec = 0;
+	char c;
+
+    dwUSBBufReadPtr = dwUSBBufBase; // USB_BUF_BASE; thiswa.diy, 2006.06.21
+    dwUSBBufWritePtr = dwUSBBufBase; // USB_BUF_BASE; thiswa.diy, 2006.06.21
+    bDMAPending = 0;
+
+    /* add by thisway.diy */
+    tempDownloadAddress = dwUSBBufBase; // USB_BUF_BASE; thiswa.diy, 2006.06.21 // RAM_BASE, changed by thisway.diy for wince, 2006.06.18
+
+    downloadAddress=(U32)tempMem; //_RAM_STARTADDRESS; 
+    downPt=(unsigned char *)downloadAddress;
+	//This address is used for receiving first 8 byte.
+    downloadFileSize=0;
+    
+
+    /*******************************/
+    /*    File download    */
+    /*******************************/
+    if(isUsbdSetConfiguration==0)
+    {
+	    printf("USB host is not connected yet.\n");
+    }
+
+    while(downloadFileSize==0) /* wait until send a file */
+    {
+        if(first==1 && isUsbdSetConfiguration!=0)
+        {
+            printf("USB host is connected. Waiting a download.\n");
+            first=0;
+        }
+		c = awaitkey(1, 0);
+		if ((c & 0x7f) == INTR)
+		{
+			printf("Cancelled by user\n");
+			return 0;
+		}
+    }
+
+    /* add by thisway.diy */
+    if (downloadFileSize - 10 > len)
+    {
+        printf("Length of file is too big : %d > %d\n", downloadFileSize - 10, len);
+        return 0;
+    }
+    
+    Timer_InitEx();
+    Timer_StartEx();
+        
+#if USBDMA    
+
+    intregs->INTMSK&=~(BIT_DMA2);  
+
+    ClearEp3OutPktReady(); 
+    	// indicate the first packit is processed.
+    	// has been delayed for DMA2 cofiguration.
+
+    if(downloadFileSize>EP3_PKT_SIZE)
+    {
+        if(downloadFileSize - EP3_PKT_SIZE<=(0x80000))
+        {
+            /* set the source and length */
+            dwUSBBufWritePtr = downloadAddress + EP3_PKT_SIZE-8;
+            dwWillDMACnt = downloadFileSize - EP3_PKT_SIZE;
+	    }
+      	else
+      	{
+            dwUSBBufWritePtr = downloadAddress + EP3_PKT_SIZE - 8;
+            // dwWillDMACnt = 0x80000 - EP3_PKT_SIZE;
+            
+            /* Changed by thisway.diy, 2006.06.22
+             * We want When the first DMA interrupt happened, 
+             * it has received (0x80000 + 8) bytes data from PC
+             * The format of data PC send out is: <ADDR(DATA):4>+<SIZE(n+10):4>+<DATA:n>+<CS:2>
+             * So, the first 8 bytes isn't the real data we want
+             * We want the dwUSBBufWritePtr is always 0x80000 aligin
+             */
+            dwWillDMACnt = 0x80000 + 8 - EP3_PKT_SIZE;
+    	}
+     	totalDmaCount = 0;
+  	    ConfigEp3DmaMode(dwUSBBufWritePtr, dwWillDMACnt);
+    }
+    else
+    {
+        dwUSBBufWritePtr = downloadAddress + downloadFileSize - 8;
+	    totalDmaCount = downloadFileSize;
+    }
+#endif
+
+    printf("\nNow, Downloading [ADDRESS:%xh,TOTAL:%d]\n",
+    		downloadAddress,downloadFileSize);
+
+    if (wait)
+    {
+        printf("RECEIVED FILE SIZE:%8d",0);
+
+        j = totalDmaCount + 0x10000;
+        while (totalDmaCount != downloadFileSize)
+        {
+            if (totalDmaCount > j)
+            {
+        	    printf("\b\b\b\b\b\b\b\b%8d", j);
+                j = totalDmaCount + 0x10000;
+            }
+        }
+	    printf("\b\b\b\b\b\b\b\b%8d ", totalDmaCount);
+        dwRecvTimeSec = Timer_StopEx();
+        if (dwRecvTimeSec == 0)
+        {
+            dwRecvTimeSec = 1;
+        }
+        printf("(%dKB/S, %dS)\n", (downloadFileSize/dwRecvTimeSec/1024), dwRecvTimeSec);
+    }
+
+    return downloadFileSize - 10;
+
+}
+
+
+void HaltUndef(void)
+{
+	printf("Undefined instruction exception!!!\n");
+	while(1);
+}
+
+void HaltSwi(void)
+{
+	printf("SWI exception!!!\n");
+	while(1);
+}
+
+void HaltPabort(void)
+{
+	printf("Pabort exception!!!\n");
+	while(1);
+}
+
+void HaltDabort(void)
+{
+	printf("Dabort exception!!!\n");
+	while(1);
+}
+
+void Clk0_Enable(int clock_sel)	
+{	// 0:MPLLin, 1:UPLL, 2:FCLK, 3:HCLK, 4:PCLK, 5:DCLK0
+	gpioregs->MISCCR = gpioregs->MISCCR&~(7<<4) | (clock_sel<<4);
+	gpioregs->GPHCON = gpioregs->GPHCON&~(3<<18) | (2<<18);
+}
+void Clk1_Enable(int clock_sel)
+{	// 0:MPLLout, 1:UPLL, 2:RTC, 3:HCLK, 4:PCLK, 5:DCLK1	
+	gpioregs->MISCCR = gpioregs->MISCCR&~(7<<8) | (clock_sel<<8);
+	gpioregs->GPHCON = gpioregs->GPHCON&~(3<<20) | (2<<20);
+}
+void Clk0_Disable(void)
+{
+	gpioregs->GPHCON = gpioregs->GPHCON&~(3<<18);	// GPH9 Input
+}
+void Clk1_Disable(void)
+{
+	gpioregs->GPHCON = gpioregs->GPHCON&~(3<<20);	// GPH10 Input
+}
+
diff -urN u-boot-1.1.6/drivers/usb/usbinit.h u-boot-1.1.6_fdt/drivers/usb/usbinit.h
--- u-boot-1.1.6/drivers/usb/usbinit.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usbinit.h	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,20 @@
+/****************************************************************
+ NAME: u2440mon.h
+ DESC: 
+ HISTORY:
+ Mar.29.2002:purnnamu: created first
+ ****************************************************************/
+ 
+#ifndef __U241MON_H__
+#define __U241MON_H__
+
+extern volatile unsigned char *downPt;
+extern volatile U32 totalDmaCount;
+extern volatile U32 downloadFileSize;
+extern volatile U32 downloadAddress;
+extern volatile U16 checkSum;
+
+extern int download_run;
+extern U32 tempDownloadAddress;
+
+#endif /*__U241MON_H__*/
diff -urN u-boot-1.1.6/drivers/usb/usblib.c u-boot-1.1.6_fdt/drivers/usb/usblib.c
--- u-boot-1.1.6/drivers/usb/usblib.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usblib.c	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,241 @@
+/****************************************************************
+ NAME: usblib.c
+ DESC: S3C2440X USB library functions
+ HISTORY:
+ Mar.25.2002:purnnamu: ported for S3C2410X.
+ Mar.27.2002:purnnamu: DMA is enabled.
+ ****************************************************************/
+#include <common.h>
+#if defined(CONFIG_S3C2400)
+#include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+#endif
+
+#include "2440usb.h"
+#include "usbmain.h"
+#include "usblib.h"
+#include "usbsetup.h"
+#include "usbmain.h"
+
+extern volatile U32 dwUSBBufReadPtr;
+extern volatile U32 dwUSBBufWritePtr;
+extern volatile U32 dwPreDMACnt;
+extern volatile U32 dwNextDMACnt;
+
+extern S3C24X0_INTERRUPT * intregs;
+extern S3C24X0_USB_DEVICE * usbdevregs;
+extern S3C24X0_DMAS * dmaregs;
+
+void ConfigUsbd(void)
+{
+
+    ReconfigUsbd();
+/*
+    pISR_USBD =(unsigned)IsrUsbd;
+    ClearPending(BIT_USBD);
+    rINTMSK&=~(BIT_USBD);  
+*/   
+    intregs->INTMSK&=~(BIT_USBD);  
+}
+
+
+void ReconfigUsbd(void)
+{
+// *** End point information ***
+//   EP0: control
+//   EP1: bulk in end point
+//   EP2: not used
+//   EP3: bulk out end point
+//   EP4: not used
+    
+    usbdevregs->PWR_REG=PWR_REG_DEFAULT_VALUE;	//disable suspend mode
+
+    usbdevregs->INDEX_REG=0;	
+    usbdevregs->MAXP_REG=FIFO_SIZE_8;   	//EP0 max packit size = 8 
+    usbdevregs->EP0_CSR_IN_CSR1_REG=EP0_SERVICED_OUT_PKT_RDY|EP0_SERVICED_SETUP_END;	
+ 				//EP0:clear OUT_PKT_RDY & SETUP_END
+    usbdevregs->INDEX_REG=1;
+    #if (EP1_PKT_SIZE==32)
+        usbdevregs->MAXP_REG=FIFO_SIZE_32;	//EP1:max packit size = 32
+    #else
+	usbdevregs->MAXP_REG=FIFO_SIZE_64;	//EP1:max packit size = 64
+    #endif	
+    usbdevregs->EP0_CSR_IN_CSR1_REG=EPI_FIFO_FLUSH|EPI_CDT;	
+    usbdevregs->IN_CSR2_REG=EPI_MODE_IN|EPI_IN_DMA_INT_MASK|EPI_BULK; //IN mode, IN_DMA_INT=masked    
+    usbdevregs->OUT_CSR1_REG=EPO_CDT;   	
+    usbdevregs->OUT_CSR2_REG=EPO_BULK|EPO_OUT_DMA_INT_MASK;   	
+
+    usbdevregs->INDEX_REG=2;
+    usbdevregs->MAXP_REG=FIFO_SIZE_64;	//EP2:max packit size = 64
+    usbdevregs->EP0_CSR_IN_CSR1_REG=EPI_FIFO_FLUSH|EPI_CDT|EPI_BULK;
+    usbdevregs->IN_CSR2_REG=EPI_MODE_IN|EPI_IN_DMA_INT_MASK; //IN mode, IN_DMA_INT=masked    
+    usbdevregs->OUT_CSR1_REG=EPO_CDT;   	
+    usbdevregs->OUT_CSR2_REG=EPO_BULK|EPO_OUT_DMA_INT_MASK;   	
+
+    usbdevregs->INDEX_REG=3;
+    #if (EP3_PKT_SIZE==32)
+        usbdevregs->MAXP_REG=FIFO_SIZE_32;	//EP3:max packit size = 32
+    #else
+	usbdevregs->MAXP_REG=FIFO_SIZE_64;	//EP3:max packit size = 64
+    #endif	
+    usbdevregs->EP0_CSR_IN_CSR1_REG=EPI_FIFO_FLUSH|EPI_CDT|EPI_BULK;
+    usbdevregs->IN_CSR2_REG=EPI_MODE_OUT|EPI_IN_DMA_INT_MASK; //OUT mode, IN_DMA_INT=masked    
+    usbdevregs->OUT_CSR1_REG=EPO_CDT;   	
+    	//clear OUT_PKT_RDY, data_toggle_bit.
+	//The data toggle bit should be cleared when initialization.
+    usbdevregs->OUT_CSR2_REG=EPO_BULK|EPO_OUT_DMA_INT_MASK;   	
+
+    usbdevregs->INDEX_REG=4;
+    usbdevregs->MAXP_REG=FIFO_SIZE_64;	//EP4:max packit size = 64
+    usbdevregs->EP0_CSR_IN_CSR1_REG=EPI_FIFO_FLUSH|EPI_CDT|EPI_BULK;
+    usbdevregs->IN_CSR2_REG=EPI_MODE_OUT|EPI_IN_DMA_INT_MASK; //OUT mode, IN_DMA_INT=masked    
+    usbdevregs->OUT_CSR1_REG=EPO_CDT;   	
+    	//clear OUT_PKT_RDY, data_toggle_bit.
+	//The data toggle bit should be cleared when initialization.
+    usbdevregs->OUT_CSR2_REG=EPO_BULK|EPO_OUT_DMA_INT_MASK;   	
+    
+    usbdevregs->EP_INT_REG=EP0_INT|EP1_INT|EP2_INT|EP3_INT|EP4_INT;
+    usbdevregs->USB_INT_REG=RESET_INT|SUSPEND_INT|RESUME_INT; 
+    	//Clear all usbd pending bits
+    	
+    //EP0,1,3 & reset interrupt are enabled
+    usbdevregs->EP_INT_EN_REG=EP0_INT|EP1_INT|EP3_INT;
+    usbdevregs->USB_INT_EN_REG=RESET_INT;
+    ep0State=EP0_STATE_INIT;
+    
+}
+
+
+void RdPktEp0(U8 *buf,int num)
+{
+    int i;
+    	
+    for(i=0;i<num;i++)
+    {
+        buf[i]=(U8)usbdevregs->fifo[0].EP_FIFO_REG;
+    }
+}
+    
+
+void WrPktEp0(U8 *buf,int num)
+{
+    int i;
+    	
+    for(i=0;i<num;i++)
+    {
+        usbdevregs->fifo[0].EP_FIFO_REG=buf[i];	
+    }
+}
+
+
+void WrPktEp1(U8 *buf,int num)
+{
+    int i;
+    	
+    for(i=0;i<num;i++)
+    {
+        usbdevregs->fifo[1].EP_FIFO_REG=buf[i];	
+    }
+}
+
+
+void WrPktEp2(U8 *buf,int num)
+{
+    int i;
+    	
+    for(i=0;i<num;i++)
+    {
+        usbdevregs->fifo[2].EP_FIFO_REG=buf[i];	
+    }
+}
+
+
+void RdPktEp3(U8 *buf,int num)
+{
+    int i;
+    	
+    for(i=0;i<num;i++)
+    {
+        buf[i]=(U8)usbdevregs->fifo[3].EP_FIFO_REG;	
+    }
+}
+
+
+void RdPktEp4(U8 *buf,int num)
+{
+    int i;
+    	
+    for(i=0;i<num;i++)
+    {
+        buf[i]=(U8)usbdevregs->fifo[4].EP_FIFO_REG;	
+    }
+}
+
+
+void ConfigEp3DmaMode(U32 bufAddr,U32 count)
+{
+    int i;
+
+    usbdevregs->INDEX_REG=3;
+    count=count&0xfffff; //transfer size should be <1MB
+    
+    dmaregs->dma[2].DISRCC=(1<<1)|(1<<0);
+    dmaregs->dma[2].DISRC=ADDR_EP3_FIFO; //src=APB,fixed,src=EP3_FIFO
+    dmaregs->dma[2].DIDSTC=(0<<1)|(0<<0);  
+    dmaregs->dma[2].DIDST=bufAddr;       //dst=AHB,increase,dst=bufAddr
+#if USBDMA_DEMAND
+    dmaregs->dma[2].DCON=(count)|(0<<31)|(0<<30)|(1<<29)|(0<<28)|(0<<27)|(4<<24)|(1<<23)|(0<<22)|(0<<20); 
+        //demand,requestor=APB,CURR_TC int enable,unit transfer,
+        //single service,src=USBD,H/W request,autoreload,byte,CURR_TC
+#else
+//    rDCON2=(count)|(1<<31)|(0<<30)|(1<<29)|(0<<28)|(0<<27)|(4<<24)|(1<<23)|(0<<22)|(0<<20); 
+    /* changed by thisway.diy to disable autoreload */
+    dmaregs->dma[2].DCON=(count)|(1<<31)|(0<<30)|(1<<29)|(0<<28)|(0<<27)|(4<<24)|(1<<23)|(1<<22)|(0<<20); 
+        //handshake,requestor=APB,CURR_TC int enable,unit transfer,
+        //single service,src=USBD,H/W request,autoreload,byte,CURR_TC
+#endif        
+    dmaregs->dma[2].DMASKTRIG= (1<<1); 
+        //DMA 2 on
+
+    //rEP3_DMA_FIFO=0x40; //not needed for OUT operation. 	
+
+    usbdevregs->ep3.EP_DMA_TTC_L=0xff;
+    usbdevregs->ep3.EP_DMA_TTC_M=0xff;
+    usbdevregs->ep3.EP_DMA_TTC_H=0x0f;
+
+    usbdevregs->OUT_CSR2_REG=usbdevregs->OUT_CSR2_REG|EPO_AUTO_CLR|EPO_OUT_DMA_INT_MASK; 
+    	//AUTO_CLR(OUT_PKT_READY is cleared automatically), interrupt_masking.
+#if USBDMA_DEMAND
+    usbdevregs->ep3.EP_DMA_UNIT=EP3_PKT_SIZE; //DMA transfer unit=64 bytes
+    usbdevregs->ep3.EP_DMA_CON=UDMA_DEMAND_MODE|UDMA_OUT_DMA_RUN|UDMA_DMA_MODE_EN; 
+        // deamnd enable,out_dma_run=run,in_dma_run=stop,DMA mode enable
+#else        
+    usbdevregs->ep3.EP_DMA_UNIT=0x01; //DMA transfer unit=1byte
+    usbdevregs->ep3.EP_DMA_CON=UDMA_OUT_DMA_RUN|UDMA_DMA_MODE_EN;
+        // deamnd disable,out_dma_run=run,in_dma_run=stop,DMA mode enable
+#endif  
+    //wait until DMA_CON is effective.
+    usbdevregs->ep3.EP_DMA_CON;
+    for(i=0;i<10;i++);    	
+
+    /* add by thisway.diy for non-autoreload */
+    dmaregs->dma[3].DMASKTRIG = (1<<1);
+}
+
+
+void ConfigEp3IntMode(void)
+{
+    usbdevregs->INDEX_REG=3;
+    
+    dmaregs->dma[2].DMASKTRIG= (0<<1);  // EP3=DMA ch 2
+        //DMA channel off
+    usbdevregs->OUT_CSR2_REG=usbdevregs->OUT_CSR2_REG&~(EPO_AUTO_CLR/*|EPO_OUT_DMA_INT_MASK*/); 
+    	//AUTOCLEAR off,interrupt_enabled (???)
+    usbdevregs->ep3.EP_DMA_UNIT=1;	
+    usbdevregs->ep3.EP_DMA_CON=0; 
+    	// deamnd disable,out_dma_run=stop,in_dma_run=stop,DMA mode disable
+    //wait until DMA_CON is effective.
+    usbdevregs->ep3.EP_DMA_CON;
+    
+}
diff -urN u-boot-1.1.6/drivers/usb/usblib.h u-boot-1.1.6_fdt/drivers/usb/usblib.h
--- u-boot-1.1.6/drivers/usb/usblib.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usblib.h	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,29 @@
+/****************************************************************
+ NAME: usblib.h
+ DESC: 
+ HISTORY:
+ Mar.25.2002:purnnamu: ported for S3C2410X.
+ ****************************************************************/
+#ifndef __USBLIB_H__
+#define __USBLIB_H__
+
+#include "2440usb.h"
+#include <def.h>
+
+#define PWR_REG_DEFAULT_VALUE (DISABLE_SUSPEND)
+
+void ConfigUsbd(void);
+void ReconfigUsbd(void);
+
+void RdPktEp0(U8 *buf,int num);
+void WrPktEp0(U8 *buf,int num);
+void WrPktEp1(U8 *buf,int num);
+void WrPktEp2(U8 *buf,int num);
+void RdPktEp3(U8 *buf,int num);
+void RdPktEp4(U8 *buf,int num);
+
+void ConfigEp3IntMode(void);
+void ConfigEp3DmaMode(U32 bufAddr,U32 count);
+
+#endif /*__USBLIB_H__*/
+
diff -urN u-boot-1.1.6/drivers/usb/usbmain.c u-boot-1.1.6_fdt/drivers/usb/usbmain.c
--- u-boot-1.1.6/drivers/usb/usbmain.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usbmain.c	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,169 @@
+/****************************************************************
+ NAME: usbmain.c
+ DESC: endpoint interrupt handler
+       USB init jobs
+ HISTORY:
+ Mar.25.2002:purnnamu: ported for S3C2410X.
+ Mar.27.2002:purnnamu: DMA is enabled.
+ ****************************************************************/
+#include <common.h>
+#if defined(CONFIG_S3C2400)
+#include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+#endif
+
+#include "2440usb.h"
+#include "usbmain.h"
+#include "usblib.h"
+#include "usbsetup.h"
+#include "usbout.h"
+#include "usbin.h"
+
+extern S3C24X0_USB_DEVICE * usbdevregs;
+extern S3C24X0_DMAS * dmaregs;
+    
+/**************************
+    Some PrepareEp1Fifo() should be deleted
+ **************************/   
+
+void UsbdMain(void)
+{
+    int i;
+    U8 tmp1;
+    U8 oldTmp1=0xff;
+    
+    //ChangeUPllValue(0x38,2,1);	// UCLK=96Mhz     
+    //ChangeUPllValue(0x38,2,2);	// UCLK=48Mhz     
+    InitDescriptorTable();
+    //ResetUsbd();
+    
+    ConfigUsbd(); 
+
+    //DetectVbus(); //not used in S3C2400X
+
+    PrepareEp1Fifo(); 
+#if 0    
+    while(1)
+    {
+    	if(DbgPrintfLoop())continue;
+    	
+    	Delay(5000);
+    	if((i++%2)==0)Led_Display(0x8);
+    	else Led_Display(0x0);
+    }
+#endif    
+}
+
+
+void IsrUsbd(void)
+{
+    U8 usbdIntpnd,epIntpnd;
+    U8 saveIndexReg=usbdevregs->INDEX_REG;
+    usbdIntpnd=usbdevregs->USB_INT_REG;
+    epIntpnd=usbdevregs->EP_INT_REG;
+    //DbgPrintf( "[INT:EP_I=%x,USBI=%x]",epIntpnd,usbIntpnd );
+
+    if(usbdIntpnd&SUSPEND_INT)
+    {
+    	usbdevregs->USB_INT_REG=SUSPEND_INT;
+    	DbgPrintf( "<SUS]");
+    }
+    if(usbdIntpnd&RESUME_INT)
+    {
+    	usbdevregs->USB_INT_REG=RESUME_INT;
+    	DbgPrintf("<RSM]");
+    }
+    if(usbdIntpnd&RESET_INT)
+    {
+    	DbgPrintf( "<RST]");  
+    	
+    	//ResetUsbd();
+    	ReconfigUsbd();
+
+    	usbdevregs->USB_INT_REG=RESET_INT;  //RESET_INT should be cleared after ResetUsbd().   	
+
+        PrepareEp1Fifo(); 
+    }
+
+    if(epIntpnd&EP0_INT)
+    {
+	    usbdevregs->EP_INT_REG=EP0_INT;  
+    	Ep0Handler();
+    }
+    if(epIntpnd&EP1_INT)
+    {
+    	usbdevregs->EP_INT_REG=EP1_INT;  
+    	Ep1Handler();
+    }
+
+    if(epIntpnd&EP2_INT)
+    {
+    	usbdevregs->EP_INT_REG=EP2_INT;  
+    	DbgPrintf("<2:TBD]");   //not implemented yet	
+    	//Ep2Handler();
+    }
+
+    if(epIntpnd&EP3_INT)
+    {
+    	usbdevregs->EP_INT_REG=EP3_INT;
+    	Ep3Handler();
+    }
+
+    if(epIntpnd&EP4_INT)
+    {
+    	usbdevregs->EP_INT_REG=EP4_INT;
+    	DbgPrintf("<4:TBD]");   //not implemented yet	
+    	//Ep4Handler();
+    }
+
+    ClearPending(BIT_USBD);	 
+    
+    usbdevregs->INDEX_REG=saveIndexReg;
+}
+
+
+
+
+/******************* Consol printf for debug *********************/
+
+#define DBGSTR_LENGTH (0x1000)
+U8 dbgStrFifo[DBGSTR_LENGTH];
+volatile U32 dbgStrRdPt=0;
+volatile U32 dbgStrWrPt=0;
+
+
+
+void _WrDbgStrFifo(U8 c)
+{
+    dbgStrFifo[dbgStrWrPt++]=c;
+    if(dbgStrWrPt==DBGSTR_LENGTH)dbgStrWrPt=0;
+
+}
+
+
+#if 0
+void DbgPrintf(char *fmt,...)
+{
+    int i,slen;
+    va_list ap;
+    char string[256];
+
+    va_start(ap,fmt);
+    vsprintf(string,fmt,ap);
+    
+//    slen=strlen(string);
+    
+//    for(i=0;i<slen;i++)
+//    	_WrDbgStrFifo(string[i]);
+    
+    va_end(ap);
+    puts(string);
+}
+#else
+void DbgPrintf(char *fmt,...)
+{
+}
+#endif
+
+
diff -urN u-boot-1.1.6/drivers/usb/usbmain.h u-boot-1.1.6_fdt/drivers/usb/usbmain.h
--- u-boot-1.1.6/drivers/usb/usbmain.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usbmain.h	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,17 @@
+/****************************************************************
+ NAME: usbmain.h
+ DESC: 
+ HISTORY:
+ Mar.25.2002:purnnamu: reuse the source of S3C2400X u24xmon 
+ ****************************************************************/
+ 
+#ifndef __USBMAIN_H__
+#define __USBMAIN_H__
+
+void UsbdMain(void);
+void IsrUsbd(void);
+
+void DbgPrintf(char *fmt,...);
+
+
+#endif /*__USBMAIN_H__*/
diff -urN u-boot-1.1.6/drivers/usb/usbout.c u-boot-1.1.6_fdt/drivers/usb/usbout.c
--- u-boot-1.1.6/drivers/usb/usbout.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usbout.c	2018-10-22 15:53:21.553641225 +0800
@@ -0,0 +1,246 @@
+/****************************************************************
+ NAME: usbout.c
+ DESC: USB bulk-OUT operation related functions
+ HISTORY:
+ Mar.25.2002:purnnamu: ported for S3C2410X.
+ Mar.27.2002:purnnamu: DMA is enabled.
+ ****************************************************************/
+#include <common.h>
+#if defined(CONFIG_S3C2400)
+#include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+#endif
+
+#include <def.h>
+ 
+#include "2440usb.h"
+#include "usbmain.h"
+#include "usb.h"
+#include "usblib.h"
+#include "usbsetup.h"
+#include "usbout.h"
+
+#include "usbinit.h"
+
+extern volatile U32 dwUSBBufReadPtr;
+extern volatile U32 dwUSBBufWritePtr;
+extern volatile U32 dwWillDMACnt;
+extern volatile U32 bDMAPending;
+extern volatile U32 dwUSBBufBase;
+extern volatile U32 dwUSBBufSize;
+
+extern S3C24X0_INTERRUPT * intregs;
+extern S3C24X0_USB_DEVICE * usbdevregs;
+extern S3C24X0_DMAS * dmaregs;
+
+static void PrintEpoPkt(U8 *pt,int cnt);
+static void RdPktEp3_CheckSum(U8 *buf,int num);
+
+
+
+// ===================================================================
+// All following commands will operate in case 
+// - out_csr3 is valid.
+// ===================================================================
+
+ 
+
+#define CLR_EP3_OUT_PKT_READY() usbdevregs->OUT_CSR1_REG= ( out_csr3 &(~ EPO_WR_BITS)\
+					&(~EPO_OUT_PKT_READY) ) 
+#define SET_EP3_SEND_STALL()	usbdevregs->OUT_CSR1_REG= ( out_csr3 & (~EPO_WR_BITS)\
+					| EPO_SEND_STALL) )
+#define CLR_EP3_SENT_STALL()	usbdevregs->OUT_CSR1_REG= ( out_csr3 & (~EPO_WR_BITS)\
+					&(~EPO_SENT_STALL) )
+#define FLUSH_EP3_FIFO() 	usbdevregs->OUT_CSR1_REG= ( out_csr3 & (~EPO_WR_BITS)\
+					|EPO_FIFO_FLUSH) )
+
+// ***************************
+// *** VERY IMPORTANT NOTE ***
+// ***************************
+// Prepare for the packit size constraint!!!
+
+// EP3 = OUT end point. 
+
+U8 ep3Buf[EP3_PKT_SIZE];
+static U8 tempBuf[64+1];
+
+void Ep3Handler(void)
+{
+    U8 out_csr3;
+    int fifoCnt;
+    usbdevregs->INDEX_REG=3;
+
+    out_csr3=usbdevregs->OUT_CSR1_REG;
+    
+    DbgPrintf("<3:%x]",out_csr3);
+
+    if(out_csr3 & EPO_OUT_PKT_READY)
+    {   
+	fifoCnt=usbdevregs->OUT_FIFO_CNT1_REG; 
+#if 0
+	RdPktEp3(ep3Buf,fifoCnt);
+	PrintEpoPkt(ep3Buf,fifoCnt);
+#else
+
+	if(downloadFileSize==0)
+	{
+   	    RdPktEp3((U8 *)downPt,8); 	
+   	    
+   	    if(download_run==0)
+   	    {
+		    downloadAddress=tempDownloadAddress;
+	    }
+	    else
+	    {
+	    	downloadAddress=
+	    		*((U8 *)(downPt+0))+
+			(*((U8 *)(downPt+1))<<8)+
+			(*((U8 *)(downPt+2))<<16)+
+			(*((U8 *)(downPt+3))<<24);
+            
+            dwUSBBufReadPtr = downloadAddress;
+            dwUSBBufWritePtr = downloadAddress;
+	    }
+	    downloadFileSize=
+	    	*((U8 *)(downPt+4))+
+		(*((U8 *)(downPt+5))<<8)+
+		(*((U8 *)(downPt+6))<<16)+
+		(*((U8 *)(downPt+7))<<24);
+	    checkSum=0;
+	    downPt=(U8 *)downloadAddress;
+
+  	    RdPktEp3_CheckSum((U8 *)downPt,fifoCnt-8); //The first 8-bytes are deleted.	    
+  	    downPt+=fifoCnt-8;  
+  	    
+  	#if USBDMA
+     	    //CLR_EP3_OUT_PKT_READY() is not executed. 
+     	    //So, USBD may generate NAK until DMA2 is configured for USB_EP3;
+     	    intregs->INTMSK|=BIT_USBD; //for debug
+      	    return;	
+  	#endif	
+	}
+	else
+	{
+	#if USBDMA    	
+	    printf("<ERROR>");
+	#endif    
+	    RdPktEp3_CheckSum((U8 *)downPt,fifoCnt); 	    
+	    downPt+=fifoCnt;  //fifoCnt=64
+	}
+#endif
+   	CLR_EP3_OUT_PKT_READY();
+#if 0
+       if(((rOUT_CSR1_REG&0x1)==1) && ((rEP_INT_REG & 0x8)==0))
+  		{
+  		fifoCnt=rOUT_FIFO_CNT1_REG; 
+		RdPktEp3_CheckSum((U8 *)downPt,fifoCnt); 	    
+	       downPt+=fifoCnt;  //fifoCnt=64
+	       CLR_EP3_OUT_PKT_READY();
+		}
+#endif
+  	return;
+    }
+
+    
+    //I think that EPO_SENT_STALL will not be set to 1.
+    if(out_csr3 & EPO_SENT_STALL)
+    {   
+   	DbgPrintf("[STALL]");
+   	CLR_EP3_SENT_STALL();
+   	return;
+    }	
+}
+
+
+
+void PrintEpoPkt(U8 *pt,int cnt)
+{
+    int i;
+    DbgPrintf("[BOUT:%d:",cnt);
+    for(i=0;i<cnt;i++)
+    	DbgPrintf("%x,",pt[i]);
+    DbgPrintf("]");
+}
+
+
+void RdPktEp3_CheckSum(U8 *buf,int num)
+{
+    int i;
+    	
+    for(i=0;i<num;i++)
+    {
+        buf[i]=(U8)usbdevregs->fifo[3].EP_FIFO_REG;
+        checkSum+=buf[i];
+    }
+}
+
+
+
+void IsrDma2(void)
+{
+    U8 out_csr3;
+    U32 dwEmptyCnt;
+    U8 saveIndexReg=usbdevregs->INDEX_REG;
+    usbdevregs->INDEX_REG=3;
+    out_csr3=usbdevregs->OUT_CSR1_REG;
+
+    ClearPending(BIT_DMA2);	    
+
+    /* thisway.diy, 2006.06.22 
+     * When the first DMA interrupt happened, it has received max (0x80000 + EP3_PKT_SIZE) bytes data from PC
+     */
+    if (!totalDmaCount) 
+        totalDmaCount = dwWillDMACnt + EP3_PKT_SIZE;
+    else
+        totalDmaCount+=dwWillDMACnt;
+
+//    dwUSBBufWritePtr = ((dwUSBBufWritePtr + dwWillDMACnt - USB_BUF_BASE) % USB_BUF_SIZE) + USB_BUF_BASE; /* thisway.diy, 2006.06.21 */
+    dwUSBBufWritePtr = ((dwUSBBufWritePtr + dwWillDMACnt - dwUSBBufBase) % dwUSBBufSize) + dwUSBBufBase;
+
+    if(totalDmaCount>=downloadFileSize)// is last?
+    {
+    	totalDmaCount=downloadFileSize;
+	
+    	ConfigEp3IntMode();	
+
+    	if(out_csr3& EPO_OUT_PKT_READY)
+    	{
+       	    CLR_EP3_OUT_PKT_READY();
+	    }
+        intregs->INTMSK|=BIT_DMA2;  
+        intregs->INTMSK&=~(BIT_USBD);  
+    }
+    else
+    {
+    	if((totalDmaCount+0x80000)<downloadFileSize)	
+    	{
+    	    dwWillDMACnt = 0x80000;
+	    }
+    	else
+    	{
+    	    dwWillDMACnt = downloadFileSize - totalDmaCount;
+    	}
+
+        // dwEmptyCnt = (dwUSBBufReadPtr - dwUSBBufWritePtr - 1 + USB_BUF_SIZE) % USB_BUF_SIZE; /* thisway.diy, 2006.06.21 */
+        dwEmptyCnt = (dwUSBBufReadPtr - dwUSBBufWritePtr - 1 + dwUSBBufSize) % dwUSBBufSize;
+        if (dwEmptyCnt >= dwWillDMACnt)
+        {
+    	    ConfigEp3DmaMode(dwUSBBufWritePtr, dwWillDMACnt);
+        }
+        else
+        {
+            bDMAPending = 1;
+        }
+    }
+    usbdevregs->INDEX_REG = saveIndexReg;
+}
+
+
+void ClearEp3OutPktReady(void)
+{
+    U8 out_csr3;
+    usbdevregs->INDEX_REG=3;
+    out_csr3=usbdevregs->OUT_CSR1_REG;
+    CLR_EP3_OUT_PKT_READY();
+}
diff -urN u-boot-1.1.6/drivers/usb/usbout.h u-boot-1.1.6_fdt/drivers/usb/usbout.h
--- u-boot-1.1.6/drivers/usb/usbout.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usbout.h	2018-10-22 15:53:21.557641225 +0800
@@ -0,0 +1,17 @@
+/****************************************************************
+ NAME: usbout.h
+ DESC: 
+ HISTORY:
+ Mar.25.2002:purnnamu: reuse the source of S3C2400X u24xmon 
+ ****************************************************************/
+ 
+#ifndef __USBOUT_H__
+#define __USBOUT_H__
+
+void Ep3Handler(void);
+void Ep3HandlerOptimized(void);
+
+void IsrDma2(void);
+void ClearEp3OutPktReady(void);
+
+#endif /*__USBOUT_H__*/
diff -urN u-boot-1.1.6/drivers/usb/usbsetup.c u-boot-1.1.6_fdt/drivers/usb/usbsetup.c
--- u-boot-1.1.6/drivers/usb/usbsetup.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usbsetup.c	2018-10-22 15:53:21.557641225 +0800
@@ -0,0 +1,692 @@
+/**************************************************************
+ NAME: usbsetup.c
+ DESC: process the USB setup stage operations.
+ HISTORY:
+ MAR.25.2002:purnnamu: S3C2400X usbsetup.c is ported for S3C2410X.
+ AUG.20.2002:purnnamu: rEP0_CSR should be used instead of rOUT_CSR1_REG for EP0 macros.
+ **************************************************************/
+#include <common.h>
+#if defined(CONFIG_S3C2400)
+#include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+#endif
+
+#include <def.h>
+
+#include "2440usb.h"
+#include "usbmain.h"
+#include "usb.h"
+#include "usblib.h"
+#include "usbsetup.h"
+
+extern S3C24X0_INTERRUPT * intregs;
+extern S3C24X0_USB_DEVICE * usbdevregs;
+extern S3C24X0_DMAS * dmaregs;
+
+// *** End point information ***
+//   EP0: control
+//   EP1: bulk in end point
+//   EP2: not used
+//   EP3: bulk out end point
+//   EP4: not used
+
+// *** VERY IMPORTANT NOTE ***
+// Every descriptor size of EP0 should be 8n+m(m=1~7).
+// Otherwise, USB will not operate normally because the program
+// doesn't prepare the case that the descriptor size is 8n+0.
+// If the size of a descriptor is 8n, the 0 length packit should be sent. 
+// Special thanks to E.S.Choi for reminding me of this USB specification.
+
+
+// ===================================================================
+// All following commands will operate only in case 
+// - ep0_csr is valid.
+// ===================================================================
+#define CLR_EP0_OUT_PKT_RDY() 		usbdevregs->EP0_CSR_IN_CSR1_REG=( ep0_csr & (~EP0_WR_BITS)| \
+						EP0_SERVICED_OUT_PKT_RDY )	 
+#define CLR_EP0_OUTPKTRDY_DATAEND() 	usbdevregs->EP0_CSR_IN_CSR1_REG=( ep0_csr & (~EP0_WR_BITS)| \
+						(EP0_SERVICED_OUT_PKT_RDY|EP0_DATA_END) )	 
+					
+#define SET_EP0_IN_PKT_RDY() 		usbdevregs->EP0_CSR_IN_CSR1_REG=( ep0_csr & (~EP0_WR_BITS)| \
+						(EP0_IN_PKT_READY) )	 
+#define SET_EP0_INPKTRDY_DATAEND() 	usbdevregs->EP0_CSR_IN_CSR1_REG=( ep0_csr & (~EP0_WR_BITS)| \
+						(EP0_IN_PKT_READY|EP0_DATA_END) )	 
+					
+#define CLR_EP0_SETUP_END() 		usbdevregs->EP0_CSR_IN_CSR1_REG=( ep0_csr & (~EP0_WR_BITS)| \
+						(EP0_SERVICED_SETUP_END) )
+
+#define CLR_EP0_SENT_STALL() 		usbdevregs->EP0_CSR_IN_CSR1_REG=( ep0_csr & (~EP0_WR_BITS)& \
+						(~EP0_SENT_STALL) )
+
+#define FLUSH_EP0_FIFO() 		{while(usbdevregs->OUT_FIFO_CNT1_REG)usbdevregs->fifo[0].EP_FIFO_REG;}
+
+U32 ep0State;
+U32 ep0SubState;
+
+extern volatile int isUsbdSetConfiguration;
+volatile U8 Rwuen;
+volatile U8 Configuration=1;
+volatile U8 AlterSetting;
+volatile U8 Selfpwr=TRUE;
+volatile U8 device_status;
+volatile U8 interface_status;
+volatile U8 endpoint0_status;
+volatile U8 endpoint1_status;
+volatile U8 endpoint3_status;
+
+struct USB_SETUP_DATA descSetup;
+struct USB_DEVICE_DESCRIPTOR descDev;
+struct USB_CONFIGURATION_DESCRIPTOR descConf;
+struct USB_INTERFACE_DESCRIPTOR descIf;
+struct USB_ENDPOINT_DESCRIPTOR descEndpt0;
+struct USB_ENDPOINT_DESCRIPTOR descEndpt1;
+struct USB_CONFIGURATION_SET ConfigSet;
+struct USB_INTERFACE_GET InterfaceGet;
+struct USB_GET_STATUS StatusGet;   //={0,0,0,0,0};
+
+
+static const U8 descStr0[]={
+	4,STRING_TYPE,LANGID_US_L,LANGID_US_H,  //codes representing languages
+    };
+
+static const U8 descStr1[]={  //Manufacturer  
+        (0x14+2),STRING_TYPE, 
+        'S',0x0,'y',0x0,'s',0x0,'t',0x0,'e',0x0,'m',0x0,' ',0x0,'M',0x0,
+        'C',0x0,'U',0x0,
+    };
+    
+static const U8 descStr2[]={  //Product  
+        (0x2a+2),STRING_TYPE, 
+        'S',0x0,'E',0x0,'C',0x0,' ',0x0,'S',0x0,'3',0x0,'C',0x0,'2',0x0,
+        '4',0x0,'1',0x0,'0',0x0,'X',0x0,' ',0x0,'T',0x0,'e',0x0,'s',0x0,
+        't',0x0,' ',0x0,'B',0x0,'/',0x0,'D',0x0
+    };
+
+
+void Ep0Handler(void)
+{
+    static int ep0SubState;
+    int i;
+    U8 ep0_csr;
+
+    usbdevregs->INDEX_REG=0;
+    ep0_csr=usbdevregs->EP0_CSR_IN_CSR1_REG;
+    
+    DbgPrintf("<0:%x]",ep0_csr);
+
+    //DATAEND interrupt(ep0_csr==0x0) will be ignored 
+    //because ep0State==EP0_STATE_INIT when the DATAEND interrupt is issued.
+
+    
+    if(ep0_csr & EP0_SETUP_END)
+    {   
+    	 // Host may end GET_DESCRIPTOR operation without completing the IN data stage.
+    	 // If host does that, SETUP_END bit will be set.
+    	 // OUT_PKT_RDY has to be also cleared because status stage sets OUT_PKT_RDY to 1.
+   	DbgPrintf("[SETUPEND]");
+	CLR_EP0_SETUP_END();
+	if(ep0_csr & EP0_OUT_PKT_READY) 
+	{
+	    FLUSH_EP0_FIFO(); //(???)
+	    	//I think this isn't needed because EP0 flush is done automatically.   
+	    CLR_EP0_OUT_PKT_RDY();
+	}
+	
+	ep0State=EP0_STATE_INIT;
+	return;
+    }	
+
+    //I think that EP0_SENT_STALL will not be set to 1.
+    if(ep0_csr & EP0_SENT_STALL)
+    {   
+   	DbgPrintf("[STALL]");
+   	CLR_EP0_SENT_STALL();
+	if(ep0_csr & EP0_OUT_PKT_READY) 
+	{
+	    CLR_EP0_OUT_PKT_RDY();
+	}
+	
+	ep0State=EP0_STATE_INIT;
+	return;
+    }	
+
+
+
+    if((ep0_csr & EP0_OUT_PKT_READY)) // && (ep0State==EP0_STATE_INIT))
+    {	
+	RdPktEp0((U8 *)&descSetup,EP0_PKT_SIZE);
+
+	PrintEp0Pkt((U8 *)(&descSetup)); //DEBUG
+    
+	switch(descSetup.bRequest)
+    	{
+    	case GET_DESCRIPTOR:
+            switch(descSetup.bValueH)        
+            {
+            case DEVICE_TYPE:
+ 	    	DbgPrintf("[GDD]");
+ 	    	CLR_EP0_OUT_PKT_RDY();
+	    	ep0State=EP0_STATE_GD_DEV_0;	        
+	    	break;	
+	    case CONFIGURATION_TYPE:
+ 	    	DbgPrintf("[GDC]");
+ 	    	CLR_EP0_OUT_PKT_RDY();
+ 	    	if((descSetup.bLengthL+(descSetup.bLengthH<<8))>0x9)
+ 	    	  //bLengthH should be used for bLength=0x209 at WIN2K.    	
+	    	   ep0State=EP0_STATE_GD_CFG_0; //for WIN98,WIN2K
+               else	    	    
+  		    ep0State=EP0_STATE_GD_CFG_ONLY_0; //for WIN2K
+	    	break;
+   	    case STRING_TYPE:
+ 	    	DbgPrintf("[GDS]");
+ 	    	CLR_EP0_OUT_PKT_RDY();
+	    	switch(descSetup.bValueL)
+	    	{
+	    	    case 0:
+	    	    	ep0State=EP0_STATE_GD_STR_I0;
+	    	    	break;
+	    	    case 1:
+       	    	    	ep0State=EP0_STATE_GD_STR_I1;
+	    	    	break;
+	    	    case 2:	
+	    	    	ep0State=EP0_STATE_GD_STR_I2;
+	    	    	break;
+	    	    default:
+	    		DbgPrintf("[UE:STRI?]");
+	    		break;
+	    	}
+	    	ep0SubState=0;
+	    	break;
+	    case INTERFACE_TYPE:
+ 	    	DbgPrintf("[GDI]");
+ 	    	CLR_EP0_OUT_PKT_RDY();
+	    	ep0State=EP0_STATE_GD_IF_ONLY_0; //for WIN98
+	    	break;
+	    case ENDPOINT_TYPE:	    	
+ 	    	DbgPrintf("[GDE]");
+ 	    	CLR_EP0_OUT_PKT_RDY();
+ 	    	switch(descSetup.bValueL&0xf)
+	    	{
+	    	case 0:
+	    	    ep0State=EP0_STATE_GD_EP0_ONLY_0;
+	    	    break;
+	    	case 1:
+       	    	    ep0State=EP0_STATE_GD_EP1_ONLY_0;
+	    	    break;
+	    	default:
+	    	    DbgPrintf("[UE:GDE?]");
+	    	    break;
+	    	}
+	    	break;
+	    default:
+	    	DbgPrintf("[UE:GD?]");
+	    	break;
+	    }	
+    	    break;
+
+    	case SET_ADDRESS:
+            DbgPrintf("[SA:%d]",descSetup.bValueL);
+            usbdevregs->FUNC_ADDR_REG=descSetup.bValueL | 0x80;
+	    CLR_EP0_OUTPKTRDY_DATAEND(); //Because of no data control transfers.
+            ep0State=EP0_STATE_INIT;
+            break;
+    	
+	case SET_CONFIGURATION:
+            DbgPrintf("[SC]");
+            ConfigSet.ConfigurationValue=descSetup.bValueL;
+            CLR_EP0_OUTPKTRDY_DATAEND(); //Because of no data control transfers.
+            ep0State=EP0_STATE_INIT;
+
+            isUsbdSetConfiguration=1; 
+            break;
+
+    	    //////////////////////// For chapter 9 test ////////////////////
+
+    	  case CLEAR_FEATURE:
+    	  	
+    	  	switch (descSetup.bmRequestType)
+    	  	{
+    	  	  case DEVICE_RECIPIENT:
+    	  	  	if (descSetup.bValueL == 1)
+    	  	  		Rwuen = FALSE;
+    	  	  	
+    	  	  	break;
+
+    	  	  case ENDPOINT_RECIPIENT:
+    	  	  	 if (descSetup.bValueL == 0)
+    	  	  	 {
+	                       if((descSetup.bIndexL & 0x7f) == 0x00){
+	                        StatusGet.Endpoint0= 0;    
+	                       }
+	                       if((descSetup.bIndexL & 0x8f) == 0x81){           // IN  Endpoint 1
+	                         StatusGet.Endpoint1= 0;           
+	                        }
+	                       if((descSetup.bIndexL & 0x8f) == 0x03){          // OUT Endpoint 3
+	                         StatusGet.Endpoint3= 0;      
+	                         }
+                       }
+    	  	  	 
+    	  	  	 break;
+
+    	  	  default:
+    	  	  	break;
+    	  	}
+    	  	CLR_EP0_OUTPKTRDY_DATAEND();
+    	  	ep0State=EP0_STATE_INIT;
+    	  	break;
+
+    	  case GET_CONFIGURATION:
+
+                CLR_EP0_OUT_PKT_RDY();
+	    	  ep0State=EP0_CONFIG_SET;
+    	  	   
+    	         break;
+
+
+    	  case GET_INTERFACE:
+    	  	
+    	  	  CLR_EP0_OUT_PKT_RDY();
+	    	  ep0State=EP0_INTERFACE_GET;
+    	  	  
+    	  	  break;
+
+    	  case GET_STATUS:
+
+    	  	switch(descSetup.bmRequestType)
+    	  	{
+    	  	      case  (0x80):
+
+    	  	 		CLR_EP0_OUT_PKT_RDY();
+    	  	 		StatusGet.Device=((U8)Rwuen<<1)|(U8)Selfpwr;
+    	  	 		ep0State=EP0_GET_STATUS0;
+    	  	 		    	  	 		
+                          break;
+
+                     case  (0x81):
+                           	CLR_EP0_OUT_PKT_RDY();
+    	  	 		StatusGet.Interface=0;
+    	  	 		ep0State=EP0_GET_STATUS1;
+                          break;
+
+                     case  (0x82):
+
+                     	CLR_EP0_OUT_PKT_RDY();
+    	  	 		if((descSetup.bIndexL & 0x7f) == 0x00){
+	                          ep0State=EP0_GET_STATUS2;
+    	  	 		  }
+    	  	 		
+	                       if((descSetup.bIndexL & 0x8f) == 0x81){
+	                          ep0State=EP0_GET_STATUS3;
+	                       }
+	                       
+	                       if((descSetup.bIndexL & 0x8f) == 0x03){
+                                ep0State=EP0_GET_STATUS4;
+	                       }
+                          break;
+
+                      default:
+                          	break;
+    	  	}
+    	  	      
+    	  	break;
+
+
+    	  case SET_DESCRIPTOR:
+    	  	       CLR_EP0_OUTPKTRDY_DATAEND();
+    	  	       ep0State=EP0_STATE_INIT;
+    	  	break;
+
+
+    	  case SET_FEATURE:
+    	  	 
+    	  	switch (descSetup.bmRequestType)
+    	  	{
+    	  	  case DEVICE_RECIPIENT:
+    	  	  	if (descSetup.bValueL == 1)
+    	  	  		Rwuen = TRUE;
+    	  	  	
+    	  	  	break;
+
+    	  	  case ENDPOINT_RECIPIENT:
+    	  	  	 if (descSetup.bValueL == 0)
+    	  	  	 {
+	                       if((descSetup.bIndexL & 0x7f) == 0x00){
+	                        StatusGet.Endpoint0= 1;
+	                       }
+	                       if((descSetup.bIndexL & 0x8f) == 0x81){
+	                         StatusGet.Endpoint1= 1;
+	                       }
+	                       if((descSetup.bIndexL & 0x8f) == 0x03){
+	                         StatusGet.Endpoint3= 1;
+	                       }
+                       }
+    	  	  	break;
+
+    	  	  default:
+    	  	  	break;
+    	  	}
+    	  	CLR_EP0_OUTPKTRDY_DATAEND();
+    	  	ep0State=EP0_STATE_INIT;
+    	  
+    	  	break;
+
+
+    	  case SET_INTERFACE:
+    	  	   InterfaceGet.AlternateSetting= descSetup.bValueL;
+    	  	   CLR_EP0_OUTPKTRDY_DATAEND(); 
+                 ep0State=EP0_STATE_INIT;
+    	  	break;
+
+    	  case SYNCH_FRAME:
+    	  	ep0State=EP0_STATE_INIT;
+    	  	break;
+
+    	  //////////////////////////////////////////////////////////////
+
+  	default:
+	    DbgPrintf("[UE:SETUP=%x]",descSetup.bRequest);
+    	    CLR_EP0_OUTPKTRDY_DATAEND(); //Because of no data control transfers.
+	    ep0State=EP0_STATE_INIT;
+	    break;
+    
+        }
+    }
+    
+    switch(ep0State)
+    {	
+	case EP0_STATE_INIT:
+	    break; 
+
+	//=== GET_DESCRIPTOR:DEVICE ===
+    	case EP0_STATE_GD_DEV_0:
+            DbgPrintf("[GDD0]");
+            WrPktEp0((U8 *)&descDev+0,8); //EP0_PKT_SIZE
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_DEV_1;
+            break;
+            
+    	case EP0_STATE_GD_DEV_1:
+            DbgPrintf("[GDD1]");
+            WrPktEp0((U8 *)&descDev+0x8,8); 
+            SET_EP0_IN_PKT_RDY();
+            
+            ep0State=EP0_STATE_GD_DEV_2;
+            break;
+
+    	case EP0_STATE_GD_DEV_2:
+            DbgPrintf("[GDD2]");
+            WrPktEp0((U8 *)&descDev+0x10,2);   //8+8+2=0x12
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;
+            break;
+    
+
+        //=== GET_DESCRIPTOR:CONFIGURATION+INTERFACE+ENDPOINT0+ENDPOINT1 ===
+        //Windows98 gets these 4 descriptors all together by issuing only a request.
+        //Windows2000 gets each descriptor seperately.
+    	case EP0_STATE_GD_CFG_0:
+            DbgPrintf("[GDC0]");
+            WrPktEp0((U8 *)&descConf+0,8); //EP0_PKT_SIZE
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_CFG_1;
+            break;
+    
+    	case EP0_STATE_GD_CFG_1:
+            DbgPrintf("[GDC1]");
+            WrPktEp0((U8 *)&descConf+8,1); 
+            WrPktEp0((U8 *)&descIf+0,7); 
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_CFG_2;
+            break;
+
+    	case EP0_STATE_GD_CFG_2:
+            DbgPrintf("[GDC2]");
+            WrPktEp0((U8 *)&descIf+7,2); 
+            WrPktEp0((U8 *)&descEndpt0+0,6); 
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_CFG_3;
+            break;
+
+    	case EP0_STATE_GD_CFG_3:
+            DbgPrintf("[GDC3]");
+            WrPktEp0((U8 *)&descEndpt0+6,1); 
+            WrPktEp0((U8 *)&descEndpt1+0,7); 
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_CFG_4;            
+            break;
+
+    	case EP0_STATE_GD_CFG_4:
+            DbgPrintf("[GDC4]");
+             //zero length data packit 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;            
+            break;
+
+        //=== GET_DESCRIPTOR:CONFIGURATION ONLY===
+    	case EP0_STATE_GD_CFG_ONLY_0:
+            DbgPrintf("[GDCO0]");
+            WrPktEp0((U8 *)&descConf+0,8); //EP0_PKT_SIZE
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_CFG_ONLY_1;
+            break;
+    
+    	case EP0_STATE_GD_CFG_ONLY_1:
+            DbgPrintf("[GDCO1]");
+            WrPktEp0((U8 *)&descConf+8,1); 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;            
+            break;
+
+        //=== GET_DESCRIPTOR:INTERFACE ONLY===
+    	case EP0_STATE_GD_IF_ONLY_0:
+            DbgPrintf("[GDI0]");
+            WrPktEp0((U8 *)&descIf+0,8); 
+            SET_EP0_IN_PKT_RDY();
+            ep0State=EP0_STATE_GD_IF_ONLY_1;
+            break;
+    	case EP0_STATE_GD_IF_ONLY_1:
+            DbgPrintf("[GDI1]");
+            WrPktEp0((U8 *)&descIf+8,1); 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;            
+            break;
+
+        //=== GET_DESCRIPTOR:ENDPOINT 0 ONLY===
+    	case EP0_STATE_GD_EP0_ONLY_0:
+            DbgPrintf("[GDE00]");
+            WrPktEp0((U8 *)&descEndpt0+0,7); 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;            
+            break;
+            
+        //=== GET_DESCRIPTOR:ENDPOINT 1 ONLY===
+    	case EP0_STATE_GD_EP1_ONLY_0:
+            DbgPrintf("[GDE10]");
+            WrPktEp0((U8 *)&descEndpt1+0,7); 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;            
+            break;
+            
+////////////////////////////////////////////
+
+         case EP0_INTERFACE_GET:
+            WrPktEp0((U8 *)&InterfaceGet+0,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+ 
+        //=== GET_DESCRIPTOR:STRING ===
+
+    	case EP0_STATE_GD_STR_I0:
+            DbgPrintf("[GDS0_0]");
+           WrPktEp0((U8 *)descStr0, 4 );  
+	    SET_EP0_INPKTRDY_DATAEND();
+	    ep0State=EP0_STATE_INIT;     
+	    ep0SubState=0;
+	    break;
+
+	case EP0_STATE_GD_STR_I1:
+            DbgPrintf("[GDS1_%d]",ep0SubState);
+             if( (ep0SubState*EP0_PKT_SIZE+EP0_PKT_SIZE)<sizeof(descStr1) )
+            {
+            	WrPktEp0((U8 *)descStr1+(ep0SubState*EP0_PKT_SIZE),EP0_PKT_SIZE); 
+            	SET_EP0_IN_PKT_RDY();
+            	ep0State=EP0_STATE_GD_STR_I1;
+            	ep0SubState++;
+            }
+	    else
+	    {
+	    	WrPktEp0((U8 *)descStr1+(ep0SubState*EP0_PKT_SIZE),
+	    		 sizeof(descStr1)-(ep0SubState*EP0_PKT_SIZE)); 
+		SET_EP0_INPKTRDY_DATAEND();
+		ep0State=EP0_STATE_INIT;     
+		ep0SubState=0;
+	    }
+	    break;
+
+	case EP0_STATE_GD_STR_I2:
+            DbgPrintf("[GDS2_%d]",ep0SubState);
+             if( (ep0SubState*EP0_PKT_SIZE+EP0_PKT_SIZE)<sizeof(descStr2) )
+            {
+            	WrPktEp0((U8 *)descStr2+(ep0SubState*EP0_PKT_SIZE),EP0_PKT_SIZE); 
+            	SET_EP0_IN_PKT_RDY();
+            	ep0State=EP0_STATE_GD_STR_I2;
+            	ep0SubState++;
+            }
+	    else
+	    {
+                DbgPrintf("[E]");
+	    	WrPktEp0((U8 *)descStr2+(ep0SubState*EP0_PKT_SIZE),
+	    		 sizeof(descStr2)-(ep0SubState*EP0_PKT_SIZE)); 
+		SET_EP0_INPKTRDY_DATAEND();
+		ep0State=EP0_STATE_INIT;     
+		ep0SubState=0;
+	    }
+	    break;
+
+	 case EP0_CONFIG_SET:
+	 	WrPktEp0((U8 *)&ConfigSet+0,1); 
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+            break;
+
+        case EP0_GET_STATUS0:
+	     WrPktEp0((U8 *)&StatusGet+0,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+         case EP0_GET_STATUS1:
+	     WrPktEp0((U8 *)&StatusGet+1,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+         case EP0_GET_STATUS2:
+	     WrPktEp0((U8 *)&StatusGet+2,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+         case EP0_GET_STATUS3:
+	     WrPktEp0((U8 *)&StatusGet+3,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+         case EP0_GET_STATUS4:
+	     WrPktEp0((U8 *)&StatusGet+4,1);
+            SET_EP0_INPKTRDY_DATAEND();
+            ep0State=EP0_STATE_INIT;      
+         break;
+
+         
+	 	
+     	default:
+	    DbgPrintf("UE:G?D");
+
+     	    break;
+    }
+}
+
+
+   
+    
+void PrintEp0Pkt(U8 *pt)
+{
+    int i;
+    DbgPrintf("[RCV:");
+    for(i=0;i<EP0_PKT_SIZE;i++)
+        DbgPrintf("%x,",pt[i]);
+    DbgPrintf("]");
+}
+
+
+
+
+void InitDescriptorTable(void)
+{	
+    //Standard device descriptor
+    descDev.bLength=0x12;	//EP0_DEV_DESC_SIZE=0x12 bytes    
+    descDev.bDescriptorType=DEVICE_TYPE;         
+    descDev.bcdUSBL=0x10;
+    descDev.bcdUSBH=0x01; 	//Ver 1.10
+    descDev.bDeviceClass=0xFF; //0x0          
+    descDev.bDeviceSubClass=0x0;          
+    descDev.bDeviceProtocol=0x0;          
+    descDev.bMaxPacketSize0=0x8;         
+    descDev.idVendorL=0x45;
+    descDev.idVendorH=0x53;
+    descDev.idProductL=0x34;
+    descDev.idProductH=0x12;
+    descDev.bcdDeviceL=0x00;
+    descDev.bcdDeviceH=0x01;
+    descDev.iManufacturer=0x1;  //index of string descriptor
+    descDev.iProduct=0x2;	//index of string descriptor 
+    descDev.iSerialNumber=0x0;
+    descDev.bNumConfigurations=0x1;
+
+    //Standard configuration descriptor
+    descConf.bLength=0x9;    
+    descConf.bDescriptorType=CONFIGURATION_TYPE;         
+    descConf.wTotalLengthL=0x20; //<cfg desc>+<if desc>+<endp0 desc>+<endp1 desc>
+    descConf.wTotalLengthH=0;
+    descConf.bNumInterfaces=1;
+//dbg    descConf.bConfigurationValue=2;  //why 2? There's no reason.
+    descConf.bConfigurationValue=1;  
+    descConf.iConfiguration=0;
+    descConf.bmAttributes=CONF_ATTR_DEFAULT|CONF_ATTR_SELFPOWERED;  //bus powered only.
+    descConf.maxPower=25; //draws 50mA current from the USB bus.          
+
+    //Standard interface descriptor
+    descIf.bLength=0x9;    
+    descIf.bDescriptorType=INTERFACE_TYPE;         
+    descIf.bInterfaceNumber=0x0;
+    descIf.bAlternateSetting=0x0; //?
+    descIf.bNumEndpoints=2;	//# of endpoints except EP0
+    descIf.bInterfaceClass=0xff; //0x0 ?
+    descIf.bInterfaceSubClass=0x0;  
+    descIf.bInterfaceProtocol=0x0;
+    descIf.iInterface=0x0;
+
+    //Standard endpoint0 descriptor
+    descEndpt0.bLength=0x7;    
+    descEndpt0.bDescriptorType=ENDPOINT_TYPE;         
+    descEndpt0.bEndpointAddress=1|EP_ADDR_IN;   // 2400Xendpoint 1 is IN endpoint.
+    descEndpt0.bmAttributes=EP_ATTR_BULK;
+    descEndpt0.wMaxPacketSizeL=EP1_PKT_SIZE; //64
+    descEndpt0.wMaxPacketSizeH=0x0;
+    descEndpt0.bInterval=0x0; //not used
+
+    //Standard endpoint1 descriptor
+    descEndpt1.bLength=0x7;    
+    descEndpt1.bDescriptorType=ENDPOINT_TYPE;         
+    descEndpt1.bEndpointAddress=3|EP_ADDR_OUT;   // 2400X endpoint 3 is OUT endpoint.
+    descEndpt1.bmAttributes=EP_ATTR_BULK;
+    descEndpt1.wMaxPacketSizeL=EP3_PKT_SIZE; //64
+    descEndpt1.wMaxPacketSizeH=0x0;
+    descEndpt1.bInterval=0x0; //not used 
+}
+
diff -urN u-boot-1.1.6/drivers/usb/usbsetup.h u-boot-1.1.6_fdt/drivers/usb/usbsetup.h
--- u-boot-1.1.6/drivers/usb/usbsetup.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/drivers/usb/usbsetup.h	2018-10-22 15:53:21.557641225 +0800
@@ -0,0 +1,55 @@
+/****************************************************************
+ NAME: usbsetup.h
+ DESC: usb setup
+ HISTORY:
+ Mar.25.2002:purnnamu: reuse the source of S3C2400X u24xmon 
+ ****************************************************************/
+ 
+#ifndef __USBSETUP_H__
+#define __USBSETUP_H__
+
+void Ep0Handler(void);
+void InitDescriptorTable(void);
+void PrintEp0Pkt(U8 *pt);
+
+
+#define EP0_STATE_INIT 			(0)  
+
+//NOTE: The ep0State value in a same group should be added by 1.
+#define EP0_STATE_GD_DEV_0	 	(10)  //10-10=0 
+#define EP0_STATE_GD_DEV_1 		(11)  //11-10=1
+#define EP0_STATE_GD_DEV_2 		(12)  //12-10=2
+
+#define EP0_STATE_GD_CFG_0	 	(20)
+#define EP0_STATE_GD_CFG_1 		(21)
+#define EP0_STATE_GD_CFG_2 		(22)
+#define EP0_STATE_GD_CFG_3 		(23)
+#define EP0_STATE_GD_CFG_4 		(24)
+
+#define EP0_STATE_GD_CFG_ONLY_0		(40)
+#define EP0_STATE_GD_CFG_ONLY_1		(41)
+#define EP0_STATE_GD_IF_ONLY_0 		(42)
+#define EP0_STATE_GD_IF_ONLY_1 		(43)
+#define EP0_STATE_GD_EP0_ONLY_0		(44)
+#define EP0_STATE_GD_EP1_ONLY_0		(45)
+#define EP0_INTERFACE_GET                        (46)
+
+
+#define EP0_STATE_GD_STR_I0	 	(30)  
+#define EP0_STATE_GD_STR_I1	 	(31)  
+#define EP0_STATE_GD_STR_I2	 	(32)  
+
+#define EP0_CONFIG_SET    (33)
+#define EP0_GET_STATUS0  (35)
+#define EP0_GET_STATUS1  (36)
+#define EP0_GET_STATUS2  (37)
+#define EP0_GET_STATUS3  (38)
+#define EP0_GET_STATUS4  (39)
+
+
+
+
+extern U32 ep0State;
+
+
+#endif /*__USBSETUP_H__*/
diff -urN u-boot-1.1.6/include/asm-arm/mach-types.h u-boot-1.1.6_fdt/include/asm-arm/mach-types.h
--- u-boot-1.1.6/include/asm-arm/mach-types.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/include/asm-arm/mach-types.h	2018-10-22 15:53:21.557641225 +0800
@@ -737,6 +737,7 @@
 #define MACH_TYPE_CB3RUFC              726
 #define MACH_TYPE_MP2USB               727
 #define MACH_TYPE_PDNB3               1002
+#define MACH_TYPE_SMDKS3C2440          782 
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
diff -urN u-boot-1.1.6/include/asm-arm/types.h u-boot-1.1.6_fdt/include/asm-arm/types.h
--- u-boot-1.1.6/include/asm-arm/types.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/include/asm-arm/types.h	2018-10-22 15:53:21.565641224 +0800
@@ -45,6 +45,9 @@
 
 typedef u32 dma_addr_t;
 
+typedef unsigned long phys_addr_t;
+typedef unsigned long phys_size_t;
+
 #endif /* __KERNEL__ */
 
 #endif
diff -urN u-boot-1.1.6/include/asm-arm/u-boot-arm.h u-boot-1.1.6_fdt/include/asm-arm/u-boot-arm.h
--- u-boot-1.1.6/include/asm-arm/u-boot-arm.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/include/asm-arm/u-boot-arm.h	2018-10-22 15:53:21.565641224 +0800
@@ -35,6 +35,9 @@
 extern ulong _bss_end;		/* BSS end */
 extern ulong IRQ_STACK_START;	/* top of IRQ stack */
 extern ulong FIQ_STACK_START;	/* top of FIQ stack */
+extern ulong FREE_RAM_END;	/* top of free ram */
+extern ulong FREE_RAM_SIZE;	/* size of free ram */
+extern ulong PreLoadedONRAM;
 
 /* cpu/.../cpu.c */
 int	cpu_init(void);
diff -urN u-boot-1.1.6/include/configs/100ask24x0.h u-boot-1.1.6_fdt/include/configs/100ask24x0.h
--- u-boot-1.1.6/include/configs/100ask24x0.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/include/configs/100ask24x0.h	2018-10-22 15:53:21.565641224 +0800
@@ -0,0 +1,240 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <gj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * Configuation settings for the SAMSUNG SMDK2410 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T		1	/* This is an ARM920T Core	*/
+#define	CONFIG_S3C2410		1	/* in a SAMSUNG S3C2410 SoC     */
+#define CONFIG_SMDK2410		1	/* on a SAMSUNG SMDK2410 Board  */
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000 /* the SMDK2410 has 12MHz input clock */
+//#define CONFIG_SYS_CLK_FREQ	16934400 /* the SMDK2410 has 12MHz input clock */
+
+
+#define USE_920T_MMU		1
+
+#define CONFIG_USB_DEVICE   1
+
+#ifdef CONFIG_USB_DEVICE
+#define CONFIG_USE_IRQ		1
+#endif
+
+#define CONFIG_JFFS2_CMDLINE 1
+#define CONFIG_JFFS2_NAND    1
+
+#define MTDIDS_DEFAULT "nand0=nandflash0"
+#define MTDPARTS_DEFAULT "mtdparts=nandflash0:256k@0(bootloader)," \
+							"128k(device_tree)," \
+							"128k(params)," \
+                            "4m(kernel)," \
+                            "-(root)"
+
+//#define	CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_IS_IN_NAND  1
+#define CFG_ENV_OFFSET      0x60000
+#define CFG_ENV_SIZE		0x20000	/* Total Size of Environment Sector */
+
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + 128*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+#if 1
+#if 0
+#define CONFIG_DRIVER_CS8900	1	/* we have a CS8900 on-board */
+#define CS8900_BASE		0x19000300
+#define CS8900_BUS16		1 /* the Linux driver does accesses as shorts */
+#endif
+
+#if !defined(CONFIG_DRIVER_CS8900)
+#define CONFIG_DRIVER_DM9000		1
+#define CONFIG_DM9000_USE_16BIT 	1
+#define CONFIG_DM9000_BASE			0x20000000
+#define DM9000_IO					0x20000000  
+#define DM9000_DATA					0x20000004
+#endif
+#endif
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on SMDK2410 */
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define	CONFIG_RTC_S3C24X0	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+/* for tag(s) to transfer message to kernel, www.100ask.net */
+#define CONFIG_SETUP_MEMORY_TAGS    1
+#define CONFIG_CMDLINE_TAG          1
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#define CONFIG_COMMANDS \
+                        ((CONFIG_CMD_DFL | \
+                        CFG_CMD_CACHE    | \
+                    /* Start: by www.100ask.net */ \
+                        CFG_CMD_PING     | \
+                        CFG_CMD_JFFS2    | \
+                        CFG_CMD_NAND     | \
+                    /* End: by www.100ask.net */ \
+                        /*CFG_CMD_EEPROM |*/ \
+                        /*CFG_CMD_I2C    |*/ \
+                        /*CFG_CMD_USB    |*/ \
+                        CFG_CMD_REGINFO  | \
+                        CFG_CMD_DATE     | \
+                        CFG_CMD_ELF))
+
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	2
+#define CONFIG_BOOTARGS    	"noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200"
+#define CONFIG_ETHADDR	    08:00:3e:26:0a:5b
+#define CONFIG_NETMASK      255.255.255.0
+#define CONFIG_IPADDR		192.168.1.17
+#define CONFIG_SERVERIP		192.168.1.11
+/*#define CONFIG_BOOTFILE	"elinos-lart" */
+#define CONFIG_BOOTCOMMAND	"nand read.jffs2 0x30007FC0 kernel; nand read.jffs2 32000000 device_tree; bootm 0x30007FC0 - 0x32000000"
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory		*/
+#define	CFG_PROMPT		"OpenJTAG> "	/* Monitor Command Prompt	*/
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CFG_MEMTEST_START	0x30000000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x33F00000	/* 63 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x33000000	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 15625 for 10 ms, so we need */
+/* it to wrap 100 times (total 1562500) to get 1 sec. */
+#define	CFG_HZ			1562500
+
+/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+#define CFG_MONITOR_BASE	PHYS_FLASH_1
+
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+#if 0
+#define CONFIG_AMD_LV400	1	/* uncomment this if you have a LV400 flash */
+#endif
+//#define CONFIG_AMD_LV800	1	/* uncomment this if you have a LV800 flash */
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#ifdef CONFIG_AMD_LV800
+#define PHYS_FLASH_SIZE		0x00100000 /* 1MB */
+#define CFG_MAX_FLASH_SECT	(19)	/* max number of sectors on one chip */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x0F0000) /* addr of environment */
+#endif
+#ifdef CONFIG_AMD_LV400
+#define PHYS_FLASH_SIZE		0x00080000 /* 512KB */
+#define CFG_MAX_FLASH_SECT	(11)	/* max number of sectors on one chip */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x070000) /* addr of environment */
+#endif
+
+#define CFG_FLASH_CFI				1
+#define CFG_FLASH_CFI_DRIVER 		1
+#define CFG_FLASH_USE_BUFFER_WRITE	1
+#define CONFIG_FLASH_CFI_LEGACY		1
+
+#ifdef CFG_FLASH_CFI_DRIVER
+#define CFG_MAX_FLASH_SECT	 512   /* max number of sectors on one chip */
+#define CFG_FLASH_CFI_WIDTH  0x02  /* FLASH_CFI_16BIT */
+#endif
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+
+/*-----------------------------------------------------------------------
+ * NAND flash settings
+ */
+#define CFG_NAND_BASE           0
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-1.1.6/include/configs/SBC8560.h u-boot-1.1.6_fdt/include/configs/SBC8560.h
--- u-boot-1.1.6/include/configs/SBC8560.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/include/configs/SBC8560.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,410 +0,0 @@
-/*
- * (C) Copyright 2002,2003 Motorola,Inc.
- * Xianghua Xiao <X.Xiao@motorola.com>
- *
- * (C) Copyright 2004 Wind River Systems Inc <www.windriver.com>.
- * Added support for Wind River SBC8560 board
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-/* mpc8560ads board configuration file */
-/* please refer to doc/README.mpc85xx for more info */
-/* make sure you change the MAC address and other network params first,
- * search for CONFIG_ETHADDR,CONFIG_SERVERIP,etc in this file
- */
-
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-#if XXX
-#define DEBUG		      /* General debug */
-#define ET_DEBUG
-#endif
-#define TSEC_DEBUG
-
-/* High Level Configuration Options */
-#define CONFIG_BOOKE		1	/* BOOKE			*/
-#define CONFIG_E500		1	/* BOOKE e500 family		*/
-#define CONFIG_MPC85xx		1	/* MPC8540/MPC8560		*/
-#define CONFIG_MPC85xx_REV1	1	/* MPC85xx Rev 1.0 chip		*/
-
-
-#define CONFIG_CPM2		1	/* has CPM2 */
-#define CONFIG_SBC8560      	1   	/* configuration for SBC8560 board */
-
-#define CONFIG_MPC8560ADS	1	/* MPC8560ADS board specific (supplement)	*/
-
-#define CONFIG_TSEC_ENET		/* tsec ethernet support	*/
-#undef	CONFIG_PCI			/* pci ethernet support		*/
-#undef  CONFIG_ETHER_ON_FCC		/* cpm FCC ethernet support	*/
-
-
-#define CONFIG_ENV_OVERWRITE
-
-/* Using Localbus SDRAM to emulate flash before we can program the flash,
- * normally you need a flash-boot image(u-boot.bin), if so undef this.
- */
-#undef CONFIG_RAM_AS_FLASH
-
-#if defined(CONFIG_PCI_66)		/* some PCI card is 33Mhz only	*/
-  #define CONFIG_SYS_CLK_FREQ	66000000/* sysclk for MPC85xx		*/
-#else
-  #define CONFIG_SYS_CLK_FREQ	33000000/* most pci cards are 33Mhz	*/
-#endif
-
-/* below can be toggled for performance analysis. otherwise use default */
-#define CONFIG_L2_CACHE			    /* toggle L2 cache		*/
-#undef	CONFIG_BTB			    /* toggle branch predition	*/
-#undef	CONFIG_ADDR_STREAMING		    /* toggle addr streaming	*/
-
-#define CONFIG_BOARD_EARLY_INIT_F 1	    /* Call board_early_init_f	*/
-
-#undef	CFG_DRAM_TEST			    /* memory test, takes time	*/
-#define CFG_MEMTEST_START	0x00200000  /* memtest region */
-#define CFG_MEMTEST_END		0x00400000
-
-#if (defined(CONFIG_PCI) && defined(CONFIG_TSEC_ENET) || \
-     defined(CONFIG_PCI) && defined(CONFIG_ETHER_ON_FCC) || \
-     defined(CONFIG_TSEC_ENET) && defined(CONFIG_ETHER_ON_FCC))
-#error "You can only use ONE of PCI Ethernet Card or TSEC Ethernet or CPM FCC."
-#endif
-
-/*
- * Base addresses -- Note these are effective addresses where the
- * actual resources get mapped (not physical addresses)
- */
-#define CFG_CCSRBAR_DEFAULT	0xff700000	/* CCSRBAR Default	*/
-
-#if XXX
-  #define CFG_CCSRBAR		0xfdf00000	/* relocated CCSRBAR	*/
-#else
-  #define CFG_CCSRBAR		0xff700000	/* default CCSRBAR	*/
-#endif
-#define CFG_IMMR		CFG_CCSRBAR	/* PQII uses CFG_IMMR	*/
-
-#define CFG_DDR_SDRAM_BASE	0x00000000	/* DDR is system memory	 */
-#define CFG_SDRAM_BASE		CFG_DDR_SDRAM_BASE
-#define CFG_SDRAM_SIZE		512		/* DDR is 512MB */
-#define SPD_EEPROM_ADDRESS	0x55		/*  DDR DIMM */
-
-#undef  CONFIG_DDR_ECC				/* only for ECC DDR module	*/
-#undef  CONFIG_SPD_EEPROM			/* Use SPD EEPROM for DDR setup */
-
-#if defined(CONFIG_MPC85xx_REV1)
-  #define CONFIG_DDR_DLL			/* possible DLL fix needed	*/
-#endif
-
-#undef CONFIG_CLOCKS_IN_MHZ
-
-#if defined(CONFIG_RAM_AS_FLASH)
-  #define CFG_LBC_SDRAM_BASE	0xfc000000	/* Localbus SDRAM */
-  #define CFG_FLASH_BASE	0xf8000000      /* start of FLASH 8M  */
-  #define CFG_BR0_PRELIM	0xf8000801      /* port size 8bit */
-  #define CFG_OR0_PRELIM	0xf8000ff7	/* 8MB Flash		*/
-#else /* Boot from real Flash */
-  #define CFG_LBC_SDRAM_BASE	0xf8000000	/* Localbus SDRAM */
-  #define CFG_FLASH_BASE	0xff800000      /* start of FLASH 8M    */
-  #define CFG_BR0_PRELIM	0xff800801      /* port size 8bit      */
-  #define CFG_OR0_PRELIM	0xff800ff7	/* 8MB Flash		*/
-#endif
-#define CFG_LBC_SDRAM_SIZE	64		/* LBC SDRAM is 64MB	*/
-
-/* local bus definitions */
-#define CFG_BR1_PRELIM		0xe4001801	/* 64M, 32-bit flash */
-#define CFG_OR1_PRELIM		0xfc000ff7
-
-#define CFG_BR2_PRELIM		0x00000000	/* CS2 not used */
-#define CFG_OR2_PRELIM		0x00000000
-
-#define CFG_BR3_PRELIM		0xf0001861	/* 64MB localbus SDRAM	*/
-#define CFG_OR3_PRELIM		0xfc000cc1
-
-#if defined(CONFIG_RAM_AS_FLASH)
-  #define CFG_BR4_PRELIM	0xf4001861	/* 64M localbus SDRAM */
-#else
-  #define CFG_BR4_PRELIM	0xf8001861	/* 64M localbus SDRAM */
-#endif
-#define CFG_OR4_PRELIM		0xfc000cc1
-
-#define CFG_BR5_PRELIM		0xfc000801	/* 16M CS5 misc devices */
-#if 1
-  #define CFG_OR5_PRELIM	0xff000ff7
-#else
-  #define CFG_OR5_PRELIM	0xff0000f0
-#endif
-
-#define CFG_BR6_PRELIM		0xe0001801	/* 64M, 32-bit flash */
-#define CFG_OR6_PRELIM		0xfc000ff7
-#define CFG_LBC_LCRR		0x00030002	/* local bus freq	*/
-#define CFG_LBC_LBCR		0x00000000
-#define CFG_LBC_LSRT		0x20000000
-#define CFG_LBC_MRTPR		0x20000000
-#define CFG_LBC_LSDMR_1		0x2861b723
-#define CFG_LBC_LSDMR_2		0x0861b723
-#define CFG_LBC_LSDMR_3		0x0861b723
-#define CFG_LBC_LSDMR_4		0x1861b723
-#define CFG_LBC_LSDMR_5		0x4061b723
-
-/* just hijack the MOT BCSR def for SBC8560 misc devices */
-#define CFG_BCSR		((CFG_BR5_PRELIM & 0xff000000)|0x00400000)
-/* the size of CS5 needs to be >= 16M for TLB and LAW setups */
-
-#define CONFIG_L1_INIT_RAM
-#define CFG_INIT_RAM_LOCK	1
-#define CFG_INIT_RAM_ADDR	0x70000000	/* Initial RAM address	*/
-#define CFG_INIT_RAM_END	0x4000		/* End of used area in RAM */
-
-#define CFG_GBL_DATA_SIZE	128		/* num bytes initial data */
-#define CFG_GBL_DATA_OFFSET	(CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
-#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
-
-#define CFG_MONITOR_LEN		(256 * 1024)	/* Reserve 256 kB for Mon */
-#define CFG_MALLOC_LEN		(128 * 1024)	/* Reserved for malloc */
-
-/* Serial Port */
-#undef  CONFIG_CONS_ON_SCC			/* define if console on SCC */
-#undef	CONFIG_CONS_NONE			/* define if console on something else */
-
-#define CONFIG_CONS_INDEX     1
-#undef	CONFIG_SERIAL_SOFTWARE_FIFO
-#define CFG_NS16550
-#define CFG_NS16550_SERIAL
-#define CFG_NS16550_REG_SIZE	1
-#define CFG_NS16550_CLK		1843200 /* get_bus_freq(0) */
-#define CONFIG_BAUDRATE		9600
-
-#define CFG_BAUDRATE_TABLE  \
-	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400,115200}
-
-#define CFG_NS16550_COM1	((CFG_BR5_PRELIM & 0xff000000)+0x00700000)
-#define CFG_NS16550_COM2	((CFG_BR5_PRELIM & 0xff000000)+0x00800000)
-
-/* Use the HUSH parser */
-#define CFG_HUSH_PARSER
-#ifdef	CFG_HUSH_PARSER
-#define CFG_PROMPT_HUSH_PS2 "> "
-#endif
-
-/* I2C */
-#define	 CONFIG_HARD_I2C		/* I2C with hardware support*/
-#undef	CONFIG_SOFT_I2C			/* I2C bit-banged */
-#define CFG_I2C_SPEED		400000	/* I2C speed and slave address	*/
-#define CFG_I2C_SLAVE		0x7F
-#define CFG_I2C_NOPROBES	{0x69}	/* Don't probe these addrs */
-
-#define CFG_PCI_MEM_BASE	0xC0000000
-#define CFG_PCI_MEM_PHYS	0xC0000000
-#define CFG_PCI_MEM_SIZE	0x10000000
-
-#if defined(CONFIG_TSEC_ENET)		/* TSEC Ethernet port */
-
-#  define CONFIG_NET_MULTI	1
-#  define CONFIG_MII		1	/* MII PHY management		*/
-#  define CONFIG_MPC85xx_TSEC1
-#  define CONFIG_MPC85xx_TSEC1_NAME	"TSEC0"
-#  define TSEC1_PHY_ADDR	25
-#  define TSEC1_PHYIDX		0
-/* Options are: TSEC0 */
-#  define CONFIG_ETHPRIME		"TSEC0"
-
-
-#elif defined(CONFIG_ETHER_ON_FCC)	/* CPM FCC Ethernet */
-
-  #undef  CONFIG_ETHER_NONE		/* define if ether on something else */
-  #define CONFIG_ETHER_ON_FCC2		/* cpm FCC ethernet support	*/
-  #define CONFIG_ETHER_INDEX	2	/* which channel for ether  */
-
-  #if (CONFIG_ETHER_INDEX == 2)
-    /*
-     * - Rx-CLK is CLK13
-     * - Tx-CLK is CLK14
-     * - Select bus for bd/buffers
-     * - Full duplex
-     */
-    #define CFG_CMXFCR_MASK	(CMXFCR_FC2 | CMXFCR_RF2CS_MSK | CMXFCR_TF2CS_MSK)
-    #define CFG_CMXFCR_VALUE	(CMXFCR_RF2CS_CLK13 | CMXFCR_TF2CS_CLK14)
-    #define CFG_CPMFCR_RAMTYPE	0
-    #define CFG_FCC_PSMR	(FCC_PSMR_FDE)
-
-  #elif (CONFIG_ETHER_INDEX == 3)
-    /* need more definitions here for FE3 */
-  #endif				/* CONFIG_ETHER_INDEX */
-
-  #define CONFIG_MII			/* MII PHY management */
-  #define CONFIG_BITBANGMII		/* bit-bang MII PHY management	*/
-  /*
-   * GPIO pins used for bit-banged MII communications
-   */
-  #define MDIO_PORT	2		/* Port C */
-  #define MDIO_ACTIVE	(iop->pdir |=  0x00400000)
-  #define MDIO_TRISTATE	(iop->pdir &= ~0x00400000)
-  #define MDIO_READ	((iop->pdat &  0x00400000) != 0)
-
-  #define MDIO(bit)	if(bit) iop->pdat |=  0x00400000; \
-			else	iop->pdat &= ~0x00400000
-
-  #define MDC(bit)	if(bit) iop->pdat |=  0x00200000; \
-			else	iop->pdat &= ~0x00200000
-
-  #define MIIDELAY	udelay(1)
-
-#endif
-
-/*-----------------------------------------------------------------------
- * FLASH and environment organization
- */
-
-#define CFG_FLASH_CFI		1	/* Flash is CFI conformant		*/
-#define CFG_FLASH_CFI_DRIVER	1	/* Use the common driver		*/
-#if 0
-#define CFG_FLASH_USE_BUFFER_WRITE 1    /* use buffered writes (20x faster)     */
-#define CFG_FLASH_PROTECTION		/* use hardware protection		*/
-#endif
-#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
-#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
-
-#undef	CFG_FLASH_CHECKSUM
-#define CFG_FLASH_ERASE_TOUT	200000		/* Timeout for Flash Erase (in ms)	*/
-#define CFG_FLASH_WRITE_TOUT	50000		/* Timeout for Flash Write (in ms)	*/
-
-#define CFG_MONITOR_BASE	TEXT_BASE	/* start of monitor	*/
-
-#if 0
-/* XXX This doesn't work and I don't want to fix it */
-#if (CFG_MONITOR_BASE < CFG_FLASH_BASE)
-  #define CFG_RAMBOOT
-#else
-  #undef  CFG_RAMBOOT
-#endif
-#endif
-
-/* Environment */
-#if !defined(CFG_RAMBOOT)
-  #if defined(CONFIG_RAM_AS_FLASH)
-    #define CFG_ENV_IS_NOWHERE
-    #define CFG_ENV_ADDR	(CFG_FLASH_BASE + 0x100000)
-    #define CFG_ENV_SIZE	0x2000
-  #else
-    #define CFG_ENV_IS_IN_FLASH	1
-    #define CFG_ENV_SECT_SIZE	0x20000 /* 128K(one sector) for env */
-    #define CFG_ENV_ADDR	(CFG_MONITOR_BASE - CFG_ENV_SECT_SIZE)
-    #define CFG_ENV_SIZE	0x2000 /* CFG_ENV_SECT_SIZE */
-  #endif
-#else
-  #define CFG_NO_FLASH		1	/* Flash is not usable now	*/
-  #define CFG_ENV_IS_NOWHERE	1	/* Store ENV in memory only	*/
-  #define CFG_ENV_ADDR		(CFG_MONITOR_BASE - 0x1000)
-  #define CFG_ENV_SIZE		0x2000
-#endif
-
-#define CONFIG_BOOTARGS "root=/dev/nfs rw nfsroot=192.168.0.251:/tftpboot ip=192.168.0.105:192.168.0.251::255.255.255.0:sbc8560:eth0:off console=ttyS0,9600"
-/*#define CONFIG_BOOTARGS      "root=/dev/ram rw console=ttyS0,115200"*/
-#define CONFIG_BOOTCOMMAND	"bootm 0xff800000 0xffa00000"
-#define CONFIG_BOOTDELAY	5	/* -1 disable autoboot */
-
-#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
-#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
-
-#if defined(CFG_RAMBOOT) || defined(CONFIG_RAM_AS_FLASH)
-  #if defined(CONFIG_PCI)
-    #define  CONFIG_COMMANDS	((CONFIG_CMD_DFL | CFG_CMD_PCI | \
-				CFG_CMD_PING | CFG_CMD_I2C) & \
-				 ~(CFG_CMD_ENV | \
-				  CFG_CMD_LOADS ))
-  #elif (defined(CONFIG_TSEC_ENET) || defined(CONFIG_ETHER_ON_FCC))
-    #define  CONFIG_COMMANDS	((CONFIG_CMD_DFL | CFG_CMD_MII | \
-				CFG_CMD_PING | CFG_CMD_I2C) & \
-				~(CFG_CMD_ENV))
-  #endif
-#else
-  #if defined(CONFIG_PCI)
-    #define  CONFIG_COMMANDS	(CONFIG_CMD_DFL | CFG_CMD_PCI | \
-				CFG_CMD_PING | CFG_CMD_I2C)
-  #elif (defined(CONFIG_TSEC_ENET) || defined(CONFIG_ETHER_ON_FCC))
-    #define  CONFIG_COMMANDS	(CONFIG_CMD_DFL | CFG_CMD_MII | \
-				CFG_CMD_PING | CFG_CMD_I2C)
-  #endif
-#endif
-
-#include <cmd_confdefs.h>
-
-#undef CONFIG_WATCHDOG			/* watchdog disabled		*/
-
-/*
- * Miscellaneous configurable options
- */
-#define CFG_LONGHELP			/* undef to save memory		*/
-#define CFG_PROMPT	"SBC8560=> " /* Monitor Command Prompt	*/
-#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
-  #define CFG_CBSIZE	1024		/* Console I/O Buffer Size	*/
-#else
-  #define CFG_CBSIZE	256		/* Console I/O Buffer Size	*/
-#endif
-#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
-#define CFG_MAXARGS	16		/* max number of command args	*/
-#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size	*/
-#define CFG_LOAD_ADDR	0x1000000	/* default load address */
-#define CFG_HZ		1000		/* decrementer freq: 1 ms ticks */
-
-/*
- * For booting Linux, the board info and command line data
- * have to be in the first 8 MB of memory, since this is
- * the maximum mapped by the Linux kernel during initialization.
- */
-#define CFG_BOOTMAPSZ		(8 << 20) /* Initial Memory map for Linux */
-
-/* Cache Configuration */
-#define CFG_DCACHE_SIZE		32768
-#define CFG_CACHELINE_SIZE	32
-#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
-  #define CFG_CACHELINE_SHIFT	5	/* log base 2 of the above value */
-#endif
-
-/*
- * Internal Definitions
- *
- * Boot Flags
- */
-#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH */
-#define BOOTFLAG_WARM	0x02		/* Software reboot		*/
-
-#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
-  #define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
-  #define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
-#endif
-
-/*Note: change below for your network setting!!! */
-#if defined(CONFIG_TSEC_ENET) || defined(CONFIG_ETHER_ON_FCC)
-#  define CONFIG_ETHADDR	00:vv:ww:xx:yy:8a
-#  define CONFIG_HAS_ETH1
-#  define CONFIG_ETH1ADDR	00:vv:ww:xx:yy:8b
-#  define CONFIG_HAS_ETH2
-#  define CONFIG_ETH2ADDR	00:vv:ww:xx:yy:8c
-#endif
-
-#define CONFIG_SERVERIP		YourServerIP
-#define CONFIG_IPADDR		YourTargetIP
-#define CONFIG_GATEWAYIP	YourGatewayIP
-#define CONFIG_NETMASK		255.255.255.0
-#define CONFIG_HOSTNAME		SBC8560
-#define CONFIG_ROOTPATH		YourRootPath
-#define CONFIG_BOOTFILE		YourImageName
-
-#endif	/* __CONFIG_H */
diff -urN u-boot-1.1.6/include/def.h u-boot-1.1.6_fdt/include/def.h
--- u-boot-1.1.6/include/def.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/include/def.h	2018-10-22 15:53:21.565641224 +0800
@@ -0,0 +1,74 @@
+//
+// Copyright (c) Microsoft Corporation.  All rights reserved.
+//
+//
+// Use of this source code is subject to the terms of the Microsoft end-user
+// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
+// If you did not accept the terms of the EULA, you are not authorized to use
+// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
+// install media.
+//
+/*++
+THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
+ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
+PARTICULAR PURPOSE.
+--*/
+#ifndef __DEF_H__
+#define __DEF_H__
+#ifndef U32
+#define U32 unsigned int
+#endif
+
+#ifndef U16
+#define U16 unsigned short
+#endif
+
+#ifndef S32
+#define S32 int
+#endif
+
+#ifndef S16
+#define S16 short int
+#endif
+
+#ifndef U8
+#define U8  unsigned char
+#endif
+
+#ifndef S8
+#define	S8  char
+#endif
+
+typedef unsigned char BOOL;
+typedef unsigned char UCHAR;
+typedef UCHAR *PUCHAR;
+typedef unsigned long DWORD;
+typedef DWORD *PDWORD;
+typedef unsigned long LDWORD;
+typedef DWORD *LPDWORD;
+typedef unsigned char   BYTE;
+typedef unsigned short  WORD;
+
+typedef unsigned long ULONG;
+typedef ULONG *PULONG;
+typedef unsigned short USHORT;
+typedef USHORT *PUSHORT;
+
+typedef BYTE *LPBYTE;
+
+typedef void *PVOID;
+
+typedef  char*          LPSTR;
+
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#define TRUE 	1   
+#define FALSE 	0
+
+#endif /*__DEF_H__*/
+
+
diff -urN u-boot-1.1.6/include/fdtdec.h u-boot-1.1.6_fdt/include/fdtdec.h
--- u-boot-1.1.6/include/fdtdec.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/include/fdtdec.h	2018-10-22 17:00:55.489566433 +0800
@@ -0,0 +1,997 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (c) 2011 The Chromium OS Authors.
+ */
+
+#ifndef __fdtdec_h
+#define __fdtdec_h
+
+/*
+ * This file contains convenience functions for decoding useful and
+ * enlightening information from FDTs. It is intended to be used by device
+ * drivers and board-specific code within U-Boot. It aims to reduce the
+ * amount of FDT munging required within U-Boot itself, so that driver code
+ * changes to support FDT are minimized.
+ */
+
+#include <linux/libfdt.h>
+#include <pci.h>
+
+#define bool unsigned char
+
+/*
+ * A typedef for a physical address. Note that fdt data is always big
+ * endian even on a litle endian machine.
+ */
+typedef phys_addr_t fdt_addr_t;
+typedef phys_size_t fdt_size_t;
+#ifdef CONFIG_PHYS_64BIT
+#define FDT_ADDR_T_NONE (-1U)
+#define fdt_addr_to_cpu(reg) be64_to_cpu(reg)
+#define fdt_size_to_cpu(reg) be64_to_cpu(reg)
+typedef fdt64_t fdt_val_t;
+#else
+#define FDT_ADDR_T_NONE (-1U)
+#define fdt_addr_to_cpu(reg) be32_to_cpu(reg)
+#define fdt_size_to_cpu(reg) be32_to_cpu(reg)
+typedef fdt32_t fdt_val_t;
+#endif
+
+/* Information obtained about memory from the FDT */
+struct fdt_memory {
+	fdt_addr_t start;
+	fdt_addr_t end;
+};
+
+struct bd_info;
+
+#ifdef CONFIG_SPL_BUILD
+#define SPL_BUILD	1
+#else
+#define SPL_BUILD	0
+#endif
+
+//#if CONFIG_IS_ENABLED(OF_PRIOR_STAGE)
+extern phys_addr_t prior_stage_fdt_address;
+//#endif
+
+/*
+ * Information about a resource. start is the first address of the resource
+ * and end is the last address (inclusive). The length of the resource will
+ * be equal to: end - start + 1.
+ */
+struct fdt_resource {
+	fdt_addr_t start;
+	fdt_addr_t end;
+};
+
+enum fdt_pci_space {
+	FDT_PCI_SPACE_CONFIG = 0,
+	FDT_PCI_SPACE_IO = 0x01000000,
+	FDT_PCI_SPACE_MEM32 = 0x02000000,
+	FDT_PCI_SPACE_MEM64 = 0x03000000,
+	FDT_PCI_SPACE_MEM32_PREF = 0x42000000,
+	FDT_PCI_SPACE_MEM64_PREF = 0x43000000,
+};
+
+#define FDT_PCI_ADDR_CELLS	3
+#define FDT_PCI_SIZE_CELLS	2
+#define FDT_PCI_REG_SIZE	\
+	((FDT_PCI_ADDR_CELLS + FDT_PCI_SIZE_CELLS) * sizeof(u32))
+
+/*
+ * The Open Firmware spec defines PCI physical address as follows:
+ *
+ *          bits# 31 .... 24 23 .... 16 15 .... 08 07 .... 00
+ *
+ * phys.hi  cell:  npt000ss   bbbbbbbb   dddddfff   rrrrrrrr
+ * phys.mid cell:  hhhhhhhh   hhhhhhhh   hhhhhhhh   hhhhhhhh
+ * phys.lo  cell:  llllllll   llllllll   llllllll   llllllll
+ *
+ * where:
+ *
+ * n:        is 0 if the address is relocatable, 1 otherwise
+ * p:        is 1 if addressable region is prefetchable, 0 otherwise
+ * t:        is 1 if the address is aliased (for non-relocatable I/O) below 1MB
+ *           (for Memory), or below 64KB (for relocatable I/O)
+ * ss:       is the space code, denoting the address space
+ * bbbbbbbb: is the 8-bit Bus Number
+ * ddddd:    is the 5-bit Device Number
+ * fff:      is the 3-bit Function Number
+ * rrrrrrrr: is the 8-bit Register Number
+ * hhhhhhhh: is a 32-bit unsigned number
+ * llllllll: is a 32-bit unsigned number
+ */
+struct fdt_pci_addr {
+	u32	phys_hi;
+	u32	phys_mid;
+	u32	phys_lo;
+};
+
+/**
+ * Compute the size of a resource.
+ *
+ * @param res	the resource to operate on
+ * @return the size of the resource
+ */
+static inline fdt_size_t fdt_resource_size(const struct fdt_resource *res)
+{
+	return res->end - res->start + 1;
+}
+
+/**
+ * Compat types that we know about and for which we might have drivers.
+ * Each is named COMPAT_<dir>_<filename> where <dir> is the directory
+ * within drivers.
+ */
+enum fdt_compat_id {
+	COMPAT_UNKNOWN,
+	COMPAT_NVIDIA_TEGRA20_EMC,	/* Tegra20 memory controller */
+	COMPAT_NVIDIA_TEGRA20_EMC_TABLE, /* Tegra20 memory timing table */
+	COMPAT_NVIDIA_TEGRA20_NAND,	/* Tegra2 NAND controller */
+	COMPAT_NVIDIA_TEGRA124_XUSB_PADCTL,
+					/* Tegra124 XUSB pad controller */
+	COMPAT_NVIDIA_TEGRA210_XUSB_PADCTL,
+					/* Tegra210 XUSB pad controller */
+	COMPAT_SMSC_LAN9215,		/* SMSC 10/100 Ethernet LAN9215 */
+	COMPAT_SAMSUNG_EXYNOS5_SROMC,	/* Exynos5 SROMC */
+	COMPAT_SAMSUNG_S3C2440_I2C,	/* Exynos I2C Controller */
+	COMPAT_SAMSUNG_EXYNOS5_SOUND,	/* Exynos Sound */
+	COMPAT_WOLFSON_WM8994_CODEC,	/* Wolfson WM8994 Sound Codec */
+	COMPAT_SAMSUNG_EXYNOS_USB_PHY,	/* Exynos phy controller for usb2.0 */
+	COMPAT_SAMSUNG_EXYNOS5_USB3_PHY,/* Exynos phy controller for usb3.0 */
+	COMPAT_SAMSUNG_EXYNOS_TMU,	/* Exynos TMU */
+	COMPAT_SAMSUNG_EXYNOS_MIPI_DSI,	/* Exynos mipi dsi */
+	COMPAT_SAMSUNG_EXYNOS_DWMMC,	/* Exynos DWMMC controller */
+	COMPAT_SAMSUNG_EXYNOS_MMC,	/* Exynos MMC controller */
+	COMPAT_GENERIC_SPI_FLASH,	/* Generic SPI Flash chip */
+	COMPAT_MAXIM_98095_CODEC,	/* MAX98095 Codec */
+	COMPAT_SAMSUNG_EXYNOS5_I2C,	/* Exynos5 High Speed I2C Controller */
+	COMPAT_SAMSUNG_EXYNOS_SYSMMU,	/* Exynos sysmmu */
+	COMPAT_INTEL_MICROCODE,		/* Intel microcode update */
+	COMPAT_AMS_AS3722,		/* AMS AS3722 PMIC */
+	COMPAT_INTEL_QRK_MRC,		/* Intel Quark MRC */
+	COMPAT_ALTERA_SOCFPGA_DWMAC,	/* SoCFPGA Ethernet controller */
+	COMPAT_ALTERA_SOCFPGA_DWMMC,	/* SoCFPGA DWMMC controller */
+	COMPAT_ALTERA_SOCFPGA_DWC2USB,	/* SoCFPGA DWC2 USB controller */
+	COMPAT_INTEL_BAYTRAIL_FSP,	/* Intel Bay Trail FSP */
+	COMPAT_INTEL_BAYTRAIL_FSP_MDP,	/* Intel FSP memory-down params */
+	COMPAT_INTEL_IVYBRIDGE_FSP,	/* Intel Ivy Bridge FSP */
+	COMPAT_SUNXI_NAND,		/* SUNXI NAND controller */
+	COMPAT_ALTERA_SOCFPGA_CLK,	/* SoCFPGA Clock initialization */
+	COMPAT_ALTERA_SOCFPGA_PINCTRL_SINGLE,	/* SoCFPGA pinctrl-single */
+	COMPAT_ALTERA_SOCFPGA_H2F_BRG,          /* SoCFPGA hps2fpga bridge */
+	COMPAT_ALTERA_SOCFPGA_LWH2F_BRG,        /* SoCFPGA lwhps2fpga bridge */
+	COMPAT_ALTERA_SOCFPGA_F2H_BRG,          /* SoCFPGA fpga2hps bridge */
+	COMPAT_ALTERA_SOCFPGA_F2SDR0,           /* SoCFPGA fpga2SDRAM0 bridge */
+	COMPAT_ALTERA_SOCFPGA_F2SDR1,           /* SoCFPGA fpga2SDRAM1 bridge */
+	COMPAT_ALTERA_SOCFPGA_F2SDR2,           /* SoCFPGA fpga2SDRAM2 bridge */
+	COMPAT_ALTERA_SOCFPGA_FPGA0,		/* SOCFPGA FPGA manager */
+	COMPAT_ALTERA_SOCFPGA_NOC,		/* SOCFPGA Arria 10 NOC */
+	COMPAT_ALTERA_SOCFPGA_CLK_INIT,		/* SOCFPGA Arria 10 clk init */
+
+	COMPAT_COUNT,
+};
+
+#define MAX_PHANDLE_ARGS 16
+struct fdtdec_phandle_args {
+	int node;
+	int args_count;
+	uint32_t args[MAX_PHANDLE_ARGS];
+};
+
+/**
+ * fdtdec_parse_phandle_with_args() - Find a node pointed by phandle in a list
+ *
+ * This function is useful to parse lists of phandles and their arguments.
+ *
+ * Example:
+ *
+ * phandle1: node1 {
+ *	#list-cells = <2>;
+ * }
+ *
+ * phandle2: node2 {
+ *	#list-cells = <1>;
+ * }
+ *
+ * node3 {
+ *	list = <&phandle1 1 2 &phandle2 3>;
+ * }
+ *
+ * To get a device_node of the `node2' node you may call this:
+ * fdtdec_parse_phandle_with_args(blob, node3, "list", "#list-cells", 0, 1,
+ *				  &args);
+ *
+ * (This function is a modified version of __of_parse_phandle_with_args() from
+ * Linux 3.18)
+ *
+ * @blob:	Pointer to device tree
+ * @src_node:	Offset of device tree node containing a list
+ * @list_name:	property name that contains a list
+ * @cells_name:	property name that specifies the phandles' arguments count,
+ *		or NULL to use @cells_count
+ * @cells_count: Cell count to use if @cells_name is NULL
+ * @index:	index of a phandle to parse out
+ * @out_args:	optional pointer to output arguments structure (will be filled)
+ * @return 0 on success (with @out_args filled out if not NULL), -ENOENT if
+ *	@list_name does not exist, a phandle was not found, @cells_name
+ *	could not be found, the arguments were truncated or there were too
+ *	many arguments.
+ *
+ */
+int fdtdec_parse_phandle_with_args(const void *blob, int src_node,
+				   const char *list_name,
+				   const char *cells_name,
+				   int cell_count, int index,
+				   struct fdtdec_phandle_args *out_args);
+
+/**
+ * Find the next numbered alias for a peripheral. This is used to enumerate
+ * all the peripherals of a certain type.
+ *
+ * Do the first call with *upto = 0. Assuming /aliases/<name>0 exists then
+ * this function will return a pointer to the node the alias points to, and
+ * then update *upto to 1. Next time you call this function, the next node
+ * will be returned.
+ *
+ * All nodes returned will match the compatible ID, as it is assumed that
+ * all peripherals use the same driver.
+ *
+ * @param blob		FDT blob to use
+ * @param name		Root name of alias to search for
+ * @param id		Compatible ID to look for
+ * @return offset of next compatible node, or -FDT_ERR_NOTFOUND if no more
+ */
+int fdtdec_next_alias(const void *blob, const char *name,
+		enum fdt_compat_id id, int *upto);
+
+/**
+ * Find the compatible ID for a given node.
+ *
+ * Generally each node has at least one compatible string attached to it.
+ * This function looks through our list of known compatible strings and
+ * returns the corresponding ID which matches the compatible string.
+ *
+ * @param blob		FDT blob to use
+ * @param node		Node containing compatible string to find
+ * @return compatible ID, or COMPAT_UNKNOWN if we cannot find a match
+ */
+enum fdt_compat_id fdtdec_lookup(const void *blob, int node);
+
+/**
+ * Find the next compatible node for a peripheral.
+ *
+ * Do the first call with node = 0. This function will return a pointer to
+ * the next compatible node. Next time you call this function, pass the
+ * value returned, and the next node will be provided.
+ *
+ * @param blob		FDT blob to use
+ * @param node		Start node for search
+ * @param id		Compatible ID to look for (enum fdt_compat_id)
+ * @return offset of next compatible node, or -FDT_ERR_NOTFOUND if no more
+ */
+int fdtdec_next_compatible(const void *blob, int node,
+		enum fdt_compat_id id);
+
+/**
+ * Find the next compatible subnode for a peripheral.
+ *
+ * Do the first call with node set to the parent and depth = 0. This
+ * function will return the offset of the next compatible node. Next time
+ * you call this function, pass the node value returned last time, with
+ * depth unchanged, and the next node will be provided.
+ *
+ * @param blob		FDT blob to use
+ * @param node		Start node for search
+ * @param id		Compatible ID to look for (enum fdt_compat_id)
+ * @param depthp	Current depth (set to 0 before first call)
+ * @return offset of next compatible node, or -FDT_ERR_NOTFOUND if no more
+ */
+int fdtdec_next_compatible_subnode(const void *blob, int node,
+		enum fdt_compat_id id, int *depthp);
+
+/*
+ * Look up an address property in a node and return the parsed address, and
+ * optionally the parsed size.
+ *
+ * This variant assumes a known and fixed number of cells are used to
+ * represent the address and size.
+ *
+ * You probably don't want to use this function directly except to parse
+ * non-standard properties, and never to parse the "reg" property. Instead,
+ * use one of the "auto" variants below, which automatically honor the
+ * #address-cells and #size-cells properties in the parent node.
+ *
+ * @param blob	FDT blob
+ * @param node	node to examine
+ * @param prop_name	name of property to find
+ * @param index	which address to retrieve from a list of addresses. Often 0.
+ * @param na	the number of cells used to represent an address
+ * @param ns	the number of cells used to represent a size
+ * @param sizep	a pointer to store the size into. Use NULL if not required
+ * @param translate	Indicates whether to translate the returned value
+ *			using the parent node's ranges property.
+ * @return address, if found, or FDT_ADDR_T_NONE if not
+ */
+fdt_addr_t fdtdec_get_addr_size_fixed(const void *blob, int node,
+		const char *prop_name, int index, int na, int ns,
+		fdt_size_t *sizep, bool translate);
+
+/*
+ * Look up an address property in a node and return the parsed address, and
+ * optionally the parsed size.
+ *
+ * This variant automatically determines the number of cells used to represent
+ * the address and size by parsing the provided parent node's #address-cells
+ * and #size-cells properties.
+ *
+ * @param blob	FDT blob
+ * @param parent	parent node of @node
+ * @param node	node to examine
+ * @param prop_name	name of property to find
+ * @param index	which address to retrieve from a list of addresses. Often 0.
+ * @param sizep	a pointer to store the size into. Use NULL if not required
+ * @param translate	Indicates whether to translate the returned value
+ *			using the parent node's ranges property.
+ * @return address, if found, or FDT_ADDR_T_NONE if not
+ */
+fdt_addr_t fdtdec_get_addr_size_auto_parent(const void *blob, int parent,
+		int node, const char *prop_name, int index, fdt_size_t *sizep,
+		bool translate);
+
+/*
+ * Look up an address property in a node and return the parsed address, and
+ * optionally the parsed size.
+ *
+ * This variant automatically determines the number of cells used to represent
+ * the address and size by parsing the parent node's #address-cells
+ * and #size-cells properties. The parent node is automatically found.
+ *
+ * The automatic parent lookup implemented by this function is slow.
+ * Consequently, fdtdec_get_addr_size_auto_parent() should be used where
+ * possible.
+ *
+ * @param blob	FDT blob
+ * @param parent	parent node of @node
+ * @param node	node to examine
+ * @param prop_name	name of property to find
+ * @param index	which address to retrieve from a list of addresses. Often 0.
+ * @param sizep	a pointer to store the size into. Use NULL if not required
+ * @param translate	Indicates whether to translate the returned value
+ *			using the parent node's ranges property.
+ * @return address, if found, or FDT_ADDR_T_NONE if not
+ */
+fdt_addr_t fdtdec_get_addr_size_auto_noparent(const void *blob, int node,
+		const char *prop_name, int index, fdt_size_t *sizep,
+		bool translate);
+
+/*
+ * Look up an address property in a node and return the parsed address.
+ *
+ * This variant hard-codes the number of cells used to represent the address
+ * and size based on sizeof(fdt_addr_t) and sizeof(fdt_size_t). It also
+ * always returns the first address value in the property (index 0).
+ *
+ * Use of this function is not recommended due to the hard-coding of cell
+ * counts. There is no programmatic validation that these hard-coded values
+ * actually match the device tree content in any way at all. This assumption
+ * can be satisfied by manually ensuring CONFIG_PHYS_64BIT is appropriately
+ * set in the U-Boot build and exercising strict control over DT content to
+ * ensure use of matching #address-cells/#size-cells properties. However, this
+ * approach is error-prone; those familiar with DT will not expect the
+ * assumption to exist, and could easily invalidate it. If the assumption is
+ * invalidated, this function will not report the issue, and debugging will
+ * be required. Instead, use fdtdec_get_addr_size_auto_parent().
+ *
+ * @param blob	FDT blob
+ * @param node	node to examine
+ * @param prop_name	name of property to find
+ * @return address, if found, or FDT_ADDR_T_NONE if not
+ */
+fdt_addr_t fdtdec_get_addr(const void *blob, int node,
+		const char *prop_name);
+
+/*
+ * Look up an address property in a node and return the parsed address, and
+ * optionally the parsed size.
+ *
+ * This variant hard-codes the number of cells used to represent the address
+ * and size based on sizeof(fdt_addr_t) and sizeof(fdt_size_t). It also
+ * always returns the first address value in the property (index 0).
+ *
+ * Use of this function is not recommended due to the hard-coding of cell
+ * counts. There is no programmatic validation that these hard-coded values
+ * actually match the device tree content in any way at all. This assumption
+ * can be satisfied by manually ensuring CONFIG_PHYS_64BIT is appropriately
+ * set in the U-Boot build and exercising strict control over DT content to
+ * ensure use of matching #address-cells/#size-cells properties. However, this
+ * approach is error-prone; those familiar with DT will not expect the
+ * assumption to exist, and could easily invalidate it. If the assumption is
+ * invalidated, this function will not report the issue, and debugging will
+ * be required. Instead, use fdtdec_get_addr_size_auto_parent().
+ *
+ * @param blob	FDT blob
+ * @param node	node to examine
+ * @param prop_name	name of property to find
+ * @param sizep	a pointer to store the size into. Use NULL if not required
+ * @return address, if found, or FDT_ADDR_T_NONE if not
+ */
+fdt_addr_t fdtdec_get_addr_size(const void *blob, int node,
+		const char *prop_name, fdt_size_t *sizep);
+
+/**
+ * Look at an address property in a node and return the pci address which
+ * corresponds to the given type in the form of fdt_pci_addr.
+ * The property must hold one fdt_pci_addr with a lengh.
+ *
+ * @param blob		FDT blob
+ * @param node		node to examine
+ * @param type		pci address type (FDT_PCI_SPACE_xxx)
+ * @param prop_name	name of property to find
+ * @param addr		returns pci address in the form of fdt_pci_addr
+ * @return 0 if ok, -ENOENT if the property did not exist, -EINVAL if the
+ *		format of the property was invalid, -ENXIO if the requested
+ *		address type was not found
+ */
+int fdtdec_get_pci_addr(const void *blob, int node, enum fdt_pci_space type,
+		const char *prop_name, struct fdt_pci_addr *addr);
+
+/**
+ * Look at the compatible property of a device node that represents a PCI
+ * device and extract pci vendor id and device id from it.
+ *
+ * @param blob		FDT blob
+ * @param node		node to examine
+ * @param vendor	vendor id of the pci device
+ * @param device	device id of the pci device
+ * @return 0 if ok, negative on error
+ */
+int fdtdec_get_pci_vendev(const void *blob, int node,
+		u16 *vendor, u16 *device);
+
+/**
+ * Look at the pci address of a device node that represents a PCI device
+ * and return base address of the pci device's registers.
+ *
+ * @param dev		device to examine
+ * @param addr		pci address in the form of fdt_pci_addr
+ * @param bar		returns base address of the pci device's registers
+ * @return 0 if ok, negative on error
+ */
+int fdtdec_get_pci_bar32(struct udevice *dev, struct fdt_pci_addr *addr,
+			 u32 *bar);
+
+/**
+ * Look up a 32-bit integer property in a node and return it. The property
+ * must have at least 4 bytes of data. The value of the first cell is
+ * returned.
+ *
+ * @param blob	FDT blob
+ * @param node	node to examine
+ * @param prop_name	name of property to find
+ * @param default_val	default value to return if the property is not found
+ * @return integer value, if found, or default_val if not
+ */
+s32 fdtdec_get_int(const void *blob, int node, const char *prop_name,
+		s32 default_val);
+
+/**
+ * Unsigned version of fdtdec_get_int. The property must have at least
+ * 4 bytes of data. The value of the first cell is returned.
+ *
+ * @param blob	FDT blob
+ * @param node	node to examine
+ * @param prop_name	name of property to find
+ * @param default_val	default value to return if the property is not found
+ * @return unsigned integer value, if found, or default_val if not
+ */
+unsigned int fdtdec_get_uint(const void *blob, int node, const char *prop_name,
+			unsigned int default_val);
+
+/**
+ * Get a variable-sized number from a property
+ *
+ * This reads a number from one or more cells.
+ *
+ * @param ptr	Pointer to property
+ * @param cells	Number of cells containing the number
+ * @return the value in the cells
+ */
+u64 fdtdec_get_number(const fdt32_t *ptr, unsigned int cells);
+
+/**
+ * Look up a 64-bit integer property in a node and return it. The property
+ * must have at least 8 bytes of data (2 cells). The first two cells are
+ * concatenated to form a 8 bytes value, where the first cell is top half and
+ * the second cell is bottom half.
+ *
+ * @param blob	FDT blob
+ * @param node	node to examine
+ * @param prop_name	name of property to find
+ * @param default_val	default value to return if the property is not found
+ * @return integer value, if found, or default_val if not
+ */
+uint64_t fdtdec_get_uint64(const void *blob, int node, const char *prop_name,
+		uint64_t default_val);
+
+/**
+ * Checks whether a node is enabled.
+ * This looks for a 'status' property. If this exists, then returns 1 if
+ * the status is 'ok' and 0 otherwise. If there is no status property,
+ * it returns 1 on the assumption that anything mentioned should be enabled
+ * by default.
+ *
+ * @param blob	FDT blob
+ * @param node	node to examine
+ * @return integer value 0 (not enabled) or 1 (enabled)
+ */
+int fdtdec_get_is_enabled(const void *blob, int node);
+
+/**
+ * Make sure we have a valid fdt available to control U-Boot.
+ *
+ * If not, a message is printed to the console if the console is ready.
+ *
+ * @return 0 if all ok, -1 if not
+ */
+int fdtdec_prepare_fdt(void);
+
+/**
+ * Checks that we have a valid fdt available to control U-Boot.
+
+ * However, if not then for the moment nothing is done, since this function
+ * is called too early to panic().
+ *
+ * @returns 0
+ */
+int fdtdec_check_fdt(void);
+
+/**
+ * Find the nodes for a peripheral and return a list of them in the correct
+ * order. This is used to enumerate all the peripherals of a certain type.
+ *
+ * To use this, optionally set up a /aliases node with alias properties for
+ * a peripheral. For example, for usb you could have:
+ *
+ * aliases {
+ *		usb0 = "/ehci@c5008000";
+ *		usb1 = "/ehci@c5000000";
+ * };
+ *
+ * Pass "usb" as the name to this function and will return a list of two
+ * nodes offsets: /ehci@c5008000 and ehci@c5000000.
+ *
+ * All nodes returned will match the compatible ID, as it is assumed that
+ * all peripherals use the same driver.
+ *
+ * If no alias node is found, then the node list will be returned in the
+ * order found in the fdt. If the aliases mention a node which doesn't
+ * exist, then this will be ignored. If nodes are found with no aliases,
+ * they will be added in any order.
+ *
+ * If there is a gap in the aliases, then this function return a 0 node at
+ * that position. The return value will also count these gaps.
+ *
+ * This function checks node properties and will not return nodes which are
+ * marked disabled (status = "disabled").
+ *
+ * @param blob		FDT blob to use
+ * @param name		Root name of alias to search for
+ * @param id		Compatible ID to look for
+ * @param node_list	Place to put list of found nodes
+ * @param maxcount	Maximum number of nodes to find
+ * @return number of nodes found on success, FDT_ERR_... on error
+ */
+int fdtdec_find_aliases_for_id(const void *blob, const char *name,
+			enum fdt_compat_id id, int *node_list, int maxcount);
+
+/*
+ * This function is similar to fdtdec_find_aliases_for_id() except that it
+ * adds to the node_list that is passed in. Any 0 elements are considered
+ * available for allocation - others are considered already used and are
+ * skipped.
+ *
+ * You can use this by calling fdtdec_find_aliases_for_id() with an
+ * uninitialised array, then setting the elements that are returned to -1,
+ * say, then calling this function, perhaps with a different compat id.
+ * Any elements you get back that are >0 are new nodes added by the call
+ * to this function.
+ *
+ * Note that if you have some nodes with aliases and some without, you are
+ * sailing close to the wind. The call to fdtdec_find_aliases_for_id() with
+ * one compat_id may fill in positions for which you have aliases defined
+ * for another compat_id. When you later call *this* function with the second
+ * compat_id, the alias positions may already be used. A debug warning may
+ * be generated in this case, but it is safest to define aliases for all
+ * nodes when you care about the ordering.
+ */
+int fdtdec_add_aliases_for_id(const void *blob, const char *name,
+			enum fdt_compat_id id, int *node_list, int maxcount);
+
+/**
+ * Get the alias sequence number of a node
+ *
+ * This works out whether a node is pointed to by an alias, and if so, the
+ * sequence number of that alias. Aliases are of the form <base><num> where
+ * <num> is the sequence number. For example spi2 would be sequence number
+ * 2.
+ *
+ * @param blob		Device tree blob (if NULL, then error is returned)
+ * @param base		Base name for alias (before the underscore)
+ * @param node		Node to look up
+ * @param seqp		This is set to the sequence number if one is found,
+ *			but otherwise the value is left alone
+ * @return 0 if a sequence was found, -ve if not
+ */
+int fdtdec_get_alias_seq(const void *blob, const char *base, int node,
+			 int *seqp);
+
+/**
+ * Get a property from the /chosen node
+ *
+ * @param blob		Device tree blob (if NULL, then NULL is returned)
+ * @param name		Property name to look up
+ * @return Value of property, or NULL if it does not exist
+ */
+const char *fdtdec_get_chosen_prop(const void *blob, const char *name);
+
+/**
+ * Get the offset of the given /chosen node
+ *
+ * This looks up a property in /chosen containing the path to another node,
+ * then finds the offset of that node.
+ *
+ * @param blob		Device tree blob (if NULL, then error is returned)
+ * @param name		Property name, e.g. "stdout-path"
+ * @return Node offset referred to by that chosen node, or -ve FDT_ERR_...
+ */
+int fdtdec_get_chosen_node(const void *blob, const char *name);
+
+/*
+ * Get the name for a compatible ID
+ *
+ * @param id		Compatible ID to look for
+ * @return compatible string for that id
+ */
+const char *fdtdec_get_compatible(enum fdt_compat_id id);
+
+/* Look up a phandle and follow it to its node. Then return the offset
+ * of that node.
+ *
+ * @param blob		FDT blob
+ * @param node		node to examine
+ * @param prop_name	name of property to find
+ * @return node offset if found, -ve error code on error
+ */
+int fdtdec_lookup_phandle(const void *blob, int node, const char *prop_name);
+
+/**
+ * Look up a property in a node and return its contents in an integer
+ * array of given length. The property must have at least enough data for
+ * the array (4*count bytes). It may have more, but this will be ignored.
+ *
+ * @param blob		FDT blob
+ * @param node		node to examine
+ * @param prop_name	name of property to find
+ * @param array		array to fill with data
+ * @param count		number of array elements
+ * @return 0 if ok, or -FDT_ERR_NOTFOUND if the property is not found,
+ *		or -FDT_ERR_BADLAYOUT if not enough data
+ */
+int fdtdec_get_int_array(const void *blob, int node, const char *prop_name,
+		u32 *array, int count);
+
+/**
+ * Look up a property in a node and return its contents in an integer
+ * array of given length. The property must exist but may have less data that
+ * expected (4*count bytes). It may have more, but this will be ignored.
+ *
+ * @param blob		FDT blob
+ * @param node		node to examine
+ * @param prop_name	name of property to find
+ * @param array		array to fill with data
+ * @param count		number of array elements
+ * @return number of array elements if ok, or -FDT_ERR_NOTFOUND if the
+ *		property is not found
+ */
+int fdtdec_get_int_array_count(const void *blob, int node,
+			       const char *prop_name, u32 *array, int count);
+
+/**
+ * Look up a property in a node and return a pointer to its contents as a
+ * unsigned int array of given length. The property must have at least enough
+ * data for the array ('count' cells). It may have more, but this will be
+ * ignored. The data is not copied.
+ *
+ * Note that you must access elements of the array with fdt32_to_cpu(),
+ * since the elements will be big endian even on a little endian machine.
+ *
+ * @param blob		FDT blob
+ * @param node		node to examine
+ * @param prop_name	name of property to find
+ * @param count		number of array elements
+ * @return pointer to array if found, or NULL if the property is not
+ *		found or there is not enough data
+ */
+const u32 *fdtdec_locate_array(const void *blob, int node,
+			       const char *prop_name, int count);
+
+/**
+ * Look up a boolean property in a node and return it.
+ *
+ * A boolean properly is true if present in the device tree and false if not
+ * present, regardless of its value.
+ *
+ * @param blob	FDT blob
+ * @param node	node to examine
+ * @param prop_name	name of property to find
+ * @return 1 if the properly is present; 0 if it isn't present
+ */
+int fdtdec_get_bool(const void *blob, int node, const char *prop_name);
+
+/*
+ * Count child nodes of one parent node.
+ *
+ * @param blob	FDT blob
+ * @param node	parent node
+ * @return number of child node; 0 if there is not child node
+ */
+int fdtdec_get_child_count(const void *blob, int node);
+
+/**
+ * Look in the FDT for a config item with the given name and return its value
+ * as a 32-bit integer. The property must have at least 4 bytes of data. The
+ * value of the first cell is returned.
+ *
+ * @param blob		FDT blob to use
+ * @param prop_name	Node property name
+ * @param default_val	default value to return if the property is not found
+ * @return integer value, if found, or default_val if not
+ */
+int fdtdec_get_config_int(const void *blob, const char *prop_name,
+		int default_val);
+
+/**
+ * Look in the FDT for a config item with the given name
+ * and return whether it exists.
+ *
+ * @param blob		FDT blob
+ * @param prop_name	property name to look up
+ * @return 1, if it exists, or 0 if not
+ */
+int fdtdec_get_config_bool(const void *blob, const char *prop_name);
+
+/**
+ * Look in the FDT for a config item with the given name and return its value
+ * as a string.
+ *
+ * @param blob          FDT blob
+ * @param prop_name     property name to look up
+ * @returns property string, NULL on error.
+ */
+char *fdtdec_get_config_string(const void *blob, const char *prop_name);
+
+/*
+ * Look up a property in a node and return its contents in a byte
+ * array of given length. The property must have at least enough data for
+ * the array (count bytes). It may have more, but this will be ignored.
+ *
+ * @param blob		FDT blob
+ * @param node		node to examine
+ * @param prop_name	name of property to find
+ * @param array		array to fill with data
+ * @param count		number of array elements
+ * @return 0 if ok, or -FDT_ERR_MISSING if the property is not found,
+ *		or -FDT_ERR_BADLAYOUT if not enough data
+ */
+int fdtdec_get_byte_array(const void *blob, int node, const char *prop_name,
+		u8 *array, int count);
+
+/**
+ * Look up a property in a node and return a pointer to its contents as a
+ * byte array of given length. The property must have at least enough data
+ * for the array (count bytes). It may have more, but this will be ignored.
+ * The data is not copied.
+ *
+ * @param blob		FDT blob
+ * @param node		node to examine
+ * @param prop_name	name of property to find
+ * @param count		number of array elements
+ * @return pointer to byte array if found, or NULL if the property is not
+ *		found or there is not enough data
+ */
+const u8 *fdtdec_locate_byte_array(const void *blob, int node,
+			     const char *prop_name, int count);
+
+/**
+ * Obtain an indexed resource from a device property.
+ *
+ * @param fdt		FDT blob
+ * @param node		node to examine
+ * @param property	name of the property to parse
+ * @param index		index of the resource to retrieve
+ * @param res		returns the resource
+ * @return 0 if ok, negative on error
+ */
+int fdt_get_resource(const void *fdt, int node, const char *property,
+		     unsigned int index, struct fdt_resource *res);
+
+/**
+ * Obtain a named resource from a device property.
+ *
+ * Look up the index of the name in a list of strings and return the resource
+ * at that index.
+ *
+ * @param fdt		FDT blob
+ * @param node		node to examine
+ * @param property	name of the property to parse
+ * @param prop_names	name of the property containing the list of names
+ * @param name		the name of the entry to look up
+ * @param res		returns the resource
+ */
+int fdt_get_named_resource(const void *fdt, int node, const char *property,
+			   const char *prop_names, const char *name,
+			   struct fdt_resource *res);
+
+/* Display timings from linux include/video/display_timing.h */
+enum display_flags {
+	DISPLAY_FLAGS_HSYNC_LOW		= 1 << 0,
+	DISPLAY_FLAGS_HSYNC_HIGH	= 1 << 1,
+	DISPLAY_FLAGS_VSYNC_LOW		= 1 << 2,
+	DISPLAY_FLAGS_VSYNC_HIGH	= 1 << 3,
+
+	/* data enable flag */
+	DISPLAY_FLAGS_DE_LOW		= 1 << 4,
+	DISPLAY_FLAGS_DE_HIGH		= 1 << 5,
+	/* drive data on pos. edge */
+	DISPLAY_FLAGS_PIXDATA_POSEDGE	= 1 << 6,
+	/* drive data on neg. edge */
+	DISPLAY_FLAGS_PIXDATA_NEGEDGE	= 1 << 7,
+	DISPLAY_FLAGS_INTERLACED	= 1 << 8,
+	DISPLAY_FLAGS_DOUBLESCAN	= 1 << 9,
+	DISPLAY_FLAGS_DOUBLECLK		= 1 << 10,
+};
+
+/*
+ * A single signal can be specified via a range of minimal and maximal values
+ * with a typical value, that lies somewhere inbetween.
+ */
+struct timing_entry {
+	u32 min;
+	u32 typ;
+	u32 max;
+};
+
+/*
+ * Single "mode" entry. This describes one set of signal timings a display can
+ * have in one setting. This struct can later be converted to struct videomode
+ * (see include/video/videomode.h). As each timing_entry can be defined as a
+ * range, one struct display_timing may become multiple struct videomodes.
+ *
+ * Example: hsync active high, vsync active low
+ *
+ *				    Active Video
+ * Video  ______________________XXXXXXXXXXXXXXXXXXXXXX_____________________
+ *	  |<- sync ->|<- back ->|<----- active ----->|<- front ->|<- sync..
+ *	  |	     |	 porch  |		     |	 porch	 |
+ *
+ * HSync _|炉炉炉炉炉炉炉炉炉炉|___________________________________________|炉炉炉炉炉炉炉炉炉
+ *
+ * VSync 炉|__________|炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉炉|_________
+ */
+struct display_timing {
+	struct timing_entry pixelclock;
+
+	struct timing_entry hactive;		/* hor. active video */
+	struct timing_entry hfront_porch;	/* hor. front porch */
+	struct timing_entry hback_porch;	/* hor. back porch */
+	struct timing_entry hsync_len;		/* hor. sync len */
+
+	struct timing_entry vactive;		/* ver. active video */
+	struct timing_entry vfront_porch;	/* ver. front porch */
+	struct timing_entry vback_porch;	/* ver. back porch */
+	struct timing_entry vsync_len;		/* ver. sync len */
+
+	enum display_flags flags;		/* display flags */
+	bool hdmi_monitor;			/* is hdmi monitor? */
+};
+
+/**
+ * fdtdec_decode_display_timing() - decode display timings
+ *
+ * Decode display timings from the supplied 'display-timings' node.
+ * See doc/device-tree-bindings/video/display-timing.txt for binding
+ * information.
+ *
+ * @param blob		FDT blob
+ * @param node		'display-timing' node containing the timing subnodes
+ * @param index		Index number to read (0=first timing subnode)
+ * @param config	Place to put timings
+ * @return 0 if OK, -FDT_ERR_NOTFOUND if not found
+ */
+int fdtdec_decode_display_timing(const void *blob, int node, int index,
+				 struct display_timing *config);
+
+/**
+ * fdtdec_setup_mem_size_base() - decode and setup gd->ram_size and
+ * gd->ram_start
+ *
+ * Decode the /memory 'reg' property to determine the size and start of the
+ * first memory bank, populate the global data with the size and start of the
+ * first bank of memory.
+ *
+ * This function should be called from a boards dram_init(). This helper
+ * function allows for boards to query the device tree for DRAM size and start
+ * address instead of hard coding the value in the case where the memory size
+ * and start address cannot be detected automatically.
+ *
+ * @return 0 if OK, -EINVAL if the /memory node or reg property is missing or
+ * invalid
+ */
+int fdtdec_setup_mem_size_base(void);
+
+/**
+ * fdtdec_setup_memory_banksize() - decode and populate gd->bd->bi_dram
+ *
+ * Decode the /memory 'reg' property to determine the address and size of the
+ * memory banks. Use this data to populate the global data board info with the
+ * phys address and size of memory banks.
+ *
+ * This function should be called from a boards dram_init_banksize(). This
+ * helper function allows for boards to query the device tree for memory bank
+ * information instead of hard coding the information in cases where it cannot
+ * be detected automatically.
+ *
+ * @return 0 if OK, -EINVAL if the /memory node or reg property is missing or
+ * invalid
+ */
+int fdtdec_setup_memory_banksize(void);
+
+/**
+ * Set up the device tree ready for use
+ */
+int fdtdec_setup(void);
+
+/**
+ * Board-specific FDT initialization. Returns the address to a device tree blob.
+ * Called when CONFIG_OF_BOARD is defined, or if CONFIG_OF_SEPARATE is defined
+ * and the board implements it.
+ */
+
+/*
+ * Decode the size of memory
+ *
+ * RAM size is normally set in a /memory node and consists of a list of
+ * (base, size) cells in the 'reg' property. This information is used to
+ * determine the total available memory as well as the address and size
+ * of each bank.
+ *
+ * Optionally the memory configuration can vary depending on a board id,
+ * typically read from strapping resistors or an EEPROM on the board.
+ *
+ * Finally, memory size can be detected (within certain limits) by probing
+ * the available memory. It is safe to do so within the limits provides by
+ * the board's device tree information. This makes it possible to produce
+ * boards with different memory sizes, where the device tree specifies the
+ * maximum memory configuration, and the smaller memory configuration is
+ * probed.
+ *
+ * This function decodes that information, returning the memory base address,
+ * size and bank information. See the memory.txt binding for full
+ * documentation.
+ *
+ * @param blob		Device tree blob
+ * @param area		Name of node to check (NULL means "/memory")
+ * @param board_id	Board ID to look up
+ * @param basep		Returns base address of first memory bank (NULL to
+ *			ignore)
+ * @param sizep		Returns total memory size (NULL to ignore)
+ * @param bd		Updated with the memory bank information (NULL to skip)
+ * @return 0 if OK, -ve on error
+ */
+int fdtdec_decode_ram_size(const void *blob, const char *area, int board_id,
+			   phys_addr_t *basep, phys_size_t *sizep,
+			   struct bd_info *bd);
+
+#endif
diff -urN u-boot-1.1.6/include/fdt.h u-boot-1.1.6_fdt/include/fdt.h
--- u-boot-1.1.6/include/fdt.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/include/fdt.h	2018-10-22 16:36:11.241593816 +0800
@@ -0,0 +1,111 @@
+#ifndef FDT_H
+#define FDT_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ * Copyright 2012 Kim Phillips, Freescale Semiconductor.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __ASSEMBLY__
+
+struct fdt_header {
+	fdt32_t magic;			 /* magic word FDT_MAGIC */
+	fdt32_t totalsize;		 /* total size of DT block */
+	fdt32_t off_dt_struct;		 /* offset to structure */
+	fdt32_t off_dt_strings;		 /* offset to strings */
+	fdt32_t off_mem_rsvmap;		 /* offset to memory reserve map */
+	fdt32_t version;		 /* format version */
+	fdt32_t last_comp_version;	 /* last compatible version */
+
+	/* version 2 fields below */
+	fdt32_t boot_cpuid_phys;	 /* Which physical CPU id we're
+					    booting on */
+	/* version 3 fields below */
+	fdt32_t size_dt_strings;	 /* size of the strings block */
+
+	/* version 17 fields below */
+	fdt32_t size_dt_struct;		 /* size of the structure block */
+};
+
+struct fdt_reserve_entry {
+	fdt64_t address;
+	fdt64_t size;
+};
+
+struct fdt_node_header {
+	fdt32_t tag;
+	char name[0];
+};
+
+struct fdt_property {
+	fdt32_t tag;
+	fdt32_t len;
+	fdt32_t nameoff;
+	char data[0];
+};
+
+#endif /* !__ASSEMBLY */
+
+#define FDT_MAGIC	0xd00dfeed	/* 4: version, 4: total size */
+#define FDT_TAGSIZE	sizeof(fdt32_t)
+
+#define FDT_BEGIN_NODE	0x1		/* Start node: full name */
+#define FDT_END_NODE	0x2		/* End node */
+#define FDT_PROP	0x3		/* Property: name off,
+					   size, content */
+#define FDT_NOP		0x4		/* nop */
+#define FDT_END		0x9
+
+#define FDT_V1_SIZE	(7*sizeof(fdt32_t))
+#define FDT_V2_SIZE	(FDT_V1_SIZE + sizeof(fdt32_t))
+#define FDT_V3_SIZE	(FDT_V2_SIZE + sizeof(fdt32_t))
+#define FDT_V16_SIZE	FDT_V3_SIZE
+#define FDT_V17_SIZE	(FDT_V16_SIZE + sizeof(fdt32_t))
+
+#endif /* FDT_H */
diff -urN u-boot-1.1.6/include/fdt_support.h u-boot-1.1.6_fdt/include/fdt_support.h
--- u-boot-1.1.6/include/fdt_support.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/include/fdt_support.h	2018-10-22 16:58:04.965569579 +0800
@@ -0,0 +1,313 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2007
+ * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
+ */
+
+#ifndef __FDT_SUPPORT_H
+#define __FDT_SUPPORT_H
+
+//#ifdef CONFIG_OF_LIBFDT
+
+#include <linux/libfdt.h>
+
+u32 fdt_getprop_u32_default_node(const void *fdt, int off, int cell,
+				const char *prop, const u32 dflt);
+u32 fdt_getprop_u32_default(const void *fdt, const char *path,
+				const char *prop, const u32 dflt);
+
+/**
+ * Add data to the root of the FDT before booting the OS.
+ *
+ * See doc/device-tree-bindings/root.txt
+ *
+ * @param fdt		FDT address in memory
+ * @return 0 if ok, or -FDT_ERR_... on error
+ */
+int fdt_root(void *fdt);
+
+/**
+ * Add chosen data the FDT before booting the OS.
+ *
+ * In particular, this adds the kernel command line (bootargs) to the FDT.
+ *
+ * @param fdt		FDT address in memory
+ * @return 0 if ok, or -FDT_ERR_... on error
+ */
+int fdt_chosen(void *fdt);
+
+/**
+ * Add initrd information to the FDT before booting the OS.
+ *
+ * @param fdt		FDT address in memory
+ * @return 0 if ok, or -FDT_ERR_... on error
+ */
+int fdt_initrd(void *fdt, ulong initrd_start, ulong initrd_end);
+
+void do_fixup_by_path(void *fdt, const char *path, const char *prop,
+		      const void *val, int len, int create);
+void do_fixup_by_path_u32(void *fdt, const char *path, const char *prop,
+			  u32 val, int create);
+
+static inline void do_fixup_by_path_string(void *fdt, const char *path,
+					   const char *prop, const char *status)
+{
+	do_fixup_by_path(fdt, path, prop, status, strlen(status) + 1, 1);
+}
+
+void do_fixup_by_prop(void *fdt,
+		      const char *pname, const void *pval, int plen,
+		      const char *prop, const void *val, int len,
+		      int create);
+void do_fixup_by_prop_u32(void *fdt,
+			  const char *pname, const void *pval, int plen,
+			  const char *prop, u32 val, int create);
+void do_fixup_by_compat(void *fdt, const char *compat,
+			const char *prop, const void *val, int len, int create);
+void do_fixup_by_compat_u32(void *fdt, const char *compat,
+			    const char *prop, u32 val, int create);
+/**
+ * Setup the memory node in the DT. Creates one if none was existing before.
+ * Calls fdt_fixup_memory_banks() to populate a single reg pair covering the
+ * whole memory.
+ *
+ * @param blob		FDT blob to update
+ * @param start		Begin of DRAM mapping in physical memory
+ * @param size		Size of the single memory bank
+ * @return 0 if ok, or -1 or -FDT_ERR_... on error
+ */
+int fdt_fixup_memory(void *blob, u64 start, u64 size);
+
+/**
+ * Fill the DT memory node with multiple memory banks.
+ * Creates the node if none was existing before.
+ * If banks is 0, it will not touch the existing reg property. This allows
+ * boards to not mess with the existing DT setup, which may have been
+ * filled in properly before.
+ *
+ * @param blob		FDT blob to update
+ * @param start		Array of size <banks> to hold the start addresses.
+ * @param size		Array of size <banks> to hold the size of each region.
+ * @param banks		Number of memory banks to create. If 0, the reg
+ *			property will be left untouched.
+ * @return 0 if ok, or -1 or -FDT_ERR_... on error
+ */
+#ifdef CONFIG_ARCH_FIXUP_FDT_MEMORY
+int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[], int banks);
+#else
+static inline int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[],
+					 int banks)
+{
+	return 0;
+}
+#endif
+
+void fdt_fixup_ethernet(void *fdt);
+int fdt_find_and_setprop(void *fdt, const char *node, const char *prop,
+			 const void *val, int len, int create);
+void fdt_fixup_qe_firmware(void *fdt);
+
+/**
+ * Update native-mode property of display-timings node to the phandle
+ * of the timings matching a display by name (case insensitive).
+ *
+ * see kernel Documentation/devicetree/bindings/video/display-timing.txt
+ *
+ * @param blob		FDT blob to update
+ * @param path		path within dt
+ * @param display	name of display timing to match
+ * @return 0 if ok, or -FDT_ERR_... on error
+ */
+int fdt_fixup_display(void *blob, const char *path, const char *display);
+
+#if defined(CONFIG_USB_EHCI_FSL) || defined(CONFIG_USB_XHCI_FSL)
+void fsl_fdt_fixup_dr_usb(void *blob, bd_t *bd);
+#else
+static inline void fsl_fdt_fixup_dr_usb(void *blob, bd_t *bd) {}
+#endif /* defined(CONFIG_USB_EHCI_FSL) || defined(CONFIG_USB_XHCI_FSL) */
+
+#if defined(CONFIG_SYS_FSL_SEC_COMPAT)
+void fdt_fixup_crypto_node(void *blob, int sec_rev);
+#else
+static inline void fdt_fixup_crypto_node(void *blob, int sec_rev) {}
+#endif
+
+/**
+ * Record information about a processed loadable in /fit-images (creating
+ * /fit-images if necessary).
+ *
+ * @param blob		FDT blob to update
+ * @param index	        index of this loadable
+ * @param name          name of the loadable
+ * @param load_addr     address the loadable was loaded to
+ * @param size          number of bytes loaded
+ * @param entry_point   entry point (if specified, otherwise pass -1)
+ * @param type          type (if specified, otherwise pass NULL)
+ * @param os            os-type (if specified, otherwise pass NULL)
+ * @return 0 if ok, or -1 or -FDT_ERR_... on error
+ */
+int fdt_record_loadable(void *blob, u32 index, const char *name,
+			uintptr_t load_addr, u32 size, uintptr_t entry_point,
+			const char *type, const char *os);
+
+#ifdef CONFIG_PCI
+#include <pci.h>
+int fdt_pci_dma_ranges(void *blob, int phb_off, struct pci_controller *hose);
+#endif
+
+int fdt_find_or_add_subnode(void *fdt, int parentoffset, const char *name);
+
+/**
+ * Add board-specific data to the FDT before booting the OS.
+ *
+ * Use CONFIG_SYS_FDT_PAD to ensure there is sufficient space.
+ * This function is called if CONFIG_OF_BOARD_SETUP is defined
+ *
+ * @param blob		FDT blob to update
+ * @param bd_t		Pointer to board data
+ * @return 0 if ok, or -FDT_ERR_... on error
+ */
+int ft_board_setup(void *blob, bd_t *bd);
+
+/*
+ * The keystone2 SOC requires all 32 bit aliased addresses to be converted
+ * to their 36 physical format. This has to happen after all fdt nodes
+ * are added or modified by the image_setup_libfdt(). The ft_board_setup_ex()
+ * called at the end of the image_setup_libfdt() is to do that convertion.
+ */
+void ft_board_setup_ex(void *blob, bd_t *bd);
+void ft_cpu_setup(void *blob, bd_t *bd);
+void ft_pci_setup(void *blob, bd_t *bd);
+
+/**
+ * Add system-specific data to the FDT before booting the OS.
+ *
+ * Use CONFIG_SYS_FDT_PAD to ensure there is sufficient space.
+ * This function is called if CONFIG_OF_SYSTEM_SETUP is defined
+ *
+ * @param blob		FDT blob to update
+ * @param bd_t		Pointer to board data
+ * @return 0 if ok, or -FDT_ERR_... on error
+ */
+int ft_system_setup(void *blob, bd_t *bd);
+
+void set_working_fdt_addr(ulong addr);
+
+/**
+ * shrink down the given blob to minimum size + some extrasize if required
+ *
+ * @param blob		FDT blob to update
+ * @param extrasize	additional bytes needed
+ * @return 0 if ok, or -FDT_ERR_... on error
+ */
+int fdt_shrink_to_minimum(void *blob, uint extrasize);
+int fdt_increase_size(void *fdt, int add_len);
+
+int fdt_fixup_nor_flash_size(void *blob);
+
+struct node_info;
+#if defined(CONFIG_FDT_FIXUP_PARTITIONS)
+void fdt_fixup_mtdparts(void *fdt, const struct node_info *node_info,
+			int node_info_size);
+#else
+static inline void fdt_fixup_mtdparts(void *fdt,
+				      const struct node_info *node_info,
+				      int node_info_size)
+{
+}
+#endif
+
+void fdt_del_node_and_alias(void *blob, const char *alias);
+u64 fdt_translate_address(const void *blob, int node_offset,
+			  const __be32 *in_addr);
+int fdt_node_offset_by_compat_reg(void *blob, const char *compat,
+					phys_addr_t compat_off);
+int fdt_alloc_phandle(void *blob);
+int fdt_set_phandle(void *fdt, int nodeoffset, uint32_t phandle);
+unsigned int fdt_create_phandle(void *fdt, int nodeoffset);
+int fdt_add_edid(void *blob, const char *compat, unsigned char *buf);
+
+int fdt_verify_alias_address(void *fdt, int anode, const char *alias,
+			      u64 addr);
+u64 fdt_get_base_address(const void *fdt, int node);
+int fdt_read_range(void *fdt, int node, int n, uint64_t *child_addr,
+		   uint64_t *addr, uint64_t *len);
+
+enum fdt_status {
+	FDT_STATUS_OKAY,
+	FDT_STATUS_DISABLED,
+	FDT_STATUS_FAIL,
+	FDT_STATUS_FAIL_ERROR_CODE,
+};
+int fdt_set_node_status(void *fdt, int nodeoffset,
+			enum fdt_status status, unsigned int error_code);
+static inline int fdt_status_okay(void *fdt, int nodeoffset)
+{
+	return fdt_set_node_status(fdt, nodeoffset, FDT_STATUS_OKAY, 0);
+}
+static inline int fdt_status_disabled(void *fdt, int nodeoffset)
+{
+	return fdt_set_node_status(fdt, nodeoffset, FDT_STATUS_DISABLED, 0);
+}
+static inline int fdt_status_fail(void *fdt, int nodeoffset)
+{
+	return fdt_set_node_status(fdt, nodeoffset, FDT_STATUS_FAIL, 0);
+}
+
+int fdt_set_status_by_alias(void *fdt, const char *alias,
+			    enum fdt_status status, unsigned int error_code);
+static inline int fdt_status_okay_by_alias(void *fdt, const char *alias)
+{
+	return fdt_set_status_by_alias(fdt, alias, FDT_STATUS_OKAY, 0);
+}
+static inline int fdt_status_disabled_by_alias(void *fdt, const char *alias)
+{
+	return fdt_set_status_by_alias(fdt, alias, FDT_STATUS_DISABLED, 0);
+}
+static inline int fdt_status_fail_by_alias(void *fdt, const char *alias)
+{
+	return fdt_set_status_by_alias(fdt, alias, FDT_STATUS_FAIL, 0);
+}
+
+/* Helper to read a big number; size is in cells (not bytes) */
+static inline u64 fdt_read_number(const fdt32_t *cell, int size)
+{
+	u64 r = 0;
+	while (size--)
+		r = (r << 32) | fdt32_to_cpu(*(cell++));
+	return r;
+}
+
+void fdt_support_default_count_cells(const void *blob, int parentoffset,
+					int *addrc, int *sizec);
+int ft_verify_fdt(void *fdt);
+int arch_fixup_memory_node(void *blob);
+
+int fdt_setup_simplefb_node(void *fdt, int node, u64 base_address, u32 width,
+			    u32 height, u32 stride, const char *format);
+
+int fdt_overlay_apply_verbose(void *fdt, void *fdto);
+
+/**
+ * fdt_get_cells_len() - Get the length of a type of cell in top-level nodes
+ *
+ * Returns the length of the cell type in bytes (4 or 8).
+ *
+ * @blob: Pointer to device tree blob
+ * @nr_cells_name: Name to lookup, e.g. "#address-cells"
+ */
+int fdt_get_cells_len(const void *blob, char *nr_cells_name);
+
+#endif /* ifdef CONFIG_OF_LIBFDT */
+
+#ifdef USE_HOSTCC
+int fdtdec_get_int(const void *blob, int node, const char *prop_name,
+		int default_val);
+#endif
+#ifdef CONFIG_FMAN_ENET
+int fdt_update_ethernet_dt(void *blob);
+#endif
+#ifdef CONFIG_FSL_MC_ENET
+void fdt_fixup_board_enet(void *blob);
+#endif
+//#endif /* ifndef __FDT_SUPPORT_H */
diff -urN u-boot-1.1.6/include/flash.h u-boot-1.1.6_fdt/include/flash.h
--- u-boot-1.1.6/include/flash.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/include/flash.h	2018-10-22 15:53:21.565641224 +0800
@@ -43,9 +43,18 @@
 	ulong	write_tout;		/* maximum write timeout		*/
 	ulong	buffer_write_tout;	/* maximum buffer write timeout		*/
 	ushort	vendor;			/* the primary vendor id		*/
-	ushort	cmd_reset;		/* Vendor specific reset command	*/
+	ushort	cmd_reset;		/* vendor specific reset command	*/
 	ushort	interface;		/* used for x8/x16 adjustments		*/
 	ushort	legacy_unlock;		/* support Intel legacy (un)locking	*/
+	uchar	manufacturer_id;	/* manufacturer id			*/
+	ushort	device_id;		/* device id				*/
+	ushort	device_id2;		/* extended device id			*/
+	ushort	ext_addr;		/* extended query table address		*/
+	ushort	cfi_version;		/* cfi version				*/
+	ushort	cfi_offset;		/* offset for cfi query			*/
+	ulong   addr_unlock1;		/* unlock address 1 for AMD flash roms  */
+	ulong   addr_unlock2;		/* unlock address 2 for AMD flash roms  */
+	const char *name;		/* human-readable name	                */
 #endif
 } flash_info_t;
 
@@ -71,6 +80,7 @@
 #define FLASH_CFI_X8		0x00
 #define FLASH_CFI_X16		0x01
 #define FLASH_CFI_X8X16		0x02
+#define FLASH_CFI_X16X32	0x05
 
 /* convert between bit value and numeric value */
 #define CFI_FLASH_SHIFT_WIDTH	3
@@ -95,6 +105,13 @@
 extern void flash_read_factory_serial(flash_info_t * info, void * buffer, int offset, int len);
 #endif	/* CFG_FLASH_PROTECTION */
 
+#ifdef CONFIG_FLASH_CFI_LEGACY
+extern ulong board_flash_get_legacy(ulong base, int banknum, flash_info_t *info);
+extern int jedec_flash_match(flash_info_t *info, ulong base);
+#define CFI_CMDSET_AMD_LEGACY		0xFFF0
+#endif
+
+
 /*-----------------------------------------------------------------------
  * return codes from flash_write():
  */
@@ -113,6 +130,11 @@
  */
 #define FLAG_PROTECT_SET	0x01
 #define FLAG_PROTECT_CLEAR	0x02
+#define	FLAG_PROTECT_INVALID	0x03
+/*-----------------------------------------------------------------------
+ * Set Environment according to label:
+ */
+#define	FLAG_SETENV		0x80
 
 /*-----------------------------------------------------------------------
  * Device IDs
@@ -246,6 +268,8 @@
 #define STM_ID_x800AB	0x005B005B	/* M29W800AB ID (8M = 512K x 16 )	*/
 #define STM_ID_29W320DT 0x22CA22CA	/* M29W320DT ID (32 M, top boot sector) */
 #define STM_ID_29W320DB 0x22CB22CB	/* M29W320DB ID (32 M, bottom boot sect)	*/
+#define STM_ID_29W320ET 0x22562256	/* M29W320ET ID (32 M, top boot sector) */
+#define STM_ID_29W320EB 0x22572257	/* M29W320EB ID (32 M, bottom boot sect)*/
 #define STM_ID_29W040B	0x00E300E3	/* M29W040B ID (4M = 512K x 8)	*/
 #define FLASH_PSD4256GV 0x00E9		/* PSD4256 Flash and CPLD combination	*/
 
@@ -298,6 +322,7 @@
 
 #define TOSH_ID_FVT160	0xC2		/* TC58FVT160 ID (16 M, top )		*/
 #define TOSH_ID_FVB160	0x43		/* TC58FVT160 ID (16 M, bottom )	*/
+#define PHILIPS_LPC2292 0x0401FF13  /* LPC2292 internal FLASH			*/
 
 /*-----------------------------------------------------------------------
  * Internal FLASH identification codes
@@ -439,6 +464,7 @@
 #define FLASH_MAN_MT	0x00400000
 #define FLASH_MAN_SHARP 0x00500000
 #define FLASH_MAN_ATM	0x00600000
+#define FLASH_MAN_CFI	0x01000000
 
 
 #define FLASH_TYPEMASK	0x0000FFFF	/* extract FLASH type	information	*/
diff -urN u-boot-1.1.6/include/libfdt_env.h u-boot-1.1.6_fdt/include/libfdt_env.h
--- u-boot-1.1.6/include/libfdt_env.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/include/libfdt_env.h	2018-10-22 16:39:09.869590521 +0800
@@ -0,0 +1,139 @@
+#ifndef LIBFDT_ENV_H
+#define LIBFDT_ENV_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ * Copyright 2012 Kim Phillips, Freescale Semiconductor.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stddef.h>
+#include <stdint.h>
+//#include <stdlib.h>
+//#include <string.h>
+
+#ifdef __CHECKER__
+#define FDT_FORCE __attribute__((force))
+#define FDT_BITWISE __attribute__((bitwise))
+#else
+#define FDT_FORCE
+#define FDT_BITWISE
+#endif
+
+typedef uint16_t FDT_BITWISE fdt16_t;
+typedef uint32_t FDT_BITWISE fdt32_t;
+typedef uint64_t FDT_BITWISE fdt64_t;
+
+#define EXTRACT_BYTE(x, n)	((unsigned long long)((uint8_t *)&x)[n])
+#define CPU_TO_FDT16(x) ((EXTRACT_BYTE(x, 0) << 8) | EXTRACT_BYTE(x, 1))
+#define CPU_TO_FDT32(x) ((EXTRACT_BYTE(x, 0) << 24) | (EXTRACT_BYTE(x, 1) << 16) | \
+			 (EXTRACT_BYTE(x, 2) << 8) | EXTRACT_BYTE(x, 3))
+#define CPU_TO_FDT64(x) ((EXTRACT_BYTE(x, 0) << 56) | (EXTRACT_BYTE(x, 1) << 48) | \
+			 (EXTRACT_BYTE(x, 2) << 40) | (EXTRACT_BYTE(x, 3) << 32) | \
+			 (EXTRACT_BYTE(x, 4) << 24) | (EXTRACT_BYTE(x, 5) << 16) | \
+			 (EXTRACT_BYTE(x, 6) << 8) | EXTRACT_BYTE(x, 7))
+
+static inline uint16_t fdt16_to_cpu(fdt16_t x)
+{
+	return (FDT_FORCE uint16_t)CPU_TO_FDT16(x);
+}
+static inline fdt16_t cpu_to_fdt16(uint16_t x)
+{
+	return (FDT_FORCE fdt16_t)CPU_TO_FDT16(x);
+}
+
+static inline uint32_t fdt32_to_cpu(fdt32_t x)
+{
+	return (FDT_FORCE uint32_t)CPU_TO_FDT32(x);
+}
+static inline fdt32_t cpu_to_fdt32(uint32_t x)
+{
+	return (FDT_FORCE fdt32_t)CPU_TO_FDT32(x);
+}
+
+static inline uint64_t fdt64_to_cpu(fdt64_t x)
+{
+	return (FDT_FORCE uint64_t)CPU_TO_FDT64(x);
+}
+static inline fdt64_t cpu_to_fdt64(uint64_t x)
+{
+	return (FDT_FORCE fdt64_t)CPU_TO_FDT64(x);
+}
+#undef CPU_TO_FDT64
+#undef CPU_TO_FDT32
+#undef CPU_TO_FDT16
+#undef EXTRACT_BYTE
+
+#ifdef __APPLE__
+#include <AvailabilityMacros.h>
+
+/* strnlen() is not available on Mac OS < 10.7 */
+# if !defined(MAC_OS_X_VERSION_10_7) || (MAC_OS_X_VERSION_MAX_ALLOWED < \
+                                         MAC_OS_X_VERSION_10_7)
+
+#define strnlen fdt_strnlen
+
+/*
+ * fdt_strnlen: returns the length of a string or max_count - which ever is
+ * smallest.
+ * Input 1 string: the string whose size is to be determined
+ * Input 2 max_count: the maximum value returned by this function
+ * Output: length of the string or max_count (the smallest of the two)
+ */
+static inline size_t fdt_strnlen(const char *string, size_t max_count)
+{
+    const char *p = memchr(string, 0, max_count);
+    return p ? p - string : max_count;
+}
+
+#endif /* !defined(MAC_OS_X_VERSION_10_7) || (MAC_OS_X_VERSION_MAX_ALLOWED <
+          MAC_OS_X_VERSION_10_7) */
+
+#endif /* __APPLE__ */
+
+#endif /* LIBFDT_ENV_H */
diff -urN u-boot-1.1.6/include/libfdt.h u-boot-1.1.6_fdt/include/libfdt.h
--- u-boot-1.1.6/include/libfdt.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/include/libfdt.h	2018-10-22 16:41:03.301588428 +0800
@@ -0,0 +1,1920 @@
+#ifndef LIBFDT_H
+#define LIBFDT_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/types.h>
+#include "libfdt_env.h"
+#include "fdt.h"
+
+
+#define int8_t		char
+#define int16_t		short
+#define int32_t		long
+#define int64_t		long long
+#define uint8_t		u_char
+#define uint16_t	u_short
+#define uint32_t	u_long
+#define uint64_t	unsigned long long
+#define t_scalar_t	int
+#define t_uscalar_t	unsigned int
+#define uintptr_t	unsigned long
+
+
+#define FDT_FIRST_SUPPORTED_VERSION	0x02
+#define FDT_LAST_SUPPORTED_VERSION	0x11
+
+/* Error codes: informative error codes */
+#define FDT_ERR_NOTFOUND	1
+	/* FDT_ERR_NOTFOUND: The requested node or property does not exist */
+#define FDT_ERR_EXISTS		2
+	/* FDT_ERR_EXISTS: Attempted to create a node or property which
+	 * already exists */
+#define FDT_ERR_NOSPACE		3
+	/* FDT_ERR_NOSPACE: Operation needed to expand the device
+	 * tree, but its buffer did not have sufficient space to
+	 * contain the expanded tree. Use fdt_open_into() to move the
+	 * device tree to a buffer with more space. */
+
+/* Error codes: codes for bad parameters */
+#define FDT_ERR_BADOFFSET	4
+	/* FDT_ERR_BADOFFSET: Function was passed a structure block
+	 * offset which is out-of-bounds, or which points to an
+	 * unsuitable part of the structure for the operation. */
+#define FDT_ERR_BADPATH		5
+	/* FDT_ERR_BADPATH: Function was passed a badly formatted path
+	 * (e.g. missing a leading / for a function which requires an
+	 * absolute path) */
+#define FDT_ERR_BADPHANDLE	6
+	/* FDT_ERR_BADPHANDLE: Function was passed an invalid phandle.
+	 * This can be caused either by an invalid phandle property
+	 * length, or the phandle value was either 0 or -1, which are
+	 * not permitted. */
+#define FDT_ERR_BADSTATE	7
+	/* FDT_ERR_BADSTATE: Function was passed an incomplete device
+	 * tree created by the sequential-write functions, which is
+	 * not sufficiently complete for the requested operation. */
+
+/* Error codes: codes for bad device tree blobs */
+#define FDT_ERR_TRUNCATED	8
+	/* FDT_ERR_TRUNCATED: Structure block of the given device tree
+	 * ends without an FDT_END tag. */
+#define FDT_ERR_BADMAGIC	9
+	/* FDT_ERR_BADMAGIC: Given "device tree" appears not to be a
+	 * device tree at all - it is missing the flattened device
+	 * tree magic number. */
+#define FDT_ERR_BADVERSION	10
+	/* FDT_ERR_BADVERSION: Given device tree has a version which
+	 * can't be handled by the requested operation.  For
+	 * read-write functions, this may mean that fdt_open_into() is
+	 * required to convert the tree to the expected version. */
+#define FDT_ERR_BADSTRUCTURE	11
+	/* FDT_ERR_BADSTRUCTURE: Given device tree has a corrupt
+	 * structure block or other serious error (e.g. misnested
+	 * nodes, or subnodes preceding properties). */
+#define FDT_ERR_BADLAYOUT	12
+	/* FDT_ERR_BADLAYOUT: For read-write functions, the given
+	 * device tree has it's sub-blocks in an order that the
+	 * function can't handle (memory reserve map, then structure,
+	 * then strings).  Use fdt_open_into() to reorganize the tree
+	 * into a form suitable for the read-write operations. */
+
+/* "Can't happen" error indicating a bug in libfdt */
+#define FDT_ERR_INTERNAL	13
+	/* FDT_ERR_INTERNAL: libfdt has failed an internal assertion.
+	 * Should never be returned, if it is, it indicates a bug in
+	 * libfdt itself. */
+
+/* Errors in device tree content */
+#define FDT_ERR_BADNCELLS	14
+	/* FDT_ERR_BADNCELLS: Device tree has a #address-cells, #size-cells
+	 * or similar property with a bad format or value */
+
+#define FDT_ERR_BADVALUE	15
+	/* FDT_ERR_BADVALUE: Device tree has a property with an unexpected
+	 * value. For example: a property expected to contain a string list
+	 * is not NUL-terminated within the length of its value. */
+
+#define FDT_ERR_BADOVERLAY	16
+	/* FDT_ERR_BADOVERLAY: The device tree overlay, while
+	 * correctly structured, cannot be applied due to some
+	 * unexpected or missing value, property or node. */
+
+#define FDT_ERR_NOPHANDLES	17
+	/* FDT_ERR_NOPHANDLES: The device tree doesn't have any
+	 * phandle available anymore without causing an overflow */
+
+#define FDT_ERR_MAX		17
+
+/**********************************************************************/
+/* Low-level functions (you probably don't need these)                */
+/**********************************************************************/
+
+#ifndef SWIG /* This function is not useful in Python */
+const void *fdt_offset_ptr(const void *fdt, int offset, unsigned int checklen);
+#endif
+static inline void *fdt_offset_ptr_w(void *fdt, int offset, int checklen)
+{
+	return (void *)(uintptr_t)fdt_offset_ptr(fdt, offset, checklen);
+}
+
+uint32_t fdt_next_tag(const void *fdt, int offset, int *nextoffset);
+
+/**********************************************************************/
+/* Traversal functions                                                */
+/**********************************************************************/
+
+int fdt_next_node(const void *fdt, int offset, int *depth);
+
+/**
+ * fdt_first_subnode() - get offset of first direct subnode
+ *
+ * @fdt:	FDT blob
+ * @offset:	Offset of node to check
+ * @return offset of first subnode, or -FDT_ERR_NOTFOUND if there is none
+ */
+int fdt_first_subnode(const void *fdt, int offset);
+
+/**
+ * fdt_next_subnode() - get offset of next direct subnode
+ *
+ * After first calling fdt_first_subnode(), call this function repeatedly to
+ * get direct subnodes of a parent node.
+ *
+ * @fdt:	FDT blob
+ * @offset:	Offset of previous subnode
+ * @return offset of next subnode, or -FDT_ERR_NOTFOUND if there are no more
+ * subnodes
+ */
+int fdt_next_subnode(const void *fdt, int offset);
+
+/**
+ * fdt_for_each_subnode - iterate over all subnodes of a parent
+ *
+ * @node:	child node (int, lvalue)
+ * @fdt:	FDT blob (const void *)
+ * @parent:	parent node (int)
+ *
+ * This is actually a wrapper around a for loop and would be used like so:
+ *
+ *	fdt_for_each_subnode(node, fdt, parent) {
+ *		Use node
+ *		...
+ *	}
+ *
+ *	if ((node < 0) && (node != -FDT_ERR_NOT_FOUND)) {
+ *		Error handling
+ *	}
+ *
+ * Note that this is implemented as a macro and @node is used as
+ * iterator in the loop. The parent variable be constant or even a
+ * literal.
+ *
+ */
+#define fdt_for_each_subnode(node, fdt, parent)		\
+	for (node = fdt_first_subnode(fdt, parent);	\
+	     node >= 0;					\
+	     node = fdt_next_subnode(fdt, node))
+
+/**********************************************************************/
+/* General functions                                                  */
+/**********************************************************************/
+#define fdt_get_header(fdt, field) \
+	(fdt32_to_cpu(((const struct fdt_header *)(fdt))->field))
+#define fdt_magic(fdt)			(fdt_get_header(fdt, magic))
+#define fdt_totalsize(fdt)		(fdt_get_header(fdt, totalsize))
+#define fdt_off_dt_struct(fdt)		(fdt_get_header(fdt, off_dt_struct))
+#define fdt_off_dt_strings(fdt)		(fdt_get_header(fdt, off_dt_strings))
+#define fdt_off_mem_rsvmap(fdt)		(fdt_get_header(fdt, off_mem_rsvmap))
+#define fdt_version(fdt)		(fdt_get_header(fdt, version))
+#define fdt_last_comp_version(fdt)	(fdt_get_header(fdt, last_comp_version))
+#define fdt_boot_cpuid_phys(fdt)	(fdt_get_header(fdt, boot_cpuid_phys))
+#define fdt_size_dt_strings(fdt)	(fdt_get_header(fdt, size_dt_strings))
+#define fdt_size_dt_struct(fdt)		(fdt_get_header(fdt, size_dt_struct))
+
+#define fdt_set_hdr_(name) \
+	static inline void fdt_set_##name(void *fdt, uint32_t val) \
+	{ \
+		struct fdt_header *fdth = (struct fdt_header *)fdt; \
+		fdth->name = cpu_to_fdt32(val); \
+	}
+fdt_set_hdr_(magic);
+fdt_set_hdr_(totalsize);
+fdt_set_hdr_(off_dt_struct);
+fdt_set_hdr_(off_dt_strings);
+fdt_set_hdr_(off_mem_rsvmap);
+fdt_set_hdr_(version);
+fdt_set_hdr_(last_comp_version);
+fdt_set_hdr_(boot_cpuid_phys);
+fdt_set_hdr_(size_dt_strings);
+fdt_set_hdr_(size_dt_struct);
+#undef fdt_set_hdr_
+
+/**
+ * fdt_check_header - sanity check a device tree or possible device tree
+ * @fdt: pointer to data which might be a flattened device tree
+ *
+ * fdt_check_header() checks that the given buffer contains what
+ * appears to be a flattened device tree with sane information in its
+ * header.
+ *
+ * returns:
+ *     0, if the buffer appears to contain a valid device tree
+ *     -FDT_ERR_BADMAGIC,
+ *     -FDT_ERR_BADVERSION,
+ *     -FDT_ERR_BADSTATE, standard meanings, as above
+ */
+int fdt_check_header(const void *fdt);
+
+/**
+ * fdt_move - move a device tree around in memory
+ * @fdt: pointer to the device tree to move
+ * @buf: pointer to memory where the device is to be moved
+ * @bufsize: size of the memory space at buf
+ *
+ * fdt_move() relocates, if possible, the device tree blob located at
+ * fdt to the buffer at buf of size bufsize.  The buffer may overlap
+ * with the existing device tree blob at fdt.  Therefore,
+ *     fdt_move(fdt, fdt, fdt_totalsize(fdt))
+ * should always succeed.
+ *
+ * returns:
+ *     0, on success
+ *     -FDT_ERR_NOSPACE, bufsize is insufficient to contain the device tree
+ *     -FDT_ERR_BADMAGIC,
+ *     -FDT_ERR_BADVERSION,
+ *     -FDT_ERR_BADSTATE, standard meanings
+ */
+int fdt_move(const void *fdt, void *buf, int bufsize);
+
+/**********************************************************************/
+/* Read-only functions                                                */
+/**********************************************************************/
+
+/**
+ * fdt_string - retrieve a string from the strings block of a device tree
+ * @fdt: pointer to the device tree blob
+ * @stroffset: offset of the string within the strings block (native endian)
+ *
+ * fdt_string() retrieves a pointer to a single string from the
+ * strings block of the device tree blob at fdt.
+ *
+ * returns:
+ *     a pointer to the string, on success
+ *     NULL, if stroffset is out of bounds
+ */
+const char *fdt_string(const void *fdt, int stroffset);
+
+/**
+ * fdt_get_max_phandle - retrieves the highest phandle in a tree
+ * @fdt: pointer to the device tree blob
+ *
+ * fdt_get_max_phandle retrieves the highest phandle in the given
+ * device tree. This will ignore badly formatted phandles, or phandles
+ * with a value of 0 or -1.
+ *
+ * returns:
+ *      the highest phandle on success
+ *      0, if no phandle was found in the device tree
+ *      -1, if an error occurred
+ */
+uint32_t fdt_get_max_phandle(const void *fdt);
+
+/**
+ * fdt_num_mem_rsv - retrieve the number of memory reserve map entries
+ * @fdt: pointer to the device tree blob
+ *
+ * Returns the number of entries in the device tree blob's memory
+ * reservation map.  This does not include the terminating 0,0 entry
+ * or any other (0,0) entries reserved for expansion.
+ *
+ * returns:
+ *     the number of entries
+ */
+int fdt_num_mem_rsv(const void *fdt);
+
+/**
+ * fdt_get_mem_rsv - retrieve one memory reserve map entry
+ * @fdt: pointer to the device tree blob
+ * @address, @size: pointers to 64-bit variables
+ *
+ * On success, *address and *size will contain the address and size of
+ * the n-th reserve map entry from the device tree blob, in
+ * native-endian format.
+ *
+ * returns:
+ *     0, on success
+ *     -FDT_ERR_BADMAGIC,
+ *     -FDT_ERR_BADVERSION,
+ *     -FDT_ERR_BADSTATE, standard meanings
+ */
+int fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size);
+
+/**
+ * fdt_subnode_offset_namelen - find a subnode based on substring
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ * @namelen: number of characters of name to consider
+ *
+ * Identical to fdt_subnode_offset(), but only examine the first
+ * namelen characters of name for matching the subnode name.  This is
+ * useful for finding subnodes based on a portion of a larger string,
+ * such as a full path.
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_subnode_offset_namelen(const void *fdt, int parentoffset,
+			       const char *name, int namelen);
+#endif
+/**
+ * fdt_subnode_offset - find a subnode of a given node
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ *
+ * fdt_subnode_offset() finds a subnode of the node at structure block
+ * offset parentoffset with the given name.  name may include a unit
+ * address, in which case fdt_subnode_offset() will find the subnode
+ * with that unit address, or the unit address may be omitted, in
+ * which case fdt_subnode_offset() will find an arbitrary subnode
+ * whose name excluding unit address matches the given name.
+ *
+ * returns:
+ *	structure block offset of the requested subnode (>=0), on success
+ *	-FDT_ERR_NOTFOUND, if the requested subnode does not exist
+ *	-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE
+ *		tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_subnode_offset(const void *fdt, int parentoffset, const char *name);
+
+/**
+ * fdt_path_offset_namelen - find a tree node by its full path
+ * @fdt: pointer to the device tree blob
+ * @path: full path of the node to locate
+ * @namelen: number of characters of path to consider
+ *
+ * Identical to fdt_path_offset(), but only consider the first namelen
+ * characters of path as the path name.
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_path_offset_namelen(const void *fdt, const char *path, int namelen);
+#endif
+
+/**
+ * fdt_path_offset - find a tree node by its full path
+ * @fdt: pointer to the device tree blob
+ * @path: full path of the node to locate
+ *
+ * fdt_path_offset() finds a node of a given path in the device tree.
+ * Each path component may omit the unit address portion, but the
+ * results of this are undefined if any such path component is
+ * ambiguous (that is if there are multiple nodes at the relevant
+ * level matching the given component, differentiated only by unit
+ * address).
+ *
+ * returns:
+ *	structure block offset of the node with the requested path (>=0), on
+ *		success
+ *	-FDT_ERR_BADPATH, given path does not begin with '/' or is invalid
+ *	-FDT_ERR_NOTFOUND, if the requested node does not exist
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_path_offset(const void *fdt, const char *path);
+
+/**
+ * fdt_get_name - retrieve the name of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of the starting node
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_get_name() retrieves the name (including unit address) of the
+ * device tree node at structure block offset nodeoffset.  If lenp is
+ * non-NULL, the length of this name is also returned, in the integer
+ * pointed to by lenp.
+ *
+ * returns:
+ *	pointer to the node's name, on success
+ *		If lenp is non-NULL, *lenp contains the length of that name
+ *			(>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL *lenp contains an error code (<0):
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE
+ *			tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE, standard meanings
+ */
+const char *fdt_get_name(const void *fdt, int nodeoffset, int *lenp);
+
+/**
+ * fdt_first_property_offset - find the offset of a node's first property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of a node
+ *
+ * fdt_first_property_offset() finds the first property of the node at
+ * the given structure block offset.
+ *
+ * returns:
+ *	structure block offset of the property (>=0), on success
+ *	-FDT_ERR_NOTFOUND, if the requested node has no properties
+ *	-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_BEGIN_NODE tag
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_first_property_offset(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_next_property_offset - step through a node's properties
+ * @fdt: pointer to the device tree blob
+ * @offset: structure block offset of a property
+ *
+ * fdt_next_property_offset() finds the property immediately after the
+ * one at the given structure block offset.  This will be a property
+ * of the same node as the given property.
+ *
+ * returns:
+ *	structure block offset of the next property (>=0), on success
+ *	-FDT_ERR_NOTFOUND, if the given property is the last in its node
+ *	-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_PROP tag
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_next_property_offset(const void *fdt, int offset);
+
+/**
+ * fdt_for_each_property_offset - iterate over all properties of a node
+ *
+ * @property_offset:	property offset (int, lvalue)
+ * @fdt:		FDT blob (const void *)
+ * @node:		node offset (int)
+ *
+ * This is actually a wrapper around a for loop and would be used like so:
+ *
+ *	fdt_for_each_property_offset(property, fdt, node) {
+ *		Use property
+ *		...
+ *	}
+ *
+ *	if ((property < 0) && (property != -FDT_ERR_NOT_FOUND)) {
+ *		Error handling
+ *	}
+ *
+ * Note that this is implemented as a macro and property is used as
+ * iterator in the loop. The node variable can be constant or even a
+ * literal.
+ */
+#define fdt_for_each_property_offset(property, fdt, node)	\
+	for (property = fdt_first_property_offset(fdt, node);	\
+	     property >= 0;					\
+	     property = fdt_next_property_offset(fdt, property))
+
+/**
+ * fdt_get_property_by_offset - retrieve the property at a given offset
+ * @fdt: pointer to the device tree blob
+ * @offset: offset of the property to retrieve
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_get_property_by_offset() retrieves a pointer to the
+ * fdt_property structure within the device tree blob at the given
+ * offset.  If lenp is non-NULL, the length of the property value is
+ * also returned, in the integer pointed to by lenp.
+ *
+ * Note that this code only works on device tree versions >= 16. fdt_getprop()
+ * works on all versions.
+ *
+ * returns:
+ *	pointer to the structure representing the property
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+const struct fdt_property *fdt_get_property_by_offset(const void *fdt,
+						      int offset,
+						      int *lenp);
+
+/**
+ * fdt_get_property_namelen - find a property based on substring
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @namelen: number of characters of name to consider
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * Identical to fdt_get_property(), but only examine the first namelen
+ * characters of name for matching the property name.
+ */
+#ifndef SWIG /* Not available in Python */
+const struct fdt_property *fdt_get_property_namelen(const void *fdt,
+						    int nodeoffset,
+						    const char *name,
+						    int namelen, int *lenp);
+#endif
+
+/**
+ * fdt_get_property - find a given property in a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_get_property() retrieves a pointer to the fdt_property
+ * structure within the device tree blob corresponding to the property
+ * named 'name' of the node at offset nodeoffset.  If lenp is
+ * non-NULL, the length of the property value is also returned, in the
+ * integer pointed to by lenp.
+ *
+ * returns:
+ *	pointer to the structure representing the property
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_NOTFOUND, node does not have named property
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE
+ *			tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+const struct fdt_property *fdt_get_property(const void *fdt, int nodeoffset,
+					    const char *name, int *lenp);
+static inline struct fdt_property *fdt_get_property_w(void *fdt, int nodeoffset,
+						      const char *name,
+						      int *lenp)
+{
+	return (struct fdt_property *)(uintptr_t)
+		fdt_get_property(fdt, nodeoffset, name, lenp);
+}
+
+/**
+ * fdt_getprop_by_offset - retrieve the value of a property at a given offset
+ * @fdt: pointer to the device tree blob
+ * @ffset: offset of the property to read
+ * @namep: pointer to a string variable (will be overwritten) or NULL
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_getprop_by_offset() retrieves a pointer to the value of the
+ * property at structure block offset 'offset' (this will be a pointer
+ * to within the device blob itself, not a copy of the value).  If
+ * lenp is non-NULL, the length of the property value is also
+ * returned, in the integer pointed to by lenp.  If namep is non-NULL,
+ * the property's namne will also be returned in the char * pointed to
+ * by namep (this will be a pointer to within the device tree's string
+ * block, not a new copy of the name).
+ *
+ * returns:
+ *	pointer to the property's value
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *		if namep is non-NULL *namep contiains a pointer to the property
+ *		name.
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+#ifndef SWIG /* This function is not useful in Python */
+const void *fdt_getprop_by_offset(const void *fdt, int offset,
+				  const char **namep, int *lenp);
+#endif
+
+/**
+ * fdt_getprop_namelen - get property value based on substring
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @namelen: number of characters of name to consider
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * Identical to fdt_getprop(), but only examine the first namelen
+ * characters of name for matching the property name.
+ */
+#ifndef SWIG /* Not available in Python */
+const void *fdt_getprop_namelen(const void *fdt, int nodeoffset,
+				const char *name, int namelen, int *lenp);
+static inline void *fdt_getprop_namelen_w(void *fdt, int nodeoffset,
+					  const char *name, int namelen,
+					  int *lenp)
+{
+	return (void *)(uintptr_t)fdt_getprop_namelen(fdt, nodeoffset, name,
+						      namelen, lenp);
+}
+#endif
+
+/**
+ * fdt_getprop - retrieve the value of a given property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_getprop() retrieves a pointer to the value of the property
+ * named 'name' of the node at offset nodeoffset (this will be a
+ * pointer to within the device blob itself, not a copy of the value).
+ * If lenp is non-NULL, the length of the property value is also
+ * returned, in the integer pointed to by lenp.
+ *
+ * returns:
+ *	pointer to the property's value
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_NOTFOUND, node does not have named property
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE
+ *			tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+const void *fdt_getprop(const void *fdt, int nodeoffset,
+			const char *name, int *lenp);
+static inline void *fdt_getprop_w(void *fdt, int nodeoffset,
+				  const char *name, int *lenp)
+{
+	return (void *)(uintptr_t)fdt_getprop(fdt, nodeoffset, name, lenp);
+}
+
+/**
+ * fdt_get_phandle - retrieve the phandle of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of the node
+ *
+ * fdt_get_phandle() retrieves the phandle of the device tree node at
+ * structure block offset nodeoffset.
+ *
+ * returns:
+ *	the phandle of the node at nodeoffset, on success (!= 0, != -1)
+ *	0, if the node has no phandle, or another error occurs
+ */
+uint32_t fdt_get_phandle(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_get_alias_namelen - get alias based on substring
+ * @fdt: pointer to the device tree blob
+ * @name: name of the alias th look up
+ * @namelen: number of characters of name to consider
+ *
+ * Identical to fdt_get_alias(), but only examine the first namelen
+ * characters of name for matching the alias name.
+ */
+#ifndef SWIG /* Not available in Python */
+const char *fdt_get_alias_namelen(const void *fdt,
+				  const char *name, int namelen);
+#endif
+
+/**
+ * fdt_get_alias - retrieve the path referenced by a given alias
+ * @fdt: pointer to the device tree blob
+ * @name: name of the alias th look up
+ *
+ * fdt_get_alias() retrieves the value of a given alias.  That is, the
+ * value of the property named 'name' in the node /aliases.
+ *
+ * returns:
+ *	a pointer to the expansion of the alias named 'name', if it exists
+ *	NULL, if the given alias or the /aliases node does not exist
+ */
+const char *fdt_get_alias(const void *fdt, const char *name);
+
+/**
+ * fdt_get_path - determine the full path of a node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose path to find
+ * @buf: character buffer to contain the returned path (will be overwritten)
+ * @buflen: size of the character buffer at buf
+ *
+ * fdt_get_path() computes the full path of the node at offset
+ * nodeoffset, and records that path in the buffer at buf.
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset.
+ *
+ * returns:
+ *	0, on success
+ *		buf contains the absolute path of the node at
+ *		nodeoffset, as a NUL-terminated string.
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_NOSPACE, the path of the given node is longer than (bufsize-1)
+ *		characters and will not fit in the given buffer.
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_get_path(const void *fdt, int nodeoffset, char *buf, int buflen);
+
+/**
+ * fdt_supernode_atdepth_offset - find a specific ancestor of a node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose parent to find
+ * @supernodedepth: depth of the ancestor to find
+ * @nodedepth: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_supernode_atdepth_offset() finds an ancestor of the given node
+ * at a specific depth from the root (where the root itself has depth
+ * 0, its immediate subnodes depth 1 and so forth).  So
+ *	fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, NULL);
+ * will always return 0, the offset of the root node.  If the node at
+ * nodeoffset has depth D, then:
+ *	fdt_supernode_atdepth_offset(fdt, nodeoffset, D, NULL);
+ * will return nodeoffset itself.
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset.
+ *
+ * returns:
+ *	structure block offset of the node at node offset's ancestor
+ *		of depth supernodedepth (>=0), on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_NOTFOUND, supernodedepth was greater than the depth of
+ *		nodeoffset
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_supernode_atdepth_offset(const void *fdt, int nodeoffset,
+				 int supernodedepth, int *nodedepth);
+
+/**
+ * fdt_node_depth - find the depth of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose parent to find
+ *
+ * fdt_node_depth() finds the depth of a given node.  The root node
+ * has depth 0, its immediate subnodes depth 1 and so forth.
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset.
+ *
+ * returns:
+ *	depth of the node at nodeoffset (>=0), on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_depth(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_parent_offset - find the parent of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose parent to find
+ *
+ * fdt_parent_offset() locates the parent node of a given node (that
+ * is, it finds the offset of the node which contains the node at
+ * nodeoffset as a subnode).
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset, *twice*.
+ *
+ * returns:
+ *	structure block offset of the parent of the node at nodeoffset
+ *		(>=0), on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_parent_offset(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_node_offset_by_prop_value - find nodes with a given property value
+ * @fdt: pointer to the device tree blob
+ * @startoffset: only find nodes after this offset
+ * @propname: property name to check
+ * @propval: property value to search for
+ * @proplen: length of the value in propval
+ *
+ * fdt_node_offset_by_prop_value() returns the offset of the first
+ * node after startoffset, which has a property named propname whose
+ * value is of length proplen and has value equal to propval; or if
+ * startoffset is -1, the very first such node in the tree.
+ *
+ * To iterate through all nodes matching the criterion, the following
+ * idiom can be used:
+ *	offset = fdt_node_offset_by_prop_value(fdt, -1, propname,
+ *					       propval, proplen);
+ *	while (offset != -FDT_ERR_NOTFOUND) {
+ *		// other code here
+ *		offset = fdt_node_offset_by_prop_value(fdt, offset, propname,
+ *						       propval, proplen);
+ *	}
+ *
+ * Note the -1 in the first call to the function, if 0 is used here
+ * instead, the function will never locate the root node, even if it
+ * matches the criterion.
+ *
+ * returns:
+ *	structure block offset of the located node (>= 0, >startoffset),
+ *		 on success
+ *	-FDT_ERR_NOTFOUND, no node matching the criterion exists in the
+ *		tree after startoffset
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_offset_by_prop_value(const void *fdt, int startoffset,
+				  const char *propname,
+				  const void *propval, int proplen);
+
+/**
+ * fdt_node_offset_by_phandle - find the node with a given phandle
+ * @fdt: pointer to the device tree blob
+ * @phandle: phandle value
+ *
+ * fdt_node_offset_by_phandle() returns the offset of the node
+ * which has the given phandle value.  If there is more than one node
+ * in the tree with the given phandle (an invalid tree), results are
+ * undefined.
+ *
+ * returns:
+ *	structure block offset of the located node (>= 0), on success
+ *	-FDT_ERR_NOTFOUND, no node with that phandle exists
+ *	-FDT_ERR_BADPHANDLE, given phandle value was invalid (0 or -1)
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle);
+
+/**
+ * fdt_node_check_compatible: check a node's compatible property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @compatible: string to match against
+ *
+ *
+ * fdt_node_check_compatible() returns 0 if the given node contains a
+ * 'compatible' property with the given string as one of its elements,
+ * it returns non-zero otherwise, or on error.
+ *
+ * returns:
+ *	0, if the node has a 'compatible' property listing the given string
+ *	1, if the node has a 'compatible' property, but it does not list
+ *		the given string
+ *	-FDT_ERR_NOTFOUND, if the given node has no 'compatible' property
+ *	-FDT_ERR_BADOFFSET, if nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_check_compatible(const void *fdt, int nodeoffset,
+			      const char *compatible);
+
+/**
+ * fdt_node_offset_by_compatible - find nodes with a given 'compatible' value
+ * @fdt: pointer to the device tree blob
+ * @startoffset: only find nodes after this offset
+ * @compatible: 'compatible' string to match against
+ *
+ * fdt_node_offset_by_compatible() returns the offset of the first
+ * node after startoffset, which has a 'compatible' property which
+ * lists the given compatible string; or if startoffset is -1, the
+ * very first such node in the tree.
+ *
+ * To iterate through all nodes matching the criterion, the following
+ * idiom can be used:
+ *	offset = fdt_node_offset_by_compatible(fdt, -1, compatible);
+ *	while (offset != -FDT_ERR_NOTFOUND) {
+ *		// other code here
+ *		offset = fdt_node_offset_by_compatible(fdt, offset, compatible);
+ *	}
+ *
+ * Note the -1 in the first call to the function, if 0 is used here
+ * instead, the function will never locate the root node, even if it
+ * matches the criterion.
+ *
+ * returns:
+ *	structure block offset of the located node (>= 0, >startoffset),
+ *		 on success
+ *	-FDT_ERR_NOTFOUND, no node matching the criterion exists in the
+ *		tree after startoffset
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_offset_by_compatible(const void *fdt, int startoffset,
+				  const char *compatible);
+
+/**
+ * fdt_stringlist_contains - check a string list property for a string
+ * @strlist: Property containing a list of strings to check
+ * @listlen: Length of property
+ * @str: String to search for
+ *
+ * This is a utility function provided for convenience. The list contains
+ * one or more strings, each terminated by \0, as is found in a device tree
+ * "compatible" property.
+ *
+ * @return: 1 if the string is found in the list, 0 not found, or invalid list
+ */
+int fdt_stringlist_contains(const char *strlist, int listlen, const char *str);
+
+/**
+ * fdt_stringlist_count - count the number of strings in a string list
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @property: name of the property containing the string list
+ * @return:
+ *   the number of strings in the given property
+ *   -FDT_ERR_BADVALUE if the property value is not NUL-terminated
+ *   -FDT_ERR_NOTFOUND if the property does not exist
+ */
+int fdt_stringlist_count(const void *fdt, int nodeoffset, const char *property);
+
+/**
+ * fdt_stringlist_search - find a string in a string list and return its index
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @property: name of the property containing the string list
+ * @string: string to look up in the string list
+ *
+ * Note that it is possible for this function to succeed on property values
+ * that are not NUL-terminated. That's because the function will stop after
+ * finding the first occurrence of @string. This can for example happen with
+ * small-valued cell properties, such as #address-cells, when searching for
+ * the empty string.
+ *
+ * @return:
+ *   the index of the string in the list of strings
+ *   -FDT_ERR_BADVALUE if the property value is not NUL-terminated
+ *   -FDT_ERR_NOTFOUND if the property does not exist or does not contain
+ *                     the given string
+ */
+int fdt_stringlist_search(const void *fdt, int nodeoffset, const char *property,
+			  const char *string);
+
+/**
+ * fdt_stringlist_get() - obtain the string at a given index in a string list
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @property: name of the property containing the string list
+ * @index: index of the string to return
+ * @lenp: return location for the string length or an error code on failure
+ *
+ * Note that this will successfully extract strings from properties with
+ * non-NUL-terminated values. For example on small-valued cell properties
+ * this function will return the empty string.
+ *
+ * If non-NULL, the length of the string (on success) or a negative error-code
+ * (on failure) will be stored in the integer pointer to by lenp.
+ *
+ * @return:
+ *   A pointer to the string at the given index in the string list or NULL on
+ *   failure. On success the length of the string will be stored in the memory
+ *   location pointed to by the lenp parameter, if non-NULL. On failure one of
+ *   the following negative error codes will be returned in the lenp parameter
+ *   (if non-NULL):
+ *     -FDT_ERR_BADVALUE if the property value is not NUL-terminated
+ *     -FDT_ERR_NOTFOUND if the property does not exist
+ */
+const char *fdt_stringlist_get(const void *fdt, int nodeoffset,
+			       const char *property, int index,
+			       int *lenp);
+
+/**********************************************************************/
+/* Read-only functions (addressing related)                           */
+/**********************************************************************/
+
+/**
+ * FDT_MAX_NCELLS - maximum value for #address-cells and #size-cells
+ *
+ * This is the maximum value for #address-cells, #size-cells and
+ * similar properties that will be processed by libfdt.  IEE1275
+ * requires that OF implementations handle values up to 4.
+ * Implementations may support larger values, but in practice higher
+ * values aren't used.
+ */
+#define FDT_MAX_NCELLS		4
+
+/**
+ * fdt_address_cells - retrieve address size for a bus represented in the tree
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to find the address size for
+ *
+ * When the node has a valid #address-cells property, returns its value.
+ *
+ * returns:
+ *	0 <= n < FDT_MAX_NCELLS, on success
+ *      2, if the node has no #address-cells property
+ *      -FDT_ERR_BADNCELLS, if the node has a badly formatted or invalid
+ *		#address-cells property
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_address_cells(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_size_cells - retrieve address range size for a bus represented in the
+ *                  tree
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to find the address range size for
+ *
+ * When the node has a valid #size-cells property, returns its value.
+ *
+ * returns:
+ *	0 <= n < FDT_MAX_NCELLS, on success
+ *      2, if the node has no #address-cells property
+ *      -FDT_ERR_BADNCELLS, if the node has a badly formatted or invalid
+ *		#size-cells property
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_size_cells(const void *fdt, int nodeoffset);
+
+
+/**********************************************************************/
+/* Write-in-place functions                                           */
+/**********************************************************************/
+
+/**
+ * fdt_setprop_inplace_namelen_partial - change a property's value,
+ *                                       but not its size
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @namelen: number of characters of name to consider
+ * @idx: index of the property to change in the array
+ * @val: pointer to data to replace the property value with
+ * @len: length of the property value
+ *
+ * Identical to fdt_setprop_inplace(), but modifies the given property
+ * starting from the given index, and using only the first characters
+ * of the name. It is useful when you want to manipulate only one value of
+ * an array and you have a string that doesn't end with \0.
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_setprop_inplace_namelen_partial(void *fdt, int nodeoffset,
+					const char *name, int namelen,
+					uint32_t idx, const void *val,
+					int len);
+#endif
+
+/**
+ * fdt_setprop_inplace - change a property's value, but not its size
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: pointer to data to replace the property value with
+ * @len: length of the property value
+ *
+ * fdt_setprop_inplace() replaces the value of a given property with
+ * the data in val, of length len.  This function cannot change the
+ * size of a property, and so will only work if len is equal to the
+ * current length of the property.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the given property value, and will not alter or move any other part
+ * of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, if len is not equal to the property's current length
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_setprop_inplace(void *fdt, int nodeoffset, const char *name,
+			const void *val, int len);
+#endif
+
+/**
+ * fdt_setprop_inplace_u32 - change the value of a 32-bit integer property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 32-bit integer value to replace the property with
+ *
+ * fdt_setprop_inplace_u32() replaces the value of a given property
+ * with the 32-bit integer value in val, converting val to big-endian
+ * if necessary.  This function cannot change the size of a property,
+ * and so will only work if the property already exists and has length
+ * 4.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the given property value, and will not alter or move any other part
+ * of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, if the property's length is not equal to 4
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_inplace_u32(void *fdt, int nodeoffset,
+					  const char *name, uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_setprop_inplace(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_inplace_u64 - change the value of a 64-bit integer property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 64-bit integer value to replace the property with
+ *
+ * fdt_setprop_inplace_u64() replaces the value of a given property
+ * with the 64-bit integer value in val, converting val to big-endian
+ * if necessary.  This function cannot change the size of a property,
+ * and so will only work if the property already exists and has length
+ * 8.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the given property value, and will not alter or move any other part
+ * of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, if the property's length is not equal to 8
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_inplace_u64(void *fdt, int nodeoffset,
+					  const char *name, uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_setprop_inplace(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_inplace_cell - change the value of a single-cell property
+ *
+ * This is an alternative name for fdt_setprop_inplace_u32()
+ */
+static inline int fdt_setprop_inplace_cell(void *fdt, int nodeoffset,
+					   const char *name, uint32_t val)
+{
+	return fdt_setprop_inplace_u32(fdt, nodeoffset, name, val);
+}
+
+/**
+ * fdt_nop_property - replace a property with nop tags
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to nop
+ * @name: name of the property to nop
+ *
+ * fdt_nop_property() will replace a given property's representation
+ * in the blob with FDT_NOP tags, effectively removing it from the
+ * tree.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the property, and will not alter or move any other part of the
+ * tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_nop_property(void *fdt, int nodeoffset, const char *name);
+
+/**
+ * fdt_nop_node - replace a node (subtree) with nop tags
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to nop
+ *
+ * fdt_nop_node() will replace a given node's representation in the
+ * blob, including all its subnodes, if any, with FDT_NOP tags,
+ * effectively removing it from the tree.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the node and its properties and subnodes, and will not alter or
+ * move any other part of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_nop_node(void *fdt, int nodeoffset);
+
+/**********************************************************************/
+/* Sequential write functions                                         */
+/**********************************************************************/
+
+int fdt_create(void *buf, int bufsize);
+int fdt_resize(void *fdt, void *buf, int bufsize);
+int fdt_add_reservemap_entry(void *fdt, uint64_t addr, uint64_t size);
+int fdt_finish_reservemap(void *fdt);
+int fdt_begin_node(void *fdt, const char *name);
+int fdt_property(void *fdt, const char *name, const void *val, int len);
+static inline int fdt_property_u32(void *fdt, const char *name, uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_property(fdt, name, &tmp, sizeof(tmp));
+}
+static inline int fdt_property_u64(void *fdt, const char *name, uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_property(fdt, name, &tmp, sizeof(tmp));
+}
+
+#ifndef SWIG /* Not available in Python */
+static inline int fdt_property_cell(void *fdt, const char *name, uint32_t val)
+{
+	return fdt_property_u32(fdt, name, val);
+}
+#endif
+
+/**
+ * fdt_property_placeholder - add a new property and return a ptr to its value
+ *
+ * @fdt: pointer to the device tree blob
+ * @name: name of property to add
+ * @len: length of property value in bytes
+ * @valp: returns a pointer to where where the value should be placed
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_NOSPACE, standard meanings
+ */
+int fdt_property_placeholder(void *fdt, const char *name, int len, void **valp);
+
+#define fdt_property_string(fdt, name, str) \
+	fdt_property(fdt, name, str, strlen(str)+1)
+int fdt_end_node(void *fdt);
+int fdt_finish(void *fdt);
+
+/**********************************************************************/
+/* Read-write functions                                               */
+/**********************************************************************/
+
+int fdt_create_empty_tree(void *buf, int bufsize);
+int fdt_open_into(const void *fdt, void *buf, int bufsize);
+int fdt_pack(void *fdt);
+
+/**
+ * fdt_add_mem_rsv - add one memory reserve map entry
+ * @fdt: pointer to the device tree blob
+ * @address, @size: 64-bit values (native endian)
+ *
+ * Adds a reserve map entry to the given blob reserving a region at
+ * address address of length size.
+ *
+ * This function will insert data into the reserve map and will
+ * therefore change the indexes of some entries in the table.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new reservation entry
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_add_mem_rsv(void *fdt, uint64_t address, uint64_t size);
+
+/**
+ * fdt_del_mem_rsv - remove a memory reserve map entry
+ * @fdt: pointer to the device tree blob
+ * @n: entry to remove
+ *
+ * fdt_del_mem_rsv() removes the n-th memory reserve map entry from
+ * the blob.
+ *
+ * This function will delete data from the reservation table and will
+ * therefore change the indexes of some entries in the table.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOTFOUND, there is no entry of the given index (i.e. there
+ *		are less than n+1 reserve map entries)
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_del_mem_rsv(void *fdt, int n);
+
+/**
+ * fdt_set_name - change the name of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of a node
+ * @name: name to give the node
+ *
+ * fdt_set_name() replaces the name (including unit address, if any)
+ * of the given node with the given string.  NOTE: this function can't
+ * efficiently check if the new name is unique amongst the given
+ * node's siblings; results are undefined if this function is invoked
+ * with a name equal to one of the given node's siblings.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob
+ *		to contain the new name
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE, standard meanings
+ */
+int fdt_set_name(void *fdt, int nodeoffset, const char *name);
+
+/**
+ * fdt_setprop - create or change a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: pointer to data to set the property value to
+ * @len: length of the property value
+ *
+ * fdt_setprop() sets the value of the named property in the given
+ * node to the given value and length, creating the property if it
+ * does not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_setprop(void *fdt, int nodeoffset, const char *name,
+		const void *val, int len);
+
+/**
+ * fdt_setprop_placeholder - allocate space for a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @len: length of the property value
+ * @prop_data: return pointer to property data
+ *
+ * fdt_setprop_placeholer() allocates the named property in the given node.
+ * If the property exists it is resized. In either case a pointer to the
+ * property data is returned.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_setprop_placeholder(void *fdt, int nodeoffset, const char *name,
+			    int len, void **prop_data);
+
+/**
+ * fdt_setprop_u32 - set a property to a 32-bit integer
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 32-bit integer value for the property (native endian)
+ *
+ * fdt_setprop_u32() sets the value of the named property in the given
+ * node to the given 32-bit integer value (converting to big-endian if
+ * necessary), or creates a new property with that value if it does
+ * not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_u32(void *fdt, int nodeoffset, const char *name,
+				  uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_setprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_u64 - set a property to a 64-bit integer
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 64-bit integer value for the property (native endian)
+ *
+ * fdt_setprop_u64() sets the value of the named property in the given
+ * node to the given 64-bit integer value (converting to big-endian if
+ * necessary), or creates a new property with that value if it does
+ * not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_u64(void *fdt, int nodeoffset, const char *name,
+				  uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_setprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_cell - set a property to a single cell value
+ *
+ * This is an alternative name for fdt_setprop_u32()
+ */
+static inline int fdt_setprop_cell(void *fdt, int nodeoffset, const char *name,
+				   uint32_t val)
+{
+	return fdt_setprop_u32(fdt, nodeoffset, name, val);
+}
+
+/**
+ * fdt_setprop_string - set a property to a string value
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @str: string value for the property
+ *
+ * fdt_setprop_string() sets the value of the named property in the
+ * given node to the given string value (using the length of the
+ * string to determine the new length of the property), or creates a
+ * new property with that value if it does not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#define fdt_setprop_string(fdt, nodeoffset, name, str) \
+	fdt_setprop((fdt), (nodeoffset), (name), (str), strlen(str)+1)
+
+
+/**
+ * fdt_setprop_empty - set a property to an empty value
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ *
+ * fdt_setprop_empty() sets the value of the named property in the
+ * given node to an empty (zero length) value, or creates a new empty
+ * property if it does not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#define fdt_setprop_empty(fdt, nodeoffset, name) \
+	fdt_setprop((fdt), (nodeoffset), (name), NULL, 0)
+
+/**
+ * fdt_appendprop - append to or create a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to append to
+ * @val: pointer to data to append to the property value
+ * @len: length of the data to append to the property value
+ *
+ * fdt_appendprop() appends the value to the named property in the
+ * given node, creating the property if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_appendprop(void *fdt, int nodeoffset, const char *name,
+		   const void *val, int len);
+
+/**
+ * fdt_appendprop_u32 - append a 32-bit integer value to a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 32-bit integer value to append to the property (native endian)
+ *
+ * fdt_appendprop_u32() appends the given 32-bit integer value
+ * (converting to big-endian if necessary) to the value of the named
+ * property in the given node, or creates a new property with that
+ * value if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_appendprop_u32(void *fdt, int nodeoffset,
+				     const char *name, uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_appendprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_appendprop_u64 - append a 64-bit integer value to a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 64-bit integer value to append to the property (native endian)
+ *
+ * fdt_appendprop_u64() appends the given 64-bit integer value
+ * (converting to big-endian if necessary) to the value of the named
+ * property in the given node, or creates a new property with that
+ * value if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_appendprop_u64(void *fdt, int nodeoffset,
+				     const char *name, uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_appendprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_appendprop_cell - append a single cell value to a property
+ *
+ * This is an alternative name for fdt_appendprop_u32()
+ */
+static inline int fdt_appendprop_cell(void *fdt, int nodeoffset,
+				      const char *name, uint32_t val)
+{
+	return fdt_appendprop_u32(fdt, nodeoffset, name, val);
+}
+
+/**
+ * fdt_appendprop_string - append a string to a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @str: string value to append to the property
+ *
+ * fdt_appendprop_string() appends the given string to the value of
+ * the named property in the given node, or creates a new property
+ * with that value if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#define fdt_appendprop_string(fdt, nodeoffset, name, str) \
+	fdt_appendprop((fdt), (nodeoffset), (name), (str), strlen(str)+1)
+
+/**
+ * fdt_delprop - delete a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to nop
+ * @name: name of the property to nop
+ *
+ * fdt_del_property() will delete the given property.
+ *
+ * This function will delete data from the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_delprop(void *fdt, int nodeoffset, const char *name);
+
+/**
+ * fdt_add_subnode_namelen - creates a new node based on substring
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ * @namelen: number of characters of name to consider
+ *
+ * Identical to fdt_add_subnode(), but use only the first namelen
+ * characters of name as the name of the new node.  This is useful for
+ * creating subnodes based on a portion of a larger string, such as a
+ * full path.
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_add_subnode_namelen(void *fdt, int parentoffset,
+			    const char *name, int namelen);
+#endif
+
+/**
+ * fdt_add_subnode - creates a new node
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ *
+ * fdt_add_subnode() creates a new node as a subnode of the node at
+ * structure block offset parentoffset, with the given name (which
+ * should include the unit address, if any).
+ *
+ * This function will insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+
+ * returns:
+ *	structure block offset of the created nodeequested subnode (>=0), on
+ *		success
+ *	-FDT_ERR_NOTFOUND, if the requested subnode does not exist
+ *	-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE
+ *		tag
+ *	-FDT_ERR_EXISTS, if the node at parentoffset already has a subnode of
+ *		the given name
+ *	-FDT_ERR_NOSPACE, if there is insufficient free space in the
+ *		blob to contain the new node
+ *	-FDT_ERR_NOSPACE
+ *	-FDT_ERR_BADLAYOUT
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_add_subnode(void *fdt, int parentoffset, const char *name);
+
+/**
+ * fdt_del_node - delete a node (subtree)
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to nop
+ *
+ * fdt_del_node() will remove the given node, including all its
+ * subnodes if any, from the blob.
+ *
+ * This function will delete data from the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_del_node(void *fdt, int nodeoffset);
+
+/**
+ * fdt_overlay_apply - Applies a DT overlay on a base DT
+ * @fdt: pointer to the base device tree blob
+ * @fdto: pointer to the device tree overlay blob
+ *
+ * fdt_overlay_apply() will apply the given device tree overlay on the
+ * given base device tree.
+ *
+ * Expect the base device tree to be modified, even if the function
+ * returns an error.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there's not enough space in the base device tree
+ *	-FDT_ERR_NOTFOUND, the overlay points to some inexistant nodes or
+ *		properties in the base DT
+ *	-FDT_ERR_BADPHANDLE,
+ *	-FDT_ERR_BADOVERLAY,
+ *	-FDT_ERR_NOPHANDLES,
+ *	-FDT_ERR_INTERNAL,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADOFFSET,
+ *	-FDT_ERR_BADPATH,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_overlay_apply(void *fdt, void *fdto);
+
+/**********************************************************************/
+/* Debugging / informational functions                                */
+/**********************************************************************/
+
+const char *fdt_strerror(int errval);
+
+#endif /* LIBFDT_H */
diff -urN u-boot-1.1.6/include/linux/libfdt_env.h u-boot-1.1.6_fdt/include/linux/libfdt_env.h
--- u-boot-1.1.6/include/linux/libfdt_env.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/include/linux/libfdt_env.h	2018-10-22 16:19:28.861612309 +0800
@@ -0,0 +1,41 @@
+#ifdef USE_HOSTCC
+#include "../scripts/dtc/libfdt/libfdt_env.h"
+#else
+/*
+ * This position of the include guard is intentional.
+ * Using the same guard name as that of scripts/dtc/libfdt/libfdt_env.h
+ * prevents it from being included.
+ */
+#ifndef LIBFDT_ENV_H
+#define LIBFDT_ENV_H
+
+#include <linux/string.h>
+
+#include <asm/byteorder.h>
+#include <asm/types.h>
+
+typedef __u16  __le16;
+typedef __u16  __be16;
+typedef __u32  __le32;
+typedef __u32  __be32;
+typedef __u64  __be64;
+
+typedef __be16 fdt16_t;
+typedef __be32 fdt32_t;
+typedef __be64 fdt64_t;
+
+#define fdt32_to_cpu(x) be32_to_cpu(x)
+#define cpu_to_fdt32(x) cpu_to_be32(x)
+#define fdt64_to_cpu(x) be64_to_cpu(x)
+#define cpu_to_fdt64(x) cpu_to_be64(x)
+
+/* U-Boot: for strtoul in fdt_overlay.c */
+//#include <vsprintf.h>
+
+extern unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base);
+
+
+#define strtoul(cp, endp, base)	simple_strtoul(cp, endp, base)
+
+#endif /* LIBFDT_ENV_H */
+#endif
diff -urN u-boot-1.1.6/include/linux/libfdt.h u-boot-1.1.6_fdt/include/linux/libfdt.h
--- u-boot-1.1.6/include/linux/libfdt.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/include/linux/libfdt.h	2018-10-22 16:22:39.073608800 +0800
@@ -0,0 +1,312 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _INCLUDE_LIBFDT_H_
+#define _INCLUDE_LIBFDT_H_
+
+#ifndef USE_HOSTCC
+#include <linux/libfdt_env.h>
+#endif
+#include "../../common/fdt/libfdt.h"
+
+/* U-Boot local hacks */
+
+#ifndef SWIG /* Not available in Python */
+struct fdt_region {
+	int offset;
+	int size;
+};
+
+/*
+ * Flags for fdt_find_regions()
+ *
+ * Add a region for the string table (always the last region)
+ */
+#define FDT_REG_ADD_STRING_TAB		(1 << 0)
+
+/*
+ * Add all supernodes of a matching node/property, useful for creating a
+ * valid subset tree
+ */
+#define FDT_REG_SUPERNODES		(1 << 1)
+
+/* Add the FDT_BEGIN_NODE tags of subnodes, including their names */
+#define FDT_REG_DIRECT_SUBNODES	(1 << 2)
+
+/* Add all subnodes of a matching node */
+#define FDT_REG_ALL_SUBNODES		(1 << 3)
+
+/* Add a region for the mem_rsvmap table (always the first region) */
+#define FDT_REG_ADD_MEM_RSVMAP		(1 << 4)
+
+/* Indicates what an fdt part is (node, property, value) */
+#define FDT_IS_NODE			(1 << 0)
+#define FDT_IS_PROP			(1 << 1)
+#define FDT_IS_VALUE			(1 << 2)	/* not supported */
+#define FDT_IS_COMPAT			(1 << 3)	/* used internally */
+#define FDT_NODE_HAS_PROP		(1 << 4)	/* node contains prop */
+
+#define FDT_ANY_GLOBAL		(FDT_IS_NODE | FDT_IS_PROP | FDT_IS_VALUE | \
+					FDT_IS_COMPAT)
+#define FDT_IS_ANY			0x1f		/* all the above */
+
+/* We set a reasonable limit on the number of nested nodes */
+#define FDT_MAX_DEPTH			32
+
+/* Decribes what we want to include from the current tag */
+enum want_t {
+	WANT_NOTHING,
+	WANT_NODES_ONLY,		/* No properties */
+	WANT_NODES_AND_PROPS,		/* Everything for one level */
+	WANT_ALL_NODES_AND_PROPS	/* Everything for all levels */
+};
+
+/* Keeps track of the state at parent nodes */
+struct fdt_subnode_stack {
+	int offset;		/* Offset of node */
+	enum want_t want;	/* The 'want' value here */
+	int included;		/* 1 if we included this node, 0 if not */
+};
+
+struct fdt_region_ptrs {
+	int depth;			/* Current tree depth */
+	int done;			/* What we have completed scanning */
+	enum want_t want;		/* What we are currently including */
+	char *end;			/* Pointer to end of full node path */
+	int nextoffset;			/* Next node offset to check */
+};
+
+/* The state of our finding algortihm */
+struct fdt_region_state {
+	struct fdt_subnode_stack stack[FDT_MAX_DEPTH];	/* node stack */
+	struct fdt_region *region;	/* Contains list of regions found */
+	int count;			/* Numnber of regions found */
+	const void *fdt;		/* FDT blob */
+	int max_regions;		/* Maximum regions to find */
+	int can_merge;		/* 1 if we can merge with previous region */
+	int start;			/* Start position of current region */
+	struct fdt_region_ptrs ptrs;	/* Pointers for what we are up to */
+};
+
+/**
+ * fdt_find_regions() - find regions in device tree
+ *
+ * Given a list of nodes to include and properties to exclude, find
+ * the regions of the device tree which describe those included parts.
+ *
+ * The intent is to get a list of regions which will be invariant provided
+ * those parts are invariant. For example, if you request a list of regions
+ * for all nodes but exclude the property "data", then you will get the
+ * same region contents regardless of any change to "data" properties.
+ *
+ * This function can be used to produce a byte-stream to send to a hashing
+ * function to verify that critical parts of the FDT have not changed.
+ *
+ * Nodes which are given in 'inc' are included in the region list, as
+ * are the names of the immediate subnodes nodes (but not the properties
+ * or subnodes of those subnodes).
+ *
+ * For eaxample "/" means to include the root node, all root properties
+ * and the FDT_BEGIN_NODE and FDT_END_NODE of all subnodes of /. The latter
+ * ensures that we capture the names of the subnodes. In a hashing situation
+ * it prevents the root node from changing at all Any change to non-excluded
+ * properties, names of subnodes or number of subnodes would be detected.
+ *
+ * When used with FITs this provides the ability to hash and sign parts of
+ * the FIT based on different configurations in the FIT. Then it is
+ * impossible to change anything about that configuration (include images
+ * attached to the configuration), but it may be possible to add new
+ * configurations, new images or new signatures within the existing
+ * framework.
+ *
+ * Adding new properties to a device tree may result in the string table
+ * being extended (if the new property names are different from those
+ * already added). This function can optionally include a region for
+ * the string table so that this can be part of the hash too.
+ *
+ * The device tree header is not included in the list.
+ *
+ * @fdt:	Device tree to check
+ * @inc:	List of node paths to included
+ * @inc_count:	Number of node paths in list
+ * @exc_prop:	List of properties names to exclude
+ * @exc_prop_count:	Number of properties in exclude list
+ * @region:	Returns list of regions
+ * @max_region:	Maximum length of region list
+ * @path:	Pointer to a temporary string for the function to use for
+ *		building path names
+ * @path_len:	Length of path, must be large enough to hold the longest
+ *		path in the tree
+ * @add_string_tab:	1 to add a region for the string table
+ * @return number of regions in list. If this is >max_regions then the
+ * region array was exhausted. You should increase max_regions and try
+ * the call again.
+ */
+int fdt_find_regions(const void *fdt, char * const inc[], int inc_count,
+		     char * const exc_prop[], int exc_prop_count,
+		     struct fdt_region region[], int max_regions,
+		     char *path, int path_len, int add_string_tab);
+
+/**
+ * fdt_first_region() - find regions in device tree
+ *
+ * Given a nodes and properties to include and properties to exclude, find
+ * the regions of the device tree which describe those included parts.
+ *
+ * The use for this function is twofold. Firstly it provides a convenient
+ * way of performing a structure-aware grep of the tree. For example it is
+ * possible to grep for a node and get all the properties associated with
+ * that node. Trees can be subsetted easily, by specifying the nodes that
+ * are required, and then writing out the regions returned by this function.
+ * This is useful for small resource-constrained systems, such as boot
+ * loaders, which want to use an FDT but do not need to know about all of
+ * it.
+ *
+ * Secondly it makes it easy to hash parts of the tree and detect changes.
+ * The intent is to get a list of regions which will be invariant provided
+ * those parts are invariant. For example, if you request a list of regions
+ * for all nodes but exclude the property "data", then you will get the
+ * same region contents regardless of any change to "data" properties.
+ *
+ * This function can be used to produce a byte-stream to send to a hashing
+ * function to verify that critical parts of the FDT have not changed.
+ * Note that semantically null changes in order could still cause false
+ * hash misses. Such reordering might happen if the tree is regenerated
+ * from source, and nodes are reordered (the bytes-stream will be emitted
+ * in a different order and many hash functions will detect this). However
+ * if an existing tree is modified using libfdt functions, such as
+ * fdt_add_subnode() and fdt_setprop(), then this problem is avoided.
+ *
+ * The nodes/properties to include/exclude are defined by a function
+ * provided by the caller. This function is called for each node and
+ * property, and must return:
+ *
+ *    0 - to exclude this part
+ *    1 - to include this part
+ *   -1 - for FDT_IS_PROP only: no information is available, so include
+ *		if its containing node is included
+ *
+ * The last case is only used to deal with properties. Often a property is
+ * included if its containing node is included - this is the case where
+ * -1 is returned.. However if the property is specifically required to be
+ * included/excluded, then 0 or 1 can be returned. Note that including a
+ * property when the FDT_REG_SUPERNODES flag is given will force its
+ * containing node to be included since it is not valid to have a property
+ * that is not in a node.
+ *
+ * Using the information provided, the inclusion of a node can be controlled
+ * either by a node name or its compatible string, or any other property
+ * that the function can determine.
+ *
+ * As an example, including node "/" means to include the root node and all
+ * root properties. A flag provides a way of also including supernodes (of
+ * which there is none for the root node), and another flag includes
+ * immediate subnodes, so in this case we would get the FDT_BEGIN_NODE and
+ * FDT_END_NODE of all subnodes of /.
+ *
+ * The subnode feature helps in a hashing situation since it prevents the
+ * root node from changing at all. Any change to non-excluded properties,
+ * names of subnodes or number of subnodes would be detected.
+ *
+ * When used with FITs this provides the ability to hash and sign parts of
+ * the FIT based on different configurations in the FIT. Then it is
+ * impossible to change anything about that configuration (include images
+ * attached to the configuration), but it may be possible to add new
+ * configurations, new images or new signatures within the existing
+ * framework.
+ *
+ * Adding new properties to a device tree may result in the string table
+ * being extended (if the new property names are different from those
+ * already added). This function can optionally include a region for
+ * the string table so that this can be part of the hash too. This is always
+ * the last region.
+ *
+ * The FDT also has a mem_rsvmap table which can also be included, and is
+ * always the first region if so.
+ *
+ * The device tree header is not included in the region list. Since the
+ * contents of the FDT are changing (shrinking, often), the caller will need
+ * to regenerate the header anyway.
+ *
+ * @fdt:	Device tree to check
+ * @h_include:	Function to call to determine whether to include a part or
+ *		not:
+ *
+ *		@priv: Private pointer as passed to fdt_find_regions()
+ *		@fdt: Pointer to FDT blob
+ *		@offset: Offset of this node / property
+ *		@type: Type of this part, FDT_IS_...
+ *		@data: Pointer to data (node name, property name, compatible
+ *			string, value (not yet supported)
+ *		@size: Size of data, or 0 if none
+ *		@return 0 to exclude, 1 to include, -1 if no information is
+ *		available
+ * @priv:	Private pointer passed to h_include
+ * @region:	Returns list of regions, sorted by offset
+ * @max_regions: Maximum length of region list
+ * @path:	Pointer to a temporary string for the function to use for
+ *		building path names
+ * @path_len:	Length of path, must be large enough to hold the longest
+ *		path in the tree
+ * @flags:	Various flags that control the region algortihm, see
+ *		FDT_REG_...
+ * @return number of regions in list. If this is >max_regions then the
+ * region array was exhausted. You should increase max_regions and try
+ * the call again. Only the first max_regions elements are available in the
+ * array.
+ *
+ * On error a -ve value is return, which can be:
+ *
+ *	-FDT_ERR_BADSTRUCTURE (too deep or more END tags than BEGIN tags
+ *	-FDT_ERR_BADLAYOUT
+ *	-FDT_ERR_NOSPACE (path area is too small)
+ */
+int fdt_first_region(const void *fdt,
+		     int (*h_include)(void *priv, const void *fdt, int offset,
+				      int type, const char *data, int size),
+		     void *priv, struct fdt_region *region,
+		     char *path, int path_len, int flags,
+		     struct fdt_region_state *info);
+
+/** fdt_next_region() - find next region
+ *
+ * See fdt_first_region() for full description. This function finds the
+ * next region according to the provided parameters, which must be the same
+ * as passed to fdt_first_region().
+ *
+ * This function can additionally return -FDT_ERR_NOTFOUND when there are no
+ * more regions
+ */
+int fdt_next_region(const void *fdt,
+		    int (*h_include)(void *priv, const void *fdt, int offset,
+				     int type, const char *data, int size),
+		    void *priv, struct fdt_region *region,
+		    char *path, int path_len, int flags,
+		    struct fdt_region_state *info);
+
+/**
+ * fdt_add_alias_regions() - find aliases that point to existing regions
+ *
+ * Once a device tree grep is complete some of the nodes will be present
+ * and some will have been dropped. This function checks all the alias nodes
+ * to figure out which points point to nodes which are still present. These
+ * aliases need to be kept, along with the nodes they reference.
+ *
+ * Given a list of regions function finds the aliases that still apply and
+ * adds more regions to the list for these. This function is called after
+ * fdt_next_region() has finished returning regions and requires the same
+ * state.
+ *
+ * @fdt:	Device tree file to reference
+ * @region:	List of regions that will be kept
+ * @count:	Number of regions
+ * @max_regions: Number of entries that can fit in @region
+ * @info:	Region state as returned from fdt_next_region()
+ * @return new number of regions in @region (i.e. count + the number added)
+ * or -FDT_ERR_NOSPACE if there was not enough space.
+ */
+int fdt_add_alias_regions(const void *fdt, struct fdt_region *region, int count,
+			  int max_regions, struct fdt_region_state *info);
+#endif /* SWIG */
+
+extern struct fdt_header *working_fdt;  /* Pointer to the working fdt */
+
+#endif /* _INCLUDE_LIBFDT_H_ */
diff -urN u-boot-1.1.6/include/nand.h u-boot-1.1.6_fdt/include/nand.h
--- u-boot-1.1.6/include/nand.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/include/nand.h	2018-10-22 15:53:21.565641224 +0800
@@ -78,6 +78,14 @@
 	int pad;		/* pad to page size */
 	int blockalign;		/* 1|2|4 set multiple of eraseblocks
 				 * to align to */
+    int skipfirstblk;   /* if true, skip the first good block,  
+                         * set true when write the yaffs image, 
+                         * add by www.100ask.net
+                         */                    
+    int nocheckbadblk;  /* if true, don't check bad blockes,
+                         * use them as good blockes
+                         * add by www.100ask.net
+                         */                    
 };
 
 typedef struct nand_write_options nand_write_options_t;
@@ -88,6 +96,11 @@
 	ulong offset;		/* start address in NAND */
 	int quiet;		/* don't display progress messages */
 	int readoob;		/* put oob data in image */
+	int noecc;		/* read without ecc */
+    int nocheckbadblk;  /* if true, don't check bad blockes,
+                         * use them as good blockes
+                         * add by www.100ask.net
+                         */                    
 };
 
 typedef struct nand_read_options nand_read_options_t;
diff -urN u-boot-1.1.6/include/s3c2410.h u-boot-1.1.6_fdt/include/s3c2410.h
--- u-boot-1.1.6/include/s3c2410.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/include/s3c2410.h	2018-10-22 15:53:21.565641224 +0800
@@ -22,7 +22,7 @@
  */
 
 /************************************************
- * NAME	    : s3c2410.h
+ * NAME     : s3c2410.h
  * Version  : 31.3.2003
  *
  * Based on S3C2410X User's manual Rev 1.1
@@ -31,38 +31,38 @@
 #ifndef __S3C2410_H__
 #define __S3C2410_H__
 
-#define S3C24X0_UART_CHANNELS	3
-#define S3C24X0_SPI_CHANNELS	2
+#define S3C24X0_UART_CHANNELS   3
+#define S3C24X0_SPI_CHANNELS    2
 
 /* S3C2410 only supports 512 Byte HW ECC */
-#define S3C2410_ECCSIZE		512
-#define S3C2410_ECCBYTES	3
+#define S3C2410_ECCSIZE     512
+#define S3C2410_ECCBYTES    3
 
 typedef enum {
-	S3C24X0_UART0,
-	S3C24X0_UART1,
-	S3C24X0_UART2
+    S3C24X0_UART0,
+    S3C24X0_UART1,
+    S3C24X0_UART2
 } S3C24X0_UARTS_NR;
 
 /* S3C2410 device base addresses */
-#define S3C24X0_MEMCTL_BASE		0x48000000
-#define S3C24X0_USB_HOST_BASE		0x49000000
-#define S3C24X0_INTERRUPT_BASE		0x4A000000
-#define S3C24X0_DMA_BASE		0x4B000000
-#define S3C24X0_CLOCK_POWER_BASE	0x4C000000
-#define S3C24X0_LCD_BASE		0x4D000000
-#define S3C2410_NAND_BASE		0x4E000000
-#define S3C24X0_UART_BASE		0x50000000
-#define S3C24X0_TIMER_BASE		0x51000000
-#define S3C24X0_USB_DEVICE_BASE		0x52000140
-#define S3C24X0_WATCHDOG_BASE		0x53000000
-#define S3C24X0_I2C_BASE		0x54000000
-#define S3C24X0_I2S_BASE		0x55000000
-#define S3C24X0_GPIO_BASE		0x56000000
-#define S3C24X0_RTC_BASE		0x57000000
-#define S3C2410_ADC_BASE		0x58000000
-#define S3C24X0_SPI_BASE		0x59000000
-#define S3C2410_SDI_BASE		0x5A000000
+#define S3C24X0_MEMCTL_BASE     0x48000000
+#define S3C24X0_USB_HOST_BASE       0x49000000
+#define S3C24X0_INTERRUPT_BASE      0x4A000000
+#define S3C24X0_DMA_BASE        0x4B000000
+#define S3C24X0_CLOCK_POWER_BASE    0x4C000000
+#define S3C24X0_LCD_BASE        0x4D000000
+#define S3C2410_NAND_BASE       0x4E000000
+#define S3C24X0_UART_BASE       0x50000000
+#define S3C24X0_TIMER_BASE      0x51000000
+#define S3C24X0_USB_DEVICE_BASE     0x52000140
+#define S3C24X0_WATCHDOG_BASE       0x53000000
+#define S3C24X0_I2C_BASE        0x54000000
+#define S3C24X0_I2S_BASE        0x55000000
+#define S3C24X0_GPIO_BASE       0x56000000
+#define S3C24X0_RTC_BASE        0x57000000
+#define S3C2410_ADC_BASE        0x58000000
+#define S3C24X0_SPI_BASE        0x59000000
+#define S3C2410_SDI_BASE        0x5A000000
 
 
 /* include common stuff */
@@ -71,130 +71,172 @@
 
 static inline S3C24X0_MEMCTL * const S3C24X0_GetBase_MEMCTL(void)
 {
-	return (S3C24X0_MEMCTL * const)S3C24X0_MEMCTL_BASE;
+    return (S3C24X0_MEMCTL * const)S3C24X0_MEMCTL_BASE;
 }
 static inline S3C24X0_USB_HOST * const S3C24X0_GetBase_USB_HOST(void)
 {
-	return (S3C24X0_USB_HOST * const)S3C24X0_USB_HOST_BASE;
+    return (S3C24X0_USB_HOST * const)S3C24X0_USB_HOST_BASE;
 }
 static inline S3C24X0_INTERRUPT * const S3C24X0_GetBase_INTERRUPT(void)
 {
-	return (S3C24X0_INTERRUPT * const)S3C24X0_INTERRUPT_BASE;
+    return (S3C24X0_INTERRUPT * const)S3C24X0_INTERRUPT_BASE;
 }
 static inline S3C24X0_DMAS * const S3C24X0_GetBase_DMAS(void)
 {
-	return (S3C24X0_DMAS * const)S3C24X0_DMA_BASE;
+    return (S3C24X0_DMAS * const)S3C24X0_DMA_BASE;
 }
 static inline S3C24X0_CLOCK_POWER * const S3C24X0_GetBase_CLOCK_POWER(void)
 {
-	return (S3C24X0_CLOCK_POWER * const)S3C24X0_CLOCK_POWER_BASE;
+    return (S3C24X0_CLOCK_POWER * const)S3C24X0_CLOCK_POWER_BASE;
 }
 static inline S3C24X0_LCD * const S3C24X0_GetBase_LCD(void)
 {
-	return (S3C24X0_LCD * const)S3C24X0_LCD_BASE;
+    return (S3C24X0_LCD * const)S3C24X0_LCD_BASE;
 }
 static inline S3C2410_NAND * const S3C2410_GetBase_NAND(void)
 {
-	return (S3C2410_NAND * const)S3C2410_NAND_BASE;
+    return (S3C2410_NAND * const)S3C2410_NAND_BASE;
+}
+
+/* for s3c2440, www.100ask.net */
+static inline S3C2440_NAND * const S3C2440_GetBase_NAND(void)
+{
+    return (S3C2440_NAND * const)S3C2410_NAND_BASE;
 }
 static inline S3C24X0_UART * const S3C24X0_GetBase_UART(S3C24X0_UARTS_NR nr)
 {
-	return (S3C24X0_UART * const)(S3C24X0_UART_BASE + (nr * 0x4000));
+    return (S3C24X0_UART * const)(S3C24X0_UART_BASE + (nr * 0x4000));
 }
 static inline S3C24X0_TIMERS * const S3C24X0_GetBase_TIMERS(void)
 {
-	return (S3C24X0_TIMERS * const)S3C24X0_TIMER_BASE;
+    return (S3C24X0_TIMERS * const)S3C24X0_TIMER_BASE;
 }
 static inline S3C24X0_USB_DEVICE * const S3C24X0_GetBase_USB_DEVICE(void)
 {
-	return (S3C24X0_USB_DEVICE * const)S3C24X0_USB_DEVICE_BASE;
+    return (S3C24X0_USB_DEVICE * const)S3C24X0_USB_DEVICE_BASE;
 }
 static inline S3C24X0_WATCHDOG * const S3C24X0_GetBase_WATCHDOG(void)
 {
-	return (S3C24X0_WATCHDOG * const)S3C24X0_WATCHDOG_BASE;
+    return (S3C24X0_WATCHDOG * const)S3C24X0_WATCHDOG_BASE;
 }
 static inline S3C24X0_I2C * const S3C24X0_GetBase_I2C(void)
 {
-	return (S3C24X0_I2C * const)S3C24X0_I2C_BASE;
+    return (S3C24X0_I2C * const)S3C24X0_I2C_BASE;
 }
 static inline S3C24X0_I2S * const S3C24X0_GetBase_I2S(void)
 {
-	return (S3C24X0_I2S * const)S3C24X0_I2S_BASE;
+    return (S3C24X0_I2S * const)S3C24X0_I2S_BASE;
 }
 static inline S3C24X0_GPIO * const S3C24X0_GetBase_GPIO(void)
 {
-	return (S3C24X0_GPIO * const)S3C24X0_GPIO_BASE;
+    return (S3C24X0_GPIO * const)S3C24X0_GPIO_BASE;
 }
 static inline S3C24X0_RTC * const S3C24X0_GetBase_RTC(void)
 {
-	return (S3C24X0_RTC * const)S3C24X0_RTC_BASE;
+    return (S3C24X0_RTC * const)S3C24X0_RTC_BASE;
 }
 static inline S3C2410_ADC * const S3C2410_GetBase_ADC(void)
 {
-	return (S3C2410_ADC * const)S3C2410_ADC_BASE;
+    return (S3C2410_ADC * const)S3C2410_ADC_BASE;
 }
 static inline S3C24X0_SPI * const S3C24X0_GetBase_SPI(void)
 {
-	return (S3C24X0_SPI * const)S3C24X0_SPI_BASE;
+    return (S3C24X0_SPI * const)S3C24X0_SPI_BASE;
 }
 static inline S3C2410_SDI * const S3C2410_GetBase_SDI(void)
 {
-	return (S3C2410_SDI * const)S3C2410_SDI_BASE;
+    return (S3C2410_SDI * const)S3C2410_SDI_BASE;
 }
 
+/* add by thisway.diy */             
+#define _ISR_STARTADDRESS   ((unsigned)isr_handle_array)
+
+#define ISR_EINT0_OFT     0
+#define ISR_EINT1_OFT     1
+#define ISR_EINT2_OFT     2
+#define ISR_EINT3_OFT     3
+#define ISR_EINT4_7_OFT   4
+#define ISR_EINT8_23_OFT  5
+#define ISR_NOTUSED6_OFT  6
+#define ISR_BAT_FLT_OFT   7
+#define ISR_TICK_OFT      8
+#define ISR_WDT_OFT       9
+#define ISR_TIMER0_OFT    10
+#define ISR_TIMER1_OFT    11
+#define ISR_TIMER2_OFT    12
+#define ISR_TIMER3_OFT    13
+#define ISR_TIMER4_OFT    14
+#define ISR_UART2_OFT     15
+#define ISR_LCD_OFT       16
+#define ISR_DMA0_OFT      17
+#define ISR_DMA1_OFT      18
+#define ISR_DMA2_OFT      19
+#define ISR_DMA3_OFT      20
+#define ISR_SDI_OFT       21
+#define ISR_SPI0_OFT      22
+#define ISR_UART1_OFT     23
+#define ISR_NOTUSED24_OFT 24
+#define ISR_USBD_OFT      25
+#define ISR_USBH_OFT      26
+#define ISR_IIC_OFT       27
+#define ISR_UART0_OFT     28
+#define ISR_SPI1_OFT      29
+#define ISR_RTC_OFT       30
+#define ISR_ADC_OFT       31
 
 /* ISR */
-#define pISR_RESET		(*(unsigned *)(_ISR_STARTADDRESS+0x0))
-#define pISR_UNDEF		(*(unsigned *)(_ISR_STARTADDRESS+0x4))
-#define pISR_SWI		(*(unsigned *)(_ISR_STARTADDRESS+0x8))
-#define pISR_PABORT		(*(unsigned *)(_ISR_STARTADDRESS+0xC))
-#define pISR_DABORT		(*(unsigned *)(_ISR_STARTADDRESS+0x10))
-#define pISR_RESERVED		(*(unsigned *)(_ISR_STARTADDRESS+0x14))
-#define pISR_IRQ		(*(unsigned *)(_ISR_STARTADDRESS+0x18))
-#define pISR_FIQ		(*(unsigned *)(_ISR_STARTADDRESS+0x1C))
-
-#define pISR_EINT0		(*(unsigned *)(_ISR_STARTADDRESS+0x20))
-#define pISR_EINT1		(*(unsigned *)(_ISR_STARTADDRESS+0x24))
-#define pISR_EINT2		(*(unsigned *)(_ISR_STARTADDRESS+0x28))
-#define pISR_EINT3		(*(unsigned *)(_ISR_STARTADDRESS+0x2C))
-#define pISR_EINT4_7		(*(unsigned *)(_ISR_STARTADDRESS+0x30))
-#define pISR_EINT8_23		(*(unsigned *)(_ISR_STARTADDRESS+0x34))
-#define pISR_BAT_FLT		(*(unsigned *)(_ISR_STARTADDRESS+0x3C))
-#define pISR_TICK		(*(unsigned *)(_ISR_STARTADDRESS+0x40))
-#define pISR_WDT		(*(unsigned *)(_ISR_STARTADDRESS+0x44))
-#define pISR_TIMER0		(*(unsigned *)(_ISR_STARTADDRESS+0x48))
-#define pISR_TIMER1		(*(unsigned *)(_ISR_STARTADDRESS+0x4C))
-#define pISR_TIMER2		(*(unsigned *)(_ISR_STARTADDRESS+0x50))
-#define pISR_TIMER3		(*(unsigned *)(_ISR_STARTADDRESS+0x54))
-#define pISR_TIMER4		(*(unsigned *)(_ISR_STARTADDRESS+0x58))
-#define pISR_UART2		(*(unsigned *)(_ISR_STARTADDRESS+0x5C))
-#define pISR_NOTUSED		(*(unsigned *)(_ISR_STARTADDRESS+0x60))
-#define pISR_DMA0		(*(unsigned *)(_ISR_STARTADDRESS+0x64))
-#define pISR_DMA1		(*(unsigned *)(_ISR_STARTADDRESS+0x68))
-#define pISR_DMA2		(*(unsigned *)(_ISR_STARTADDRESS+0x6C))
-#define pISR_DMA3		(*(unsigned *)(_ISR_STARTADDRESS+0x70))
-#define pISR_SDI		(*(unsigned *)(_ISR_STARTADDRESS+0x74))
-#define pISR_SPI0		(*(unsigned *)(_ISR_STARTADDRESS+0x78))
-#define pISR_UART1		(*(unsigned *)(_ISR_STARTADDRESS+0x7C))
-#define pISR_USBD		(*(unsigned *)(_ISR_STARTADDRESS+0x84))
-#define pISR_USBH		(*(unsigned *)(_ISR_STARTADDRESS+0x88))
-#define pISR_IIC		(*(unsigned *)(_ISR_STARTADDRESS+0x8C))
-#define pISR_UART0		(*(unsigned *)(_ISR_STARTADDRESS+0x90))
-#define pISR_SPI1		(*(unsigned *)(_ISR_STARTADDRESS+0x94))
-#define pISR_RTC		(*(unsigned *)(_ISR_STARTADDRESS+0x98))
-#define pISR_ADC		(*(unsigned *)(_ISR_STARTADDRESS+0xA0))
+#define pISR_RESET      (*(unsigned *)(_ISR_STARTADDRESS+0x0))
+#define pISR_UNDEF      (*(unsigned *)(_ISR_STARTADDRESS+0x4))
+#define pISR_SWI        (*(unsigned *)(_ISR_STARTADDRESS+0x8))
+#define pISR_PABORT     (*(unsigned *)(_ISR_STARTADDRESS+0xC))
+#define pISR_DABORT     (*(unsigned *)(_ISR_STARTADDRESS+0x10))
+#define pISR_RESERVED       (*(unsigned *)(_ISR_STARTADDRESS+0x14))
+#define pISR_IRQ        (*(unsigned *)(_ISR_STARTADDRESS+0x18))
+#define pISR_FIQ        (*(unsigned *)(_ISR_STARTADDRESS+0x1C))
+
+#define pISR_EINT0      (*(unsigned *)(_ISR_STARTADDRESS+0x20))
+#define pISR_EINT1      (*(unsigned *)(_ISR_STARTADDRESS+0x24))
+#define pISR_EINT2      (*(unsigned *)(_ISR_STARTADDRESS+0x28))
+#define pISR_EINT3      (*(unsigned *)(_ISR_STARTADDRESS+0x2C))
+#define pISR_EINT4_7        (*(unsigned *)(_ISR_STARTADDRESS+0x30))
+#define pISR_EINT8_23       (*(unsigned *)(_ISR_STARTADDRESS+0x34))
+#define pISR_BAT_FLT        (*(unsigned *)(_ISR_STARTADDRESS+0x3C))
+#define pISR_TICK       (*(unsigned *)(_ISR_STARTADDRESS+0x40))
+#define pISR_WDT        (*(unsigned *)(_ISR_STARTADDRESS+0x44))
+#define pISR_TIMER0     (*(unsigned *)(_ISR_STARTADDRESS+0x48))
+#define pISR_TIMER1     (*(unsigned *)(_ISR_STARTADDRESS+0x4C))
+#define pISR_TIMER2     (*(unsigned *)(_ISR_STARTADDRESS+0x50))
+#define pISR_TIMER3     (*(unsigned *)(_ISR_STARTADDRESS+0x54))
+#define pISR_TIMER4     (*(unsigned *)(_ISR_STARTADDRESS+0x58))
+#define pISR_UART2      (*(unsigned *)(_ISR_STARTADDRESS+0x5C))
+#define pISR_NOTUSED        (*(unsigned *)(_ISR_STARTADDRESS+0x60))
+#define pISR_DMA0       (*(unsigned *)(_ISR_STARTADDRESS+0x64))
+#define pISR_DMA1       (*(unsigned *)(_ISR_STARTADDRESS+0x68))
+#define pISR_DMA2       (*(unsigned *)(_ISR_STARTADDRESS+0x6C))
+#define pISR_DMA3       (*(unsigned *)(_ISR_STARTADDRESS+0x70))
+#define pISR_SDI        (*(unsigned *)(_ISR_STARTADDRESS+0x74))
+#define pISR_SPI0       (*(unsigned *)(_ISR_STARTADDRESS+0x78))
+#define pISR_UART1      (*(unsigned *)(_ISR_STARTADDRESS+0x7C))
+#define pISR_USBD       (*(unsigned *)(_ISR_STARTADDRESS+0x84))
+#define pISR_USBH       (*(unsigned *)(_ISR_STARTADDRESS+0x88))
+#define pISR_IIC        (*(unsigned *)(_ISR_STARTADDRESS+0x8C))
+#define pISR_UART0      (*(unsigned *)(_ISR_STARTADDRESS+0x90))
+#define pISR_SPI1       (*(unsigned *)(_ISR_STARTADDRESS+0x94))
+#define pISR_RTC        (*(unsigned *)(_ISR_STARTADDRESS+0x98))
+#define pISR_ADC        (*(unsigned *)(_ISR_STARTADDRESS+0xA0))
 
 
-/* PENDING BIT */
+// PENDING BIT
 #define BIT_EINT0		(0x1)
 #define BIT_EINT1		(0x1<<1)
 #define BIT_EINT2		(0x1<<2)
 #define BIT_EINT3		(0x1<<3)
 #define BIT_EINT4_7		(0x1<<4)
-#define BIT_EINT8_23		(0x1<<5)
+#define BIT_EINT8_23	(0x1<<5)
+#define BIT_CAM			(0x1<<6)		// Added for 2440.
 #define BIT_BAT_FLT		(0x1<<7)
-#define BIT_TICK		(0x1<<8)
-#define BIT_WDT			(0x1<<9)
+#define BIT_TICK			(0x1<<8)
+#define BIT_WDT_AC97	(0x1<<9)
 #define BIT_TIMER0		(0x1<<10)
 #define BIT_TIMER1		(0x1<<11)
 #define BIT_TIMER2		(0x1<<12)
@@ -207,21 +249,33 @@
 #define BIT_DMA2		(0x1<<19)
 #define BIT_DMA3		(0x1<<20)
 #define BIT_SDI			(0x1<<21)
-#define BIT_SPI0		(0x1<<22)
+#define BIT_SPI0			(0x1<<22)
 #define BIT_UART1		(0x1<<23)
+#define BIT_NFCON		(0x1<<24)		// Added for 2440.
 #define BIT_USBD		(0x1<<25)
 #define BIT_USBH		(0x1<<26)
 #define BIT_IIC			(0x1<<27)
 #define BIT_UART0		(0x1<<28)
-#define BIT_SPI1		(0x1<<29)
+#define BIT_SPI1			(0x1<<29)
 #define BIT_RTC			(0x1<<30)
 #define BIT_ADC			(0x1<<31)
-#define BIT_ALLMSK		(0xFFFFFFFF)
+#define BIT_ALLMSK		(0xffffffff)
+
+#define BIT_SUB_ALLMSK	(0x7fff)
+#define BIT_SUB_AC97 	(0x1<<14)
+#define BIT_SUB_WDT 	(0x1<<13)
+#define BIT_SUB_CAM_S	(0x1<<12)		// Added for 2440.
+#define BIT_SUB_CAM_C	(0x1<<11)		// Added for 2440.
+#define BIT_SUB_ADC		(0x1<<10)
+#define BIT_SUB_TC		(0x1<<9)
+#define BIT_SUB_ERR2	(0x1<<8)
+#define BIT_SUB_TXD2	(0x1<<7)
+#define BIT_SUB_RXD2	(0x1<<6)
+#define BIT_SUB_ERR1	(0x1<<5)
+#define BIT_SUB_TXD1	(0x1<<4)
+#define BIT_SUB_RXD1	(0x1<<3)
+#define BIT_SUB_ERR0	(0x1<<2)
+#define BIT_SUB_TXD0	(0x1<<1)
+#define BIT_SUB_RXD0	(0x1<<0)
 
-#define ClearPending(bit) {\
-		 rSRCPND = bit;\
-		 rINTPND = bit;\
-		 rINTPND;\
-		 }
-/* Wait until rINTPND is changed for the case that the ISR is very short. */
 #endif /*__S3C2410_H__*/
diff -urN u-boot-1.1.6/include/s3c24x0.h u-boot-1.1.6_fdt/include/s3c24x0.h
--- u-boot-1.1.6/include/s3c24x0.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/include/s3c24x0.h	2018-10-22 15:53:21.565641224 +0800
@@ -22,7 +22,7 @@
  */
 
 /************************************************
- * NAME	    : s3c24x0.h
+ * NAME     : s3c24x0.h
  * Version  : 31.3.2003
  *
  * common stuff for SAMSUNG S3C24X0 SoC
@@ -31,337 +31,363 @@
 #ifndef __S3C24X0_H__
 #define __S3C24X0_H__
 
-typedef volatile u8	S3C24X0_REG8;
-typedef volatile u16	S3C24X0_REG16;
-typedef volatile u32	S3C24X0_REG32;
+typedef volatile u8 S3C24X0_REG8;
+typedef volatile u16    S3C24X0_REG16;
+typedef volatile u32    S3C24X0_REG32;
 
 /* Memory controller (see manual chapter 5) */
 typedef struct {
-	S3C24X0_REG32	BWSCON;
-	S3C24X0_REG32	BANKCON[8];
-	S3C24X0_REG32	REFRESH;
-	S3C24X0_REG32	BANKSIZE;
-	S3C24X0_REG32	MRSRB6;
-	S3C24X0_REG32	MRSRB7;
+    S3C24X0_REG32   BWSCON;
+    S3C24X0_REG32   BANKCON[8];
+    S3C24X0_REG32   REFRESH;
+    S3C24X0_REG32   BANKSIZE;
+    S3C24X0_REG32   MRSRB6;
+    S3C24X0_REG32   MRSRB7;
 } /*__attribute__((__packed__))*/ S3C24X0_MEMCTL;
 
 
 /* USB HOST (see manual chapter 12) */
 typedef struct {
-	S3C24X0_REG32	HcRevision;
-	S3C24X0_REG32	HcControl;
-	S3C24X0_REG32	HcCommonStatus;
-	S3C24X0_REG32	HcInterruptStatus;
-	S3C24X0_REG32	HcInterruptEnable;
-	S3C24X0_REG32	HcInterruptDisable;
-	S3C24X0_REG32	HcHCCA;
-	S3C24X0_REG32	HcPeriodCuttendED;
-	S3C24X0_REG32	HcControlHeadED;
-	S3C24X0_REG32	HcControlCurrentED;
-	S3C24X0_REG32	HcBulkHeadED;
-	S3C24X0_REG32	HcBuldCurrentED;
-	S3C24X0_REG32	HcDoneHead;
-	S3C24X0_REG32	HcRmInterval;
-	S3C24X0_REG32	HcFmRemaining;
-	S3C24X0_REG32	HcFmNumber;
-	S3C24X0_REG32	HcPeriodicStart;
-	S3C24X0_REG32	HcLSThreshold;
-	S3C24X0_REG32	HcRhDescriptorA;
-	S3C24X0_REG32	HcRhDescriptorB;
-	S3C24X0_REG32	HcRhStatus;
-	S3C24X0_REG32	HcRhPortStatus1;
-	S3C24X0_REG32	HcRhPortStatus2;
+    S3C24X0_REG32   HcRevision;
+    S3C24X0_REG32   HcControl;
+    S3C24X0_REG32   HcCommonStatus;
+    S3C24X0_REG32   HcInterruptStatus;
+    S3C24X0_REG32   HcInterruptEnable;
+    S3C24X0_REG32   HcInterruptDisable;
+    S3C24X0_REG32   HcHCCA;
+    S3C24X0_REG32   HcPeriodCuttendED;
+    S3C24X0_REG32   HcControlHeadED;
+    S3C24X0_REG32   HcControlCurrentED;
+    S3C24X0_REG32   HcBulkHeadED;
+    S3C24X0_REG32   HcBuldCurrentED;
+    S3C24X0_REG32   HcDoneHead;
+    S3C24X0_REG32   HcRmInterval;
+    S3C24X0_REG32   HcFmRemaining;
+    S3C24X0_REG32   HcFmNumber;
+    S3C24X0_REG32   HcPeriodicStart;
+    S3C24X0_REG32   HcLSThreshold;
+    S3C24X0_REG32   HcRhDescriptorA;
+    S3C24X0_REG32   HcRhDescriptorB;
+    S3C24X0_REG32   HcRhStatus;
+    S3C24X0_REG32   HcRhPortStatus1;
+    S3C24X0_REG32   HcRhPortStatus2;
 } /*__attribute__((__packed__))*/ S3C24X0_USB_HOST;
 
 
 /* INTERRUPT (see manual chapter 14) */
 typedef struct {
-	S3C24X0_REG32	SRCPND;
-	S3C24X0_REG32	INTMOD;
-	S3C24X0_REG32	INTMSK;
-	S3C24X0_REG32	PRIORITY;
-	S3C24X0_REG32	INTPND;
-	S3C24X0_REG32	INTOFFSET;
+    S3C24X0_REG32   SRCPND;
+    S3C24X0_REG32   INTMOD;
+    S3C24X0_REG32   INTMSK;
+    S3C24X0_REG32   PRIORITY;
+    S3C24X0_REG32   INTPND;
+    S3C24X0_REG32   INTOFFSET;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	SUBSRCPND;
-	S3C24X0_REG32	INTSUBMSK;
+    S3C24X0_REG32   SUBSRCPND;
+    S3C24X0_REG32   INTSUBMSK;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_INTERRUPT;
 
 
 /* DMAS (see manual chapter 8) */
 typedef struct {
-	S3C24X0_REG32	DISRC;
+    S3C24X0_REG32   DISRC;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	DISRCC;
+    S3C24X0_REG32   DISRCC;
 #endif
-	S3C24X0_REG32	DIDST;
+    S3C24X0_REG32   DIDST;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	DIDSTC;
+    S3C24X0_REG32   DIDSTC;
 #endif
-	S3C24X0_REG32	DCON;
-	S3C24X0_REG32	DSTAT;
-	S3C24X0_REG32	DCSRC;
-	S3C24X0_REG32	DCDST;
-	S3C24X0_REG32	DMASKTRIG;
+    S3C24X0_REG32   DCON;
+    S3C24X0_REG32   DSTAT;
+    S3C24X0_REG32   DCSRC;
+    S3C24X0_REG32   DCDST;
+    S3C24X0_REG32   DMASKTRIG;
 #ifdef CONFIG_S3C2400
-	S3C24X0_REG32	res[1];
+    S3C24X0_REG32   res[1];
 #endif
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	res[7];
+    S3C24X0_REG32   res[7];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_DMA;
 
 typedef struct {
-	S3C24X0_DMA	dma[4];
+    S3C24X0_DMA dma[4];
 } /*__attribute__((__packed__))*/ S3C24X0_DMAS;
 
 
 /* CLOCK & POWER MANAGEMENT (see S3C2400 manual chapter 6) */
 /*                          (see S3C2410 manual chapter 7) */
 typedef struct {
-	S3C24X0_REG32	LOCKTIME;
-	S3C24X0_REG32	MPLLCON;
-	S3C24X0_REG32	UPLLCON;
-	S3C24X0_REG32	CLKCON;
-	S3C24X0_REG32	CLKSLOW;
-	S3C24X0_REG32	CLKDIVN;
+    S3C24X0_REG32   LOCKTIME;
+    S3C24X0_REG32   MPLLCON;
+    S3C24X0_REG32   UPLLCON;
+    S3C24X0_REG32   CLKCON;
+    S3C24X0_REG32   CLKSLOW;
+    S3C24X0_REG32   CLKDIVN;
+    S3C24X0_REG32   CAMDIVN;    /* for s3c2440, by www.100ask.net */
 } /*__attribute__((__packed__))*/ S3C24X0_CLOCK_POWER;
 
 
 /* LCD CONTROLLER (see manual chapter 15) */
 typedef struct {
-	S3C24X0_REG32	LCDCON1;
-	S3C24X0_REG32	LCDCON2;
-	S3C24X0_REG32	LCDCON3;
-	S3C24X0_REG32	LCDCON4;
-	S3C24X0_REG32	LCDCON5;
-	S3C24X0_REG32	LCDSADDR1;
-	S3C24X0_REG32	LCDSADDR2;
-	S3C24X0_REG32	LCDSADDR3;
-	S3C24X0_REG32	REDLUT;
-	S3C24X0_REG32	GREENLUT;
-	S3C24X0_REG32	BLUELUT;
-	S3C24X0_REG32	res[8];
-	S3C24X0_REG32	DITHMODE;
-	S3C24X0_REG32	TPAL;
+    S3C24X0_REG32   LCDCON1;
+    S3C24X0_REG32   LCDCON2;
+    S3C24X0_REG32   LCDCON3;
+    S3C24X0_REG32   LCDCON4;
+    S3C24X0_REG32   LCDCON5;
+    S3C24X0_REG32   LCDSADDR1;
+    S3C24X0_REG32   LCDSADDR2;
+    S3C24X0_REG32   LCDSADDR3;
+    S3C24X0_REG32   REDLUT;
+    S3C24X0_REG32   GREENLUT;
+    S3C24X0_REG32   BLUELUT;
+    S3C24X0_REG32   res[8];
+    S3C24X0_REG32   DITHMODE;
+    S3C24X0_REG32   TPAL;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	LCDINTPND;
-	S3C24X0_REG32	LCDSRCPND;
-	S3C24X0_REG32	LCDINTMSK;
-	S3C24X0_REG32	LPCSEL;
+    S3C24X0_REG32   LCDINTPND;
+    S3C24X0_REG32   LCDSRCPND;
+    S3C24X0_REG32   LCDINTMSK;
+    S3C24X0_REG32   LPCSEL;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_LCD;
 
 
 /* NAND FLASH (see S3C2410 manual chapter 6) */
 typedef struct {
-	S3C24X0_REG32	NFCONF;
-	S3C24X0_REG32	NFCMD;
-	S3C24X0_REG32	NFADDR;
-	S3C24X0_REG32	NFDATA;
-	S3C24X0_REG32	NFSTAT;
-	S3C24X0_REG32	NFECC;
+    S3C24X0_REG32   NFCONF;
+    S3C24X0_REG32   NFCMD;
+    S3C24X0_REG32   NFADDR;
+    S3C24X0_REG32   NFDATA;
+    S3C24X0_REG32   NFSTAT;
+    S3C24X0_REG32   NFECC;
 } /*__attribute__((__packed__))*/ S3C2410_NAND;
 
+/* NAND FLASH (see S3C2440 manual chapter 6, www.100ask.net) */
+typedef struct {
+    S3C24X0_REG32   NFCONF;
+    S3C24X0_REG32   NFCONT;
+    S3C24X0_REG32   NFCMD;
+    S3C24X0_REG32   NFADDR;
+    S3C24X0_REG32   NFDATA;
+    S3C24X0_REG32   NFMECCD0;
+    S3C24X0_REG32   NFMECCD1;
+    S3C24X0_REG32   NFSECCD;
+    S3C24X0_REG32   NFSTAT;
+    S3C24X0_REG32   NFESTAT0;
+    S3C24X0_REG32   NFESTAT1;
+    S3C24X0_REG32   NFMECC0;
+    S3C24X0_REG32   NFMECC1;
+    S3C24X0_REG32   NFSECC;
+    S3C24X0_REG32   NFSBLK;
+    S3C24X0_REG32   NFEBLK;
+} /*__attribute__((__packed__))*/ S3C2440_NAND;
 
 /* UART (see manual chapter 11) */
 typedef struct {
-	S3C24X0_REG32	ULCON;
-	S3C24X0_REG32	UCON;
-	S3C24X0_REG32	UFCON;
-	S3C24X0_REG32	UMCON;
-	S3C24X0_REG32	UTRSTAT;
-	S3C24X0_REG32	UERSTAT;
-	S3C24X0_REG32	UFSTAT;
-	S3C24X0_REG32	UMSTAT;
+    S3C24X0_REG32   ULCON;
+    S3C24X0_REG32   UCON;
+    S3C24X0_REG32   UFCON;
+    S3C24X0_REG32   UMCON;
+    S3C24X0_REG32   UTRSTAT;
+    S3C24X0_REG32   UERSTAT;
+    S3C24X0_REG32   UFSTAT;
+    S3C24X0_REG32   UMSTAT;
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	UTXH;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	URXH;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    UTXH;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    URXH;
 #else /* Little Endian */
-	S3C24X0_REG8	UTXH;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	URXH;
-	S3C24X0_REG8	res2[3];
+    S3C24X0_REG8    UTXH;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    URXH;
+    S3C24X0_REG8    res2[3];
 #endif
-	S3C24X0_REG32	UBRDIV;
+    S3C24X0_REG32   UBRDIV;
 } /*__attribute__((__packed__))*/ S3C24X0_UART;
 
 
 /* PWM TIMER (see manual chapter 10) */
 typedef struct {
-	S3C24X0_REG32	TCNTB;
-	S3C24X0_REG32	TCMPB;
-	S3C24X0_REG32	TCNTO;
+    S3C24X0_REG32   TCNTB;
+    S3C24X0_REG32   TCMPB;
+    S3C24X0_REG32   TCNTO;
 } /*__attribute__((__packed__))*/ S3C24X0_TIMER;
 
 typedef struct {
-	S3C24X0_REG32	TCFG0;
-	S3C24X0_REG32	TCFG1;
-	S3C24X0_REG32	TCON;
-	S3C24X0_TIMER	ch[4];
-	S3C24X0_REG32	TCNTB4;
-	S3C24X0_REG32	TCNTO4;
+    S3C24X0_REG32   TCFG0;
+    S3C24X0_REG32   TCFG1;
+    S3C24X0_REG32   TCON;
+    S3C24X0_TIMER   ch[4];
+    S3C24X0_REG32   TCNTB4;
+    S3C24X0_REG32   TCNTO4;
 } /*__attribute__((__packed__))*/ S3C24X0_TIMERS;
 
 
 /* USB DEVICE (see manual chapter 13) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res[3];
-	S3C24X0_REG8	EP_FIFO_REG;
+    S3C24X0_REG8    res[3];
+    S3C24X0_REG8    EP_FIFO_REG;
 #else /*  little endian */
-	S3C24X0_REG8	EP_FIFO_REG;
-	S3C24X0_REG8	res[3];
+    S3C24X0_REG8    EP_FIFO_REG;
+    S3C24X0_REG8    res[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_USB_DEV_FIFOS;
 
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	EP_DMA_CON;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	EP_DMA_UNIT;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	EP_DMA_FIFO;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	EP_DMA_TTC_L;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	EP_DMA_TTC_M;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	EP_DMA_TTC_H;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    EP_DMA_CON;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    EP_DMA_UNIT;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    EP_DMA_FIFO;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    EP_DMA_TTC_L;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    EP_DMA_TTC_M;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    EP_DMA_TTC_H;
 #else /*  little endian */
-	S3C24X0_REG8	EP_DMA_CON;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	EP_DMA_UNIT;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	EP_DMA_FIFO;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	EP_DMA_TTC_L;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	EP_DMA_TTC_M;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	EP_DMA_TTC_H;
-	S3C24X0_REG8	res6[3];
+    S3C24X0_REG8    EP_DMA_CON;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    EP_DMA_UNIT;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    EP_DMA_FIFO;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    EP_DMA_TTC_L;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    EP_DMA_TTC_M;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    EP_DMA_TTC_H;
+    S3C24X0_REG8    res6[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_USB_DEV_DMAS;
 
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	FUNC_ADDR_REG;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	PWR_REG;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	EP_INT_REG;
-	S3C24X0_REG8	res4[15];
-	S3C24X0_REG8	USB_INT_REG;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	EP_INT_EN_REG;
-	S3C24X0_REG8	res6[15];
-	S3C24X0_REG8	USB_INT_EN_REG;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	FRAME_NUM1_REG;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	FRAME_NUM2_REG;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	INDEX_REG;
-	S3C24X0_REG8	res10[7];
-	S3C24X0_REG8	MAXP_REG;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	EP0_CSR_IN_CSR1_REG;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	IN_CSR2_REG;
-	S3C24X0_REG8	res13[7];
-	S3C24X0_REG8	OUT_CSR1_REG;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	OUT_CSR2_REG;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	OUT_FIFO_CNT1_REG;
-	S3C24X0_REG8	res16[3];
-	S3C24X0_REG8	OUT_FIFO_CNT2_REG;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    FUNC_ADDR_REG;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    PWR_REG;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    EP_INT_REG;
+    S3C24X0_REG8    res4[15];
+    S3C24X0_REG8    USB_INT_REG;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    EP_INT_EN_REG;
+    S3C24X0_REG8    res6[15];
+    S3C24X0_REG8    USB_INT_EN_REG;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    FRAME_NUM1_REG;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    FRAME_NUM2_REG;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    INDEX_REG;
+    S3C24X0_REG8    res10[7];
+    S3C24X0_REG8    MAXP_REG;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    EP0_CSR_IN_CSR1_REG;
+    S3C24X0_REG8    res12[3];
+    S3C24X0_REG8    IN_CSR2_REG;
+    S3C24X0_REG8    res13[7];
+    S3C24X0_REG8    OUT_CSR1_REG;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    OUT_CSR2_REG;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    OUT_FIFO_CNT1_REG;
+    S3C24X0_REG8    res16[3];
+    S3C24X0_REG8    OUT_FIFO_CNT2_REG;
 #else /*  little endian */
-	S3C24X0_REG8	FUNC_ADDR_REG;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	PWR_REG;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	EP_INT_REG;
-	S3C24X0_REG8	res3[15];
-	S3C24X0_REG8	USB_INT_REG;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	EP_INT_EN_REG;
-	S3C24X0_REG8	res5[15];
-	S3C24X0_REG8	USB_INT_EN_REG;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	FRAME_NUM1_REG;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	FRAME_NUM2_REG;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	INDEX_REG;
-	S3C24X0_REG8	res9[7];
-	S3C24X0_REG8	MAXP_REG;
-	S3C24X0_REG8	res10[7];
-	S3C24X0_REG8	EP0_CSR_IN_CSR1_REG;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	IN_CSR2_REG;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	OUT_CSR1_REG;
-	S3C24X0_REG8	res13[7];
-	S3C24X0_REG8	OUT_CSR2_REG;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	OUT_FIFO_CNT1_REG;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	OUT_FIFO_CNT2_REG;
-	S3C24X0_REG8	res16[3];
+    S3C24X0_REG8    FUNC_ADDR_REG;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    PWR_REG;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    EP_INT_REG;
+    S3C24X0_REG8    res3[15];
+    S3C24X0_REG8    USB_INT_REG;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    EP_INT_EN_REG;
+    S3C24X0_REG8    res5[15];
+    S3C24X0_REG8    USB_INT_EN_REG;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    FRAME_NUM1_REG;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    FRAME_NUM2_REG;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    INDEX_REG;
+    S3C24X0_REG8    res9[7];
+    S3C24X0_REG8    MAXP_REG;
+    S3C24X0_REG8    res10[3];
+    S3C24X0_REG8    EP0_CSR_IN_CSR1_REG;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    IN_CSR2_REG;
+    S3C24X0_REG8    res12[7];
+    S3C24X0_REG8    OUT_CSR1_REG;
+    S3C24X0_REG8    res13[3];
+    S3C24X0_REG8    OUT_CSR2_REG;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    OUT_FIFO_CNT1_REG;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    OUT_FIFO_CNT2_REG;
+    S3C24X0_REG8    res16[3];
 #endif /*  __BIG_ENDIAN */
-	S3C24X0_USB_DEV_FIFOS	fifo[5];
-	S3C24X0_USB_DEV_DMAS	dma[5];
+    S3C24X0_REG32   res17[8];
+    S3C24X0_USB_DEV_FIFOS   fifo[5];
+    S3C24X0_REG32   res18[11];
+    S3C24X0_USB_DEV_DMAS    ep1;
+    S3C24X0_USB_DEV_DMAS    ep2;
+    S3C24X0_REG8    res19[16];
+    S3C24X0_USB_DEV_DMAS    ep3;
+    S3C24X0_USB_DEV_DMAS    ep4;
 } /*__attribute__((__packed__))*/ S3C24X0_USB_DEVICE;
 
 
 /* WATCH DOG TIMER (see manual chapter 18) */
 typedef struct {
-	S3C24X0_REG32	WTCON;
-	S3C24X0_REG32	WTDAT;
-	S3C24X0_REG32	WTCNT;
+    S3C24X0_REG32   WTCON;
+    S3C24X0_REG32   WTDAT;
+    S3C24X0_REG32   WTCNT;
 } /*__attribute__((__packed__))*/ S3C24X0_WATCHDOG;
 
 
 /* IIC (see manual chapter 20) */
 typedef struct {
-	S3C24X0_REG32	IICCON;
-	S3C24X0_REG32	IICSTAT;
-	S3C24X0_REG32	IICADD;
-	S3C24X0_REG32	IICDS;
+    S3C24X0_REG32   IICCON;
+    S3C24X0_REG32   IICSTAT;
+    S3C24X0_REG32   IICADD;
+    S3C24X0_REG32   IICDS;
 } /*__attribute__((__packed__))*/ S3C24X0_I2C;
 
 
 /* IIS (see manual chapter 21) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG16	res1;
-	S3C24X0_REG16	IISCON;
-	S3C24X0_REG16	res2;
-	S3C24X0_REG16	IISMOD;
-	S3C24X0_REG16	res3;
-	S3C24X0_REG16	IISPSR;
-	S3C24X0_REG16	res4;
-	S3C24X0_REG16	IISFCON;
-	S3C24X0_REG16	res5;
-	S3C24X0_REG16	IISFIFO;
+    S3C24X0_REG16   res1;
+    S3C24X0_REG16   IISCON;
+    S3C24X0_REG16   res2;
+    S3C24X0_REG16   IISMOD;
+    S3C24X0_REG16   res3;
+    S3C24X0_REG16   IISPSR;
+    S3C24X0_REG16   res4;
+    S3C24X0_REG16   IISFCON;
+    S3C24X0_REG16   res5;
+    S3C24X0_REG16   IISFIFO;
 #else /*  little endian */
-	S3C24X0_REG16	IISCON;
-	S3C24X0_REG16	res1;
-	S3C24X0_REG16	IISMOD;
-	S3C24X0_REG16	res2;
-	S3C24X0_REG16	IISPSR;
-	S3C24X0_REG16	res3;
-	S3C24X0_REG16	IISFCON;
-	S3C24X0_REG16	res4;
-	S3C24X0_REG16	IISFIFO;
-	S3C24X0_REG16	res5;
+    S3C24X0_REG16   IISCON;
+    S3C24X0_REG16   res1;
+    S3C24X0_REG16   IISMOD;
+    S3C24X0_REG16   res2;
+    S3C24X0_REG16   IISPSR;
+    S3C24X0_REG16   res3;
+    S3C24X0_REG16   IISFCON;
+    S3C24X0_REG16   res4;
+    S3C24X0_REG16   IISFIFO;
+    S3C24X0_REG16   res5;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_I2S;
 
@@ -369,87 +395,93 @@
 /* I/O PORT (see manual chapter 9) */
 typedef struct {
 #ifdef CONFIG_S3C2400
-	S3C24X0_REG32	PACON;
-	S3C24X0_REG32	PADAT;
+    S3C24X0_REG32   PACON;
+    S3C24X0_REG32   PADAT;
 
-	S3C24X0_REG32	PBCON;
-	S3C24X0_REG32	PBDAT;
-	S3C24X0_REG32	PBUP;
+    S3C24X0_REG32   PBCON;
+    S3C24X0_REG32   PBDAT;
+    S3C24X0_REG32   PBUP;
 
-	S3C24X0_REG32	PCCON;
-	S3C24X0_REG32	PCDAT;
-	S3C24X0_REG32	PCUP;
+    S3C24X0_REG32   PCCON;
+    S3C24X0_REG32   PCDAT;
+    S3C24X0_REG32   PCUP;
 
-	S3C24X0_REG32	PDCON;
-	S3C24X0_REG32	PDDAT;
-	S3C24X0_REG32	PDUP;
+    S3C24X0_REG32   PDCON;
+    S3C24X0_REG32   PDDAT;
+    S3C24X0_REG32   PDUP;
 
-	S3C24X0_REG32	PECON;
-	S3C24X0_REG32	PEDAT;
-	S3C24X0_REG32	PEUP;
+    S3C24X0_REG32   PECON;
+    S3C24X0_REG32   PEDAT;
+    S3C24X0_REG32   PEUP;
 
-	S3C24X0_REG32	PFCON;
-	S3C24X0_REG32	PFDAT;
-	S3C24X0_REG32	PFUP;
+    S3C24X0_REG32   PFCON;
+    S3C24X0_REG32   PFDAT;
+    S3C24X0_REG32   PFUP;
 
-	S3C24X0_REG32	PGCON;
-	S3C24X0_REG32	PGDAT;
-	S3C24X0_REG32	PGUP;
+    S3C24X0_REG32   PGCON;
+    S3C24X0_REG32   PGDAT;
+    S3C24X0_REG32   PGUP;
 
-	S3C24X0_REG32	OPENCR;
+    S3C24X0_REG32   OPENCR;
 
-	S3C24X0_REG32	MISCCR;
-	S3C24X0_REG32	EXTINT;
+    S3C24X0_REG32   MISCCR;
+    S3C24X0_REG32   EXTINT;
 #endif
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	GPACON;
-	S3C24X0_REG32	GPADAT;
-	S3C24X0_REG32	res1[2];
-	S3C24X0_REG32	GPBCON;
-	S3C24X0_REG32	GPBDAT;
-	S3C24X0_REG32	GPBUP;
-	S3C24X0_REG32	res2;
-	S3C24X0_REG32	GPCCON;
-	S3C24X0_REG32	GPCDAT;
-	S3C24X0_REG32	GPCUP;
-	S3C24X0_REG32	res3;
-	S3C24X0_REG32	GPDCON;
-	S3C24X0_REG32	GPDDAT;
-	S3C24X0_REG32	GPDUP;
-	S3C24X0_REG32	res4;
-	S3C24X0_REG32	GPECON;
-	S3C24X0_REG32	GPEDAT;
-	S3C24X0_REG32	GPEUP;
-	S3C24X0_REG32	res5;
-	S3C24X0_REG32	GPFCON;
-	S3C24X0_REG32	GPFDAT;
-	S3C24X0_REG32	GPFUP;
-	S3C24X0_REG32	res6;
-	S3C24X0_REG32	GPGCON;
-	S3C24X0_REG32	GPGDAT;
-	S3C24X0_REG32	GPGUP;
-	S3C24X0_REG32	res7;
-	S3C24X0_REG32	GPHCON;
-	S3C24X0_REG32	GPHDAT;
-	S3C24X0_REG32	GPHUP;
-	S3C24X0_REG32	res8;
-
-	S3C24X0_REG32	MISCCR;
-	S3C24X0_REG32	DCLKCON;
-	S3C24X0_REG32	EXTINT0;
-	S3C24X0_REG32	EXTINT1;
-	S3C24X0_REG32	EXTINT2;
-	S3C24X0_REG32	EINTFLT0;
-	S3C24X0_REG32	EINTFLT1;
-	S3C24X0_REG32	EINTFLT2;
-	S3C24X0_REG32	EINTFLT3;
-	S3C24X0_REG32	EINTMASK;
-	S3C24X0_REG32	EINTPEND;
-	S3C24X0_REG32	GSTATUS0;
-	S3C24X0_REG32	GSTATUS1;
-	S3C24X0_REG32	GSTATUS2;
-	S3C24X0_REG32	GSTATUS3;
-	S3C24X0_REG32	GSTATUS4;
+    S3C24X0_REG32   GPACON;
+    S3C24X0_REG32   GPADAT;
+    S3C24X0_REG32   res1[2];
+    S3C24X0_REG32   GPBCON;
+    S3C24X0_REG32   GPBDAT;
+    S3C24X0_REG32   GPBUP;
+    S3C24X0_REG32   res2;
+    S3C24X0_REG32   GPCCON;
+    S3C24X0_REG32   GPCDAT;
+    S3C24X0_REG32   GPCUP;
+    S3C24X0_REG32   res3;
+    S3C24X0_REG32   GPDCON;
+    S3C24X0_REG32   GPDDAT;
+    S3C24X0_REG32   GPDUP;
+    S3C24X0_REG32   res4;
+    S3C24X0_REG32   GPECON;
+    S3C24X0_REG32   GPEDAT;
+    S3C24X0_REG32   GPEUP;
+    S3C24X0_REG32   res5;
+    S3C24X0_REG32   GPFCON;
+    S3C24X0_REG32   GPFDAT;
+    S3C24X0_REG32   GPFUP;
+    S3C24X0_REG32   res6;
+    S3C24X0_REG32   GPGCON;
+    S3C24X0_REG32   GPGDAT;
+    S3C24X0_REG32   GPGUP;
+    S3C24X0_REG32   res7;
+    S3C24X0_REG32   GPHCON;
+    S3C24X0_REG32   GPHDAT;
+    S3C24X0_REG32   GPHUP;
+    S3C24X0_REG32   res8;
+
+    S3C24X0_REG32   MISCCR;
+    S3C24X0_REG32   DCLKCON;
+    S3C24X0_REG32   EXTINT0;
+    S3C24X0_REG32   EXTINT1;
+    S3C24X0_REG32   EXTINT2;
+    S3C24X0_REG32   EINTFLT0;
+    S3C24X0_REG32   EINTFLT1;
+    S3C24X0_REG32   EINTFLT2;
+    S3C24X0_REG32   EINTFLT3;
+    S3C24X0_REG32   EINTMASK;
+    S3C24X0_REG32   EINTPEND;
+    S3C24X0_REG32   GSTATUS0;
+    S3C24X0_REG32   GSTATUS1;
+    S3C24X0_REG32   GSTATUS2;
+    S3C24X0_REG32   GSTATUS3;
+    S3C24X0_REG32   GSTATUS4;
+
+    /* s3c2440 */
+    S3C24X0_REG32   res9[4];
+    S3C24X0_REG32   GPJCON;
+    S3C24X0_REG32   GPJDAT;
+    S3C24X0_REG32   GPJUP;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_GPIO;
 
@@ -457,679 +489,685 @@
 /* RTC (see manual chapter 17) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[67];
-	S3C24X0_REG8	RTCCON;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	TICNT;
-	S3C24X0_REG8	res3[11];
-	S3C24X0_REG8	RTCALM;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	ALMSEC;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	ALMMIN;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	ALMHOUR;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	ALMDATE;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	ALMMON;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	ALMYEAR;
-	S3C24X0_REG8	res10[3];
-	S3C24X0_REG8	RTCRST;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	BCDSEC;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	BCDMIN;
-	S3C24X0_REG8	res13[3];
-	S3C24X0_REG8	BCDHOUR;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	BCDDATE;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	BCDDAY;
-	S3C24X0_REG8	res16[3];
-	S3C24X0_REG8	BCDMON;
-	S3C24X0_REG8	res17[3];
-	S3C24X0_REG8	BCDYEAR;
+    S3C24X0_REG8    res1[67];
+    S3C24X0_REG8    RTCCON;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    TICNT;
+    S3C24X0_REG8    res3[11];
+    S3C24X0_REG8    RTCALM;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    ALMSEC;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    ALMMIN;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    ALMHOUR;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    ALMDATE;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    ALMMON;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    ALMYEAR;
+    S3C24X0_REG8    res10[3];
+    S3C24X0_REG8    RTCRST;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    BCDSEC;
+    S3C24X0_REG8    res12[3];
+    S3C24X0_REG8    BCDMIN;
+    S3C24X0_REG8    res13[3];
+    S3C24X0_REG8    BCDHOUR;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    BCDDATE;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    BCDDAY;
+    S3C24X0_REG8    res16[3];
+    S3C24X0_REG8    BCDMON;
+    S3C24X0_REG8    res17[3];
+    S3C24X0_REG8    BCDYEAR;
 #else /*  little endian */
-	S3C24X0_REG8	res0[64];
-	S3C24X0_REG8	RTCCON;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	TICNT;
-	S3C24X0_REG8	res2[11];
-	S3C24X0_REG8	RTCALM;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	ALMSEC;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	ALMMIN;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	ALMHOUR;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	ALMDATE;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	ALMMON;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	ALMYEAR;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	RTCRST;
-	S3C24X0_REG8	res10[3];
-	S3C24X0_REG8	BCDSEC;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	BCDMIN;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	BCDHOUR;
-	S3C24X0_REG8	res13[3];
-	S3C24X0_REG8	BCDDATE;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	BCDDAY;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	BCDMON;
-	S3C24X0_REG8	res16[3];
-	S3C24X0_REG8	BCDYEAR;
-	S3C24X0_REG8	res17[3];
+    S3C24X0_REG8    res0[64];
+    S3C24X0_REG8    RTCCON;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    TICNT;
+    S3C24X0_REG8    res2[11];
+    S3C24X0_REG8    RTCALM;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    ALMSEC;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    ALMMIN;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    ALMHOUR;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    ALMDATE;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    ALMMON;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    ALMYEAR;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    RTCRST;
+    S3C24X0_REG8    res10[3];
+    S3C24X0_REG8    BCDSEC;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    BCDMIN;
+    S3C24X0_REG8    res12[3];
+    S3C24X0_REG8    BCDHOUR;
+    S3C24X0_REG8    res13[3];
+    S3C24X0_REG8    BCDDATE;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    BCDDAY;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    BCDMON;
+    S3C24X0_REG8    res16[3];
+    S3C24X0_REG8    BCDYEAR;
+    S3C24X0_REG8    res17[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_RTC;
 
 
 /* ADC (see manual chapter 16) */
 typedef struct {
-	S3C24X0_REG32	ADCCON;
-	S3C24X0_REG32	ADCDAT;
+    S3C24X0_REG32   ADCCON;
+    S3C24X0_REG32   ADCDAT;
 } /*__attribute__((__packed__))*/ S3C2400_ADC;
 
 
 /* ADC (see manual chapter 16) */
 typedef struct {
-	S3C24X0_REG32	ADCCON;
-	S3C24X0_REG32	ADCTSC;
-	S3C24X0_REG32	ADCDLY;
-	S3C24X0_REG32	ADCDAT0;
-	S3C24X0_REG32	ADCDAT1;
+    S3C24X0_REG32   ADCCON;
+    S3C24X0_REG32   ADCTSC;
+    S3C24X0_REG32   ADCDLY;
+    S3C24X0_REG32   ADCDAT0;
+    S3C24X0_REG32   ADCDAT1;
 } /*__attribute__((__packed__))*/ S3C2410_ADC;
 
 
 /* SPI (see manual chapter 22) */
 typedef struct {
-	S3C24X0_REG32	SPCON;
-	S3C24X0_REG32	SPSTA;
-	S3C24X0_REG32	SPPIN;
-	S3C24X0_REG32	SPPRE;
-	S3C24X0_REG32	SPTDAT;
-	S3C24X0_REG32	SPRDAT;
-	S3C24X0_REG32	res[2];
+    S3C24X0_REG32   SPCON;
+    S3C24X0_REG32   SPSTA;
+    S3C24X0_REG32   SPPIN;
+    S3C24X0_REG32   SPPRE;
+    S3C24X0_REG32   SPTDAT;
+    S3C24X0_REG32   SPRDAT;
+    S3C24X0_REG32   res[2];
 } __attribute__((__packed__)) S3C24X0_SPI_CHANNEL;
 
 typedef struct {
-	S3C24X0_SPI_CHANNEL	ch[S3C24X0_SPI_CHANNELS];
+    S3C24X0_SPI_CHANNEL ch[2];
 } /*__attribute__((__packed__))*/ S3C24X0_SPI;
 
 
 /* MMC INTERFACE (see S3C2400 manual chapter 19) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	MMCON;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	MMCRR;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	MMFCON;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	MMSTA;
-	S3C24X0_REG16	res5;
-	S3C24X0_REG16	MMFSTA;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	MMPRE;
-	S3C24X0_REG16	res7;
-	S3C24X0_REG16	MMLEN;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	MMCR7;
-	S3C24X0_REG32	MMRSP[4];
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	MMCMD0;
-	S3C24X0_REG32	MMCMD1;
-	S3C24X0_REG16	res10;
-	S3C24X0_REG16	MMCR16;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	MMDAT;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    MMCON;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    MMCRR;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    MMFCON;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    MMSTA;
+    S3C24X0_REG16   res5;
+    S3C24X0_REG16   MMFSTA;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    MMPRE;
+    S3C24X0_REG16   res7;
+    S3C24X0_REG16   MMLEN;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    MMCR7;
+    S3C24X0_REG32   MMRSP[4];
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    MMCMD0;
+    S3C24X0_REG32   MMCMD1;
+    S3C24X0_REG16   res10;
+    S3C24X0_REG16   MMCR16;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    MMDAT;
 #else
-	S3C24X0_REG8	MMCON;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	MMCRR;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	MMFCON;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	MMSTA;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG16	MMFSTA;
-	S3C24X0_REG16	res5;
-	S3C24X0_REG8	MMPRE;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG16	MMLEN;
-	S3C24X0_REG16	res7;
-	S3C24X0_REG8	MMCR7;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG32	MMRSP[4];
-	S3C24X0_REG8	MMCMD0;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG32	MMCMD1;
-	S3C24X0_REG16	MMCR16;
-	S3C24X0_REG16	res10;
-	S3C24X0_REG8	MMDAT;
-	S3C24X0_REG8	res11[3];
+    S3C24X0_REG8    MMCON;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    MMCRR;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    MMFCON;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    MMSTA;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG16   MMFSTA;
+    S3C24X0_REG16   res5;
+    S3C24X0_REG8    MMPRE;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG16   MMLEN;
+    S3C24X0_REG16   res7;
+    S3C24X0_REG8    MMCR7;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG32   MMRSP[4];
+    S3C24X0_REG8    MMCMD0;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG32   MMCMD1;
+    S3C24X0_REG16   MMCR16;
+    S3C24X0_REG16   res10;
+    S3C24X0_REG8    MMDAT;
+    S3C24X0_REG8    res11[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C2400_MMC;
 
 
 /* SD INTERFACE (see S3C2410 manual chapter 19) */
 typedef struct {
-	S3C24X0_REG32	SDICON;
-	S3C24X0_REG32	SDIPRE;
-	S3C24X0_REG32	SDICARG;
-	S3C24X0_REG32	SDICCON;
-	S3C24X0_REG32	SDICSTA;
-	S3C24X0_REG32	SDIRSP0;
-	S3C24X0_REG32	SDIRSP1;
-	S3C24X0_REG32	SDIRSP2;
-	S3C24X0_REG32	SDIRSP3;
-	S3C24X0_REG32	SDIDTIMER;
-	S3C24X0_REG32	SDIBSIZE;
-	S3C24X0_REG32	SDIDCON;
-	S3C24X0_REG32	SDIDCNT;
-	S3C24X0_REG32	SDIDSTA;
-	S3C24X0_REG32	SDIFSTA;
+    S3C24X0_REG32   SDICON;
+    S3C24X0_REG32   SDIPRE;
+    S3C24X0_REG32   SDICARG;
+    S3C24X0_REG32   SDICCON;
+    S3C24X0_REG32   SDICSTA;
+    S3C24X0_REG32   SDIRSP0;
+    S3C24X0_REG32   SDIRSP1;
+    S3C24X0_REG32   SDIRSP2;
+    S3C24X0_REG32   SDIRSP3;
+    S3C24X0_REG32   SDIDTIMER;
+    S3C24X0_REG32   SDIBSIZE;
+    S3C24X0_REG32   SDIDCON;
+    S3C24X0_REG32   SDIDCNT;
+    S3C24X0_REG32   SDIDSTA;
+    S3C24X0_REG32   SDIFSTA;
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res[3];
-	S3C24X0_REG8	SDIDAT;
+    S3C24X0_REG8    res[3];
+    S3C24X0_REG8    SDIDAT;
 #else
-	S3C24X0_REG8	SDIDAT;
-	S3C24X0_REG8	res[3];
+    S3C24X0_REG8    SDIDAT;
+    S3C24X0_REG8    res[3];
 #endif
-	S3C24X0_REG32	SDIIMSK;
+    S3C24X0_REG32   SDIIMSK;
 } /*__attribute__((__packed__))*/ S3C2410_SDI;
 
 
-#if 0
+#if 1
 /* Memory control */
-#define rBWSCON			(*(volatile unsigned *)0x48000000)
-#define rBANKCON0		(*(volatile unsigned *)0x48000004)
-#define rBANKCON1		(*(volatile unsigned *)0x48000008)
-#define rBANKCON2		(*(volatile unsigned *)0x4800000C)
-#define rBANKCON3		(*(volatile unsigned *)0x48000010)
-#define rBANKCON4		(*(volatile unsigned *)0x48000014)
-#define rBANKCON5		(*(volatile unsigned *)0x48000018)
-#define rBANKCON6		(*(volatile unsigned *)0x4800001C)
-#define rBANKCON7		(*(volatile unsigned *)0x48000020)
-#define rREFRESH		(*(volatile unsigned *)0x48000024)
-#define rBANKSIZE		(*(volatile unsigned *)0x48000028)
-#define rMRSRB6			(*(volatile unsigned *)0x4800002C)
-#define rMRSRB7			(*(volatile unsigned *)0x48000030)
+#define rBWSCON         (*(volatile unsigned *)0x48000000)
+#define rBANKCON0       (*(volatile unsigned *)0x48000004)
+#define rBANKCON1       (*(volatile unsigned *)0x48000008)
+#define rBANKCON2       (*(volatile unsigned *)0x4800000C)
+#define rBANKCON3       (*(volatile unsigned *)0x48000010)
+#define rBANKCON4       (*(volatile unsigned *)0x48000014)
+#define rBANKCON5       (*(volatile unsigned *)0x48000018)
+#define rBANKCON6       (*(volatile unsigned *)0x4800001C)
+#define rBANKCON7       (*(volatile unsigned *)0x48000020)
+#define rREFRESH        (*(volatile unsigned *)0x48000024)
+#define rBANKSIZE       (*(volatile unsigned *)0x48000028)
+#define rMRSRB6         (*(volatile unsigned *)0x4800002C)
+#define rMRSRB7         (*(volatile unsigned *)0x48000030)
 
 
 /* USB HOST */
-#define rHcRevision		(*(volatile unsigned *)0x49000000)
-#define rHcControl		(*(volatile unsigned *)0x49000004)
-#define rHcCommonStatus		(*(volatile unsigned *)0x49000008)
-#define rHcInterruptStatus	(*(volatile unsigned *)0x4900000C)
-#define rHcInterruptEnable	(*(volatile unsigned *)0x49000010)
-#define rHcInterruptDisable	(*(volatile unsigned *)0x49000014)
-#define rHcHCCA			(*(volatile unsigned *)0x49000018)
-#define rHcPeriodCuttendED	(*(volatile unsigned *)0x4900001C)
-#define rHcControlHeadED	(*(volatile unsigned *)0x49000020)
-#define rHcControlCurrentED	(*(volatile unsigned *)0x49000024)
-#define rHcBulkHeadED		(*(volatile unsigned *)0x49000028)
-#define rHcBuldCurrentED	(*(volatile unsigned *)0x4900002C)
-#define rHcDoneHead		(*(volatile unsigned *)0x49000030)
-#define rHcRmInterval		(*(volatile unsigned *)0x49000034)
-#define rHcFmRemaining		(*(volatile unsigned *)0x49000038)
-#define rHcFmNumber		(*(volatile unsigned *)0x4900003C)
-#define rHcPeriodicStart	(*(volatile unsigned *)0x49000040)
-#define rHcLSThreshold		(*(volatile unsigned *)0x49000044)
-#define rHcRhDescriptorA	(*(volatile unsigned *)0x49000048)
-#define rHcRhDescriptorB	(*(volatile unsigned *)0x4900004C)
-#define rHcRhStatus		(*(volatile unsigned *)0x49000050)
-#define rHcRhPortStatus1	(*(volatile unsigned *)0x49000054)
-#define rHcRhPortStatus2	(*(volatile unsigned *)0x49000058)
+#define rHcRevision     (*(volatile unsigned *)0x49000000)
+#define rHcControl      (*(volatile unsigned *)0x49000004)
+#define rHcCommonStatus     (*(volatile unsigned *)0x49000008)
+#define rHcInterruptStatus  (*(volatile unsigned *)0x4900000C)
+#define rHcInterruptEnable  (*(volatile unsigned *)0x49000010)
+#define rHcInterruptDisable (*(volatile unsigned *)0x49000014)
+#define rHcHCCA         (*(volatile unsigned *)0x49000018)
+#define rHcPeriodCuttendED  (*(volatile unsigned *)0x4900001C)
+#define rHcControlHeadED    (*(volatile unsigned *)0x49000020)
+#define rHcControlCurrentED (*(volatile unsigned *)0x49000024)
+#define rHcBulkHeadED       (*(volatile unsigned *)0x49000028)
+#define rHcBuldCurrentED    (*(volatile unsigned *)0x4900002C)
+#define rHcDoneHead     (*(volatile unsigned *)0x49000030)
+#define rHcRmInterval       (*(volatile unsigned *)0x49000034)
+#define rHcFmRemaining      (*(volatile unsigned *)0x49000038)
+#define rHcFmNumber     (*(volatile unsigned *)0x4900003C)
+#define rHcPeriodicStart    (*(volatile unsigned *)0x49000040)
+#define rHcLSThreshold      (*(volatile unsigned *)0x49000044)
+#define rHcRhDescriptorA    (*(volatile unsigned *)0x49000048)
+#define rHcRhDescriptorB    (*(volatile unsigned *)0x4900004C)
+#define rHcRhStatus     (*(volatile unsigned *)0x49000050)
+#define rHcRhPortStatus1    (*(volatile unsigned *)0x49000054)
+#define rHcRhPortStatus2    (*(volatile unsigned *)0x49000058)
 
 
 /* INTERRUPT */
-#define rSRCPND			(*(volatile unsigned *)0x4A000000)
-#define rINTMOD			(*(volatile unsigned *)0x4A000004)
-#define rINTMSK			(*(volatile unsigned *)0x4A000008)
-#define rPRIORITY		(*(volatile unsigned *)0x4A00000C)
-#define rINTPND			(*(volatile unsigned *)0x4A000010)
-#define rINTOFFSET		(*(volatile unsigned *)0x4A000014)
-#define rSUBSRCPND		(*(volatile unsigned *)0x4A000018)
-#define rINTSUBMSK		(*(volatile unsigned *)0x4A00001C)
+#define rSRCPND         (*(volatile unsigned *)0x4A000000)
+#define rINTMOD         (*(volatile unsigned *)0x4A000004)
+#define rINTMSK         (*(volatile unsigned *)0x4A000008)
+#define rPRIORITY       (*(volatile unsigned *)0x4A00000C)
+#define rINTPND         (*(volatile unsigned *)0x4A000010)
+#define rINTOFFSET      (*(volatile unsigned *)0x4A000014)
+#define rSUBSRCPND      (*(volatile unsigned *)0x4A000018)
+#define rINTSUBMSK      (*(volatile unsigned *)0x4A00001C)
 
 
 /* DMA */
-#define rDISRC0			(*(volatile unsigned *)0x4B000000)
-#define rDISRCC0		(*(volatile unsigned *)0x4B000004)
-#define rDIDST0			(*(volatile unsigned *)0x4B000008)
-#define rDIDSTC0		(*(volatile unsigned *)0x4B00000C)
-#define rDCON0			(*(volatile unsigned *)0x4B000010)
-#define rDSTAT0			(*(volatile unsigned *)0x4B000014)
-#define rDCSRC0			(*(volatile unsigned *)0x4B000018)
-#define rDCDST0			(*(volatile unsigned *)0x4B00001C)
-#define rDMASKTRIG0		(*(volatile unsigned *)0x4B000020)
-#define rDISRC1			(*(volatile unsigned *)0x4B000040)
-#define rDISRCC1		(*(volatile unsigned *)0x4B000044)
-#define rDIDST1			(*(volatile unsigned *)0x4B000048)
-#define rDIDSTC1		(*(volatile unsigned *)0x4B00004C)
-#define rDCON1			(*(volatile unsigned *)0x4B000050)
-#define rDSTAT1			(*(volatile unsigned *)0x4B000054)
-#define rDCSRC1			(*(volatile unsigned *)0x4B000058)
-#define rDCDST1			(*(volatile unsigned *)0x4B00005C)
-#define rDMASKTRIG1		(*(volatile unsigned *)0x4B000060)
-#define rDISRC2			(*(volatile unsigned *)0x4B000080)
-#define rDISRCC2		(*(volatile unsigned *)0x4B000084)
-#define rDIDST2			(*(volatile unsigned *)0x4B000088)
-#define rDIDSTC2		(*(volatile unsigned *)0x4B00008C)
-#define rDCON2			(*(volatile unsigned *)0x4B000090)
-#define rDSTAT2			(*(volatile unsigned *)0x4B000094)
-#define rDCSRC2			(*(volatile unsigned *)0x4B000098)
-#define rDCDST2			(*(volatile unsigned *)0x4B00009C)
-#define rDMASKTRIG2		(*(volatile unsigned *)0x4B0000A0)
-#define rDISRC3			(*(volatile unsigned *)0x4B0000C0)
-#define rDISRCC3		(*(volatile unsigned *)0x4B0000C4)
-#define rDIDST3			(*(volatile unsigned *)0x4B0000C8)
-#define rDIDSTC3		(*(volatile unsigned *)0x4B0000CC)
-#define rDCON3			(*(volatile unsigned *)0x4B0000D0)
-#define rDSTAT3			(*(volatile unsigned *)0x4B0000D4)
-#define rDCSRC3			(*(volatile unsigned *)0x4B0000D8)
-#define rDCDST3			(*(volatile unsigned *)0x4B0000DC)
-#define rDMASKTRIG3		(*(volatile unsigned *)0x4B0000E0)
+#define rDISRC0         (*(volatile unsigned *)0x4B000000)
+#define rDISRCC0        (*(volatile unsigned *)0x4B000004)
+#define rDIDST0         (*(volatile unsigned *)0x4B000008)
+#define rDIDSTC0        (*(volatile unsigned *)0x4B00000C)
+#define rDCON0          (*(volatile unsigned *)0x4B000010)
+#define rDSTAT0         (*(volatile unsigned *)0x4B000014)
+#define rDCSRC0         (*(volatile unsigned *)0x4B000018)
+#define rDCDST0         (*(volatile unsigned *)0x4B00001C)
+#define rDMASKTRIG0     (*(volatile unsigned *)0x4B000020)
+#define rDISRC1         (*(volatile unsigned *)0x4B000040)
+#define rDISRCC1        (*(volatile unsigned *)0x4B000044)
+#define rDIDST1         (*(volatile unsigned *)0x4B000048)
+#define rDIDSTC1        (*(volatile unsigned *)0x4B00004C)
+#define rDCON1          (*(volatile unsigned *)0x4B000050)
+#define rDSTAT1         (*(volatile unsigned *)0x4B000054)
+#define rDCSRC1         (*(volatile unsigned *)0x4B000058)
+#define rDCDST1         (*(volatile unsigned *)0x4B00005C)
+#define rDMASKTRIG1     (*(volatile unsigned *)0x4B000060)
+#define rDISRC2         (*(volatile unsigned *)0x4B000080)
+#define rDISRCC2        (*(volatile unsigned *)0x4B000084)
+#define rDIDST2         (*(volatile unsigned *)0x4B000088)
+#define rDIDSTC2        (*(volatile unsigned *)0x4B00008C)
+#define rDCON2          (*(volatile unsigned *)0x4B000090)
+#define rDSTAT2         (*(volatile unsigned *)0x4B000094)
+#define rDCSRC2         (*(volatile unsigned *)0x4B000098)
+#define rDCDST2         (*(volatile unsigned *)0x4B00009C)
+#define rDMASKTRIG2     (*(volatile unsigned *)0x4B0000A0)
+#define rDISRC3         (*(volatile unsigned *)0x4B0000C0)
+#define rDISRCC3        (*(volatile unsigned *)0x4B0000C4)
+#define rDIDST3         (*(volatile unsigned *)0x4B0000C8)
+#define rDIDSTC3        (*(volatile unsigned *)0x4B0000CC)
+#define rDCON3          (*(volatile unsigned *)0x4B0000D0)
+#define rDSTAT3         (*(volatile unsigned *)0x4B0000D4)
+#define rDCSRC3         (*(volatile unsigned *)0x4B0000D8)
+#define rDCDST3         (*(volatile unsigned *)0x4B0000DC)
+#define rDMASKTRIG3     (*(volatile unsigned *)0x4B0000E0)
 
 
 /* CLOCK & POWER MANAGEMENT */
-#define rLOCKTIME		(*(volatile unsigned *)0x4C000000)
-#define rMPLLCON		(*(volatile unsigned *)0x4C000004)
-#define rUPLLCON		(*(volatile unsigned *)0x4C000008)
-#define rCLKCON			(*(volatile unsigned *)0x4C00000C)
-#define rCLKSLOW		(*(volatile unsigned *)0x4C000010)
-#define rCLKDIVN		(*(volatile unsigned *)0x4C000014)
+#define rLOCKTIME       (*(volatile unsigned *)0x4C000000)
+#define rMPLLCON        (*(volatile unsigned *)0x4C000004)
+#define rUPLLCON        (*(volatile unsigned *)0x4C000008)
+#define rCLKCON         (*(volatile unsigned *)0x4C00000C)
+#define rCLKSLOW        (*(volatile unsigned *)0x4C000010)
+#define rCLKDIVN        (*(volatile unsigned *)0x4C000014)
 
 
 /* LCD CONTROLLER */
-#define rLCDCON1		(*(volatile unsigned *)0x4D000000)
-#define rLCDCON2		(*(volatile unsigned *)0x4D000004)
-#define rLCDCON3		(*(volatile unsigned *)0x4D000008)
-#define rLCDCON4		(*(volatile unsigned *)0x4D00000C)
-#define rLCDCON5		(*(volatile unsigned *)0x4D000010)
-#define rLCDSADDR1		(*(volatile unsigned *)0x4D000014)
-#define rLCDSADDR2		(*(volatile unsigned *)0x4D000018)
-#define rLCDSADDR3		(*(volatile unsigned *)0x4D00001C)
-#define rREDLUT			(*(volatile unsigned *)0x4D000020)
-#define rGREENLUT		(*(volatile unsigned *)0x4D000024)
-#define rBLUELUT		(*(volatile unsigned *)0x4D000028)
-#define rDITHMODE		(*(volatile unsigned *)0x4D00004C)
-#define rTPAL			(*(volatile unsigned *)0x4D000050)
-#define rLCDINTPND		(*(volatile unsigned *)0x4D000054)
-#define rLCDSRCPND		(*(volatile unsigned *)0x4D000058)
-#define rLCDINTMSK		(*(volatile unsigned *)0x4D00005C)
+#define rLCDCON1        (*(volatile unsigned *)0x4D000000)
+#define rLCDCON2        (*(volatile unsigned *)0x4D000004)
+#define rLCDCON3        (*(volatile unsigned *)0x4D000008)
+#define rLCDCON4        (*(volatile unsigned *)0x4D00000C)
+#define rLCDCON5        (*(volatile unsigned *)0x4D000010)
+#define rLCDSADDR1      (*(volatile unsigned *)0x4D000014)
+#define rLCDSADDR2      (*(volatile unsigned *)0x4D000018)
+#define rLCDSADDR3      (*(volatile unsigned *)0x4D00001C)
+#define rREDLUT         (*(volatile unsigned *)0x4D000020)
+#define rGREENLUT       (*(volatile unsigned *)0x4D000024)
+#define rBLUELUT        (*(volatile unsigned *)0x4D000028)
+#define rDITHMODE       (*(volatile unsigned *)0x4D00004C)
+#define rTPAL           (*(volatile unsigned *)0x4D000050)
+#define rLCDINTPND      (*(volatile unsigned *)0x4D000054)
+#define rLCDSRCPND      (*(volatile unsigned *)0x4D000058)
+#define rLCDINTMSK      (*(volatile unsigned *)0x4D00005C)
 
 
 /* NAND FLASH */
-#define rNFCONF			(*(volatile unsigned *)0x4E000000)
-#define rNFCMD			(*(volatile unsigned *)0x4E000004)
-#define rNFADDR			(*(volatile unsigned *)0x4E000008)
-#define rNFDATA			(*(volatile unsigned *)0x4E00000C)
-#define rNFSTAT			(*(volatile unsigned *)0x4E000010)
-#define rNFECC			(*(volatile unsigned *)0x4E000014)
+#define rNFCONF         (*(volatile unsigned *)0x4E000000)
+#define rNFCMD          (*(volatile unsigned *)0x4E000004)
+#define rNFADDR         (*(volatile unsigned *)0x4E000008)
+#define rNFDATA         (*(volatile unsigned *)0x4E00000C)
+#define rNFSTAT         (*(volatile unsigned *)0x4E000010)
+#define rNFECC          (*(volatile unsigned *)0x4E000014)
 
 
 /* UART */
-#define rULCON0			(*(volatile unsigned *)0x50000000)
-#define rUCON0			(*(volatile unsigned *)0x50000004)
-#define rUFCON0			(*(volatile unsigned *)0x50000008)
-#define rUMCON0			(*(volatile unsigned *)0x5000000C)
-#define rUTRSTAT0		(*(volatile unsigned *)0x50000010)
-#define rUERSTAT0		(*(volatile unsigned *)0x50000014)
-#define rUFSTAT0		(*(volatile unsigned *)0x50000018)
-#define rUMSTAT0		(*(volatile unsigned *)0x5000001C)
-#define rUBRDIV0		(*(volatile unsigned *)0x50000028)
-
-#define rULCON1			(*(volatile unsigned *)0x50004000)
-#define rUCON1			(*(volatile unsigned *)0x50004004)
-#define rUFCON1			(*(volatile unsigned *)0x50004008)
-#define rUMCON1			(*(volatile unsigned *)0x5000400C)
-#define rUTRSTAT1		(*(volatile unsigned *)0x50004010)
-#define rUERSTAT1		(*(volatile unsigned *)0x50004014)
-#define rUFSTAT1		(*(volatile unsigned *)0x50004018)
-#define rUMSTAT1		(*(volatile unsigned *)0x5000401C)
-#define rUBRDIV1		(*(volatile unsigned *)0x50004028)
-
-#define rULCON2			(*(volatile unsigned *)0x50008000)
-#define rUCON2			(*(volatile unsigned *)0x50008004)
-#define rUFCON2			(*(volatile unsigned *)0x50008008)
-#define rUTRSTAT2		(*(volatile unsigned *)0x50008010)
-#define rUERSTAT2		(*(volatile unsigned *)0x50008014)
-#define rUFSTAT2		(*(volatile unsigned *)0x50008018)
-#define rUBRDIV2		(*(volatile unsigned *)0x50008028)
+#define rULCON0         (*(volatile unsigned *)0x50000000)
+#define rUCON0          (*(volatile unsigned *)0x50000004)
+#define rUFCON0         (*(volatile unsigned *)0x50000008)
+#define rUMCON0         (*(volatile unsigned *)0x5000000C)
+#define rUTRSTAT0       (*(volatile unsigned *)0x50000010)
+#define rUERSTAT0       (*(volatile unsigned *)0x50000014)
+#define rUFSTAT0        (*(volatile unsigned *)0x50000018)
+#define rUMSTAT0        (*(volatile unsigned *)0x5000001C)
+#define rUBRDIV0        (*(volatile unsigned *)0x50000028)
+
+#define rULCON1         (*(volatile unsigned *)0x50004000)
+#define rUCON1          (*(volatile unsigned *)0x50004004)
+#define rUFCON1         (*(volatile unsigned *)0x50004008)
+#define rUMCON1         (*(volatile unsigned *)0x5000400C)
+#define rUTRSTAT1       (*(volatile unsigned *)0x50004010)
+#define rUERSTAT1       (*(volatile unsigned *)0x50004014)
+#define rUFSTAT1        (*(volatile unsigned *)0x50004018)
+#define rUMSTAT1        (*(volatile unsigned *)0x5000401C)
+#define rUBRDIV1        (*(volatile unsigned *)0x50004028)
+
+#define rULCON2         (*(volatile unsigned *)0x50008000)
+#define rUCON2          (*(volatile unsigned *)0x50008004)
+#define rUFCON2         (*(volatile unsigned *)0x50008008)
+#define rUTRSTAT2       (*(volatile unsigned *)0x50008010)
+#define rUERSTAT2       (*(volatile unsigned *)0x50008014)
+#define rUFSTAT2        (*(volatile unsigned *)0x50008018)
+#define rUBRDIV2        (*(volatile unsigned *)0x50008028)
 
 #ifdef __BIG_ENDIAN
-#define rUTXH0			(*(volatile unsigned char *)0x50000023)
-#define rURXH0			(*(volatile unsigned char *)0x50000027)
-#define rUTXH1			(*(volatile unsigned char *)0x50004023)
-#define rURXH1			(*(volatile unsigned char *)0x50004027)
-#define rUTXH2			(*(volatile unsigned char *)0x50008023)
-#define rURXH2			(*(volatile unsigned char *)0x50008027)
-
-#define WrUTXH0(ch)		(*(volatile unsigned char *)0x50000023)=(unsigned char)(ch)
-#define RdURXH0()		(*(volatile unsigned char *)0x50000027)
-#define WrUTXH1(ch)		(*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
-#define RdURXH1()		(*(volatile unsigned char *)0x50004027)
-#define WrUTXH2(ch)		(*(volatile unsigned char *)0x50008023)=(unsigned char)(ch)
-#define RdURXH2()		(*(volatile unsigned char *)0x50008027)
-
-#define UTXH0			(0x50000020+3)  /* byte_access address by DMA */
-#define URXH0			(0x50000024+3)
-#define UTXH1			(0x50004020+3)
-#define URXH1			(0x50004024+3)
-#define UTXH2			(0x50008020+3)
-#define URXH2			(0x50008024+3)
+#define rUTXH0          (*(volatile unsigned char *)0x50000023)
+#define rURXH0          (*(volatile unsigned char *)0x50000027)
+#define rUTXH1          (*(volatile unsigned char *)0x50004023)
+#define rURXH1          (*(volatile unsigned char *)0x50004027)
+#define rUTXH2          (*(volatile unsigned char *)0x50008023)
+#define rURXH2          (*(volatile unsigned char *)0x50008027)
+
+#define WrUTXH0(ch)     (*(volatile unsigned char *)0x50000023)=(unsigned char)(ch)
+#define RdURXH0()       (*(volatile unsigned char *)0x50000027)
+#define WrUTXH1(ch)     (*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
+#define RdURXH1()       (*(volatile unsigned char *)0x50004027)
+#define WrUTXH2(ch)     (*(volatile unsigned char *)0x50008023)=(unsigned char)(ch)
+#define RdURXH2()       (*(volatile unsigned char *)0x50008027)
+
+#define UTXH0           (0x50000020+3)  /* byte_access address by DMA */
+#define URXH0           (0x50000024+3)
+#define UTXH1           (0x50004020+3)
+#define URXH1           (0x50004024+3)
+#define UTXH2           (0x50008020+3)
+#define URXH2           (0x50008024+3)
 
 #else /* Little Endian */
-#define rUTXH0			(*(volatile unsigned char *)0x50000020)
-#define rURXH0			(*(volatile unsigned char *)0x50000024)
-#define rUTXH1			(*(volatile unsigned char *)0x50004020)
-#define rURXH1			(*(volatile unsigned char *)0x50004024)
-#define rUTXH2			(*(volatile unsigned char *)0x50008020)
-#define rURXH2			(*(volatile unsigned char *)0x50008024)
-
-#define WrUTXH0(ch)		(*(volatile unsigned char *)0x50000020)=(unsigned char)(ch)
-#define RdURXH0()		(*(volatile unsigned char *)0x50000024)
-#define WrUTXH1(ch)		(*(volatile unsigned char *)0x50004020)=(unsigned char)(ch)
-#define RdURXH1()		(*(volatile unsigned char *)0x50004024)
-#define WrUTXH2(ch)		(*(volatile unsigned char *)0x50008020)=(unsigned char)(ch)
-#define RdURXH2()		(*(volatile unsigned char *)0x50008024)
-
-#define UTXH0			(0x50000020)    /* byte_access address by DMA */
-#define URXH0			(0x50000024)
-#define UTXH1			(0x50004020)
-#define URXH1			(0x50004024)
-#define UTXH2			(0x50008020)
-#define URXH2			(0x50008024)
+#define rUTXH0          (*(volatile unsigned char *)0x50000020)
+#define rURXH0          (*(volatile unsigned char *)0x50000024)
+#define rUTXH1          (*(volatile unsigned char *)0x50004020)
+#define rURXH1          (*(volatile unsigned char *)0x50004024)
+#define rUTXH2          (*(volatile unsigned char *)0x50008020)
+#define rURXH2          (*(volatile unsigned char *)0x50008024)
+
+#define WrUTXH0(ch)     (*(volatile unsigned char *)0x50000020)=(unsigned char)(ch)
+#define RdURXH0()       (*(volatile unsigned char *)0x50000024)
+#define WrUTXH1(ch)     (*(volatile unsigned char *)0x50004020)=(unsigned char)(ch)
+#define RdURXH1()       (*(volatile unsigned char *)0x50004024)
+#define WrUTXH2(ch)     (*(volatile unsigned char *)0x50008020)=(unsigned char)(ch)
+#define RdURXH2()       (*(volatile unsigned char *)0x50008024)
+
+#define UTXH0           (0x50000020)    /* byte_access address by DMA */
+#define URXH0           (0x50000024)
+#define UTXH1           (0x50004020)
+#define URXH1           (0x50004024)
+#define UTXH2           (0x50008020)
+#define URXH2           (0x50008024)
 #endif
 
 
 /* PWM TIMER */
-#define rTCFG0			(*(volatile unsigned *)0x51000000)
-#define rTCFG1			(*(volatile unsigned *)0x51000004)
-#define rTCON			(*(volatile unsigned *)0x51000008)
-#define rTCNTB0			(*(volatile unsigned *)0x5100000C)
-#define rTCMPB0			(*(volatile unsigned *)0x51000010)
-#define rTCNTO0			(*(volatile unsigned *)0x51000014)
-#define rTCNTB1			(*(volatile unsigned *)0x51000018)
-#define rTCMPB1			(*(volatile unsigned *)0x5100001C)
-#define rTCNTO1			(*(volatile unsigned *)0x51000020)
-#define rTCNTB2			(*(volatile unsigned *)0x51000024)
-#define rTCMPB2			(*(volatile unsigned *)0x51000028)
-#define rTCNTO2			(*(volatile unsigned *)0x5100002C)
-#define rTCNTB3			(*(volatile unsigned *)0x51000030)
-#define rTCMPB3			(*(volatile unsigned *)0x51000034)
-#define rTCNTO3			(*(volatile unsigned *)0x51000038)
-#define rTCNTB4			(*(volatile unsigned *)0x5100003C)
-#define rTCNTO4			(*(volatile unsigned *)0x51000040)
+#define rTCFG0          (*(volatile unsigned *)0x51000000)
+#define rTCFG1          (*(volatile unsigned *)0x51000004)
+#define rTCON           (*(volatile unsigned *)0x51000008)
+#define rTCNTB0         (*(volatile unsigned *)0x5100000C)
+#define rTCMPB0         (*(volatile unsigned *)0x51000010)
+#define rTCNTO0         (*(volatile unsigned *)0x51000014)
+#define rTCNTB1         (*(volatile unsigned *)0x51000018)
+#define rTCMPB1         (*(volatile unsigned *)0x5100001C)
+#define rTCNTO1         (*(volatile unsigned *)0x51000020)
+#define rTCNTB2         (*(volatile unsigned *)0x51000024)
+#define rTCMPB2         (*(volatile unsigned *)0x51000028)
+#define rTCNTO2         (*(volatile unsigned *)0x5100002C)
+#define rTCNTB3         (*(volatile unsigned *)0x51000030)
+#define rTCMPB3         (*(volatile unsigned *)0x51000034)
+#define rTCNTO3         (*(volatile unsigned *)0x51000038)
+#define rTCNTB4         (*(volatile unsigned *)0x5100003C)
+#define rTCNTO4         (*(volatile unsigned *)0x51000040)
 
 
 /* USB DEVICE */
 #ifdef __BIG_ENDIAN
-#define rFUNC_ADDR_REG		(*(volatile unsigned char *)0x52000143)
-#define rPWR_REG		(*(volatile unsigned char *)0x52000147)
-#define rEP_INT_REG		(*(volatile unsigned char *)0x5200014B)
-#define rUSB_INT_REG		(*(volatile unsigned char *)0x5200015B)
-#define rEP_INT_EN_REG		(*(volatile unsigned char *)0x5200015F)
-#define rUSB_INT_EN_REG		(*(volatile unsigned char *)0x5200016F)
-#define rFRAME_NUM1_REG		(*(volatile unsigned char *)0x52000173)
-#define rFRAME_NUM2_REG		(*(volatile unsigned char *)0x52000177)
-#define rINDEX_REG		(*(volatile unsigned char *)0x5200017B)
-#define rMAXP_REG		(*(volatile unsigned char *)0x52000183)
-#define rEP0_CSR		(*(volatile unsigned char *)0x52000187)
-#define rIN_CSR1_REG		(*(volatile unsigned char *)0x52000187)
-#define rIN_CSR2_REG		(*(volatile unsigned char *)0x5200018B)
-#define rOUT_CSR1_REG		(*(volatile unsigned char *)0x52000193)
-#define rOUT_CSR2_REG		(*(volatile unsigned char *)0x52000197)
-#define rOUT_FIFO_CNT1_REG	(*(volatile unsigned char *)0x5200019B)
-#define rOUT_FIFO_CNT2_REG	(*(volatile unsigned char *)0x5200019F)
-#define rEP0_FIFO		(*(volatile unsigned char *)0x520001C3)
-#define rEP1_FIFO		(*(volatile unsigned char *)0x520001C7)
-#define rEP2_FIFO		(*(volatile unsigned char *)0x520001CB)
-#define rEP3_FIFO		(*(volatile unsigned char *)0x520001CF)
-#define rEP4_FIFO		(*(volatile unsigned char *)0x520001D3)
-#define rEP1_DMA_CON		(*(volatile unsigned char *)0x52000203)
-#define rEP1_DMA_UNIT		(*(volatile unsigned char *)0x52000207)
-#define rEP1_DMA_FIFO		(*(volatile unsigned char *)0x5200020B)
-#define rEP1_DMA_TX_LO		(*(volatile unsigned char *)0x5200020F)
-#define rEP1_DMA_TX_MD		(*(volatile unsigned char *)0x52000213)
-#define rEP1_DMA_TX_HI		(*(volatile unsigned char *)0x52000217)
-#define rEP2_DMA_CON		(*(volatile unsigned char *)0x5200021B)
-#define rEP2_DMA_UNIT		(*(volatile unsigned char *)0x5200021F)
-#define rEP2_DMA_FIFO		(*(volatile unsigned char *)0x52000223)
-#define rEP2_DMA_TX_LO		(*(volatile unsigned char *)0x52000227)
-#define rEP2_DMA_TX_MD		(*(volatile unsigned char *)0x5200022B)
-#define rEP2_DMA_TX_HI		(*(volatile unsigned char *)0x5200022F)
-#define rEP3_DMA_CON		(*(volatile unsigned char *)0x52000243)
-#define rEP3_DMA_UNIT		(*(volatile unsigned char *)0x52000247)
-#define rEP3_DMA_FIFO		(*(volatile unsigned char *)0x5200024B)
-#define rEP3_DMA_TX_LO		(*(volatile unsigned char *)0x5200024F)
-#define rEP3_DMA_TX_MD		(*(volatile unsigned char *)0x52000253)
-#define rEP3_DMA_TX_HI		(*(volatile unsigned char *)0x52000257)
-#define rEP4_DMA_CON		(*(volatile unsigned char *)0x5200025B)
-#define rEP4_DMA_UNIT		(*(volatile unsigned char *)0x5200025F)
-#define rEP4_DMA_FIFO		(*(volatile unsigned char *)0x52000263)
-#define rEP4_DMA_TX_LO		(*(volatile unsigned char *)0x52000267)
-#define rEP4_DMA_TX_MD		(*(volatile unsigned char *)0x5200026B)
-#define rEP4_DMA_TX_HI		(*(volatile unsigned char *)0x5200026F)
+#define rFUNC_ADDR_REG      (*(volatile unsigned char *)0x52000143)
+#define rPWR_REG        (*(volatile unsigned char *)0x52000147)
+#define rEP_INT_REG     (*(volatile unsigned char *)0x5200014B)
+#define rUSB_INT_REG        (*(volatile unsigned char *)0x5200015B)
+#define rEP_INT_EN_REG      (*(volatile unsigned char *)0x5200015F)
+#define rUSB_INT_EN_REG     (*(volatile unsigned char *)0x5200016F)
+#define rFRAME_NUM1_REG     (*(volatile unsigned char *)0x52000173)
+#define rFRAME_NUM2_REG     (*(volatile unsigned char *)0x52000177)
+#define rINDEX_REG      (*(volatile unsigned char *)0x5200017B)
+#define rMAXP_REG       (*(volatile unsigned char *)0x52000183)
+#define rEP0_CSR        (*(volatile unsigned char *)0x52000187)
+#define rIN_CSR1_REG        (*(volatile unsigned char *)0x52000187)
+#define rIN_CSR2_REG        (*(volatile unsigned char *)0x5200018B)
+#define rOUT_CSR1_REG       (*(volatile unsigned char *)0x52000193)
+#define rOUT_CSR2_REG       (*(volatile unsigned char *)0x52000197)
+#define rOUT_FIFO_CNT1_REG  (*(volatile unsigned char *)0x5200019B)
+#define rOUT_FIFO_CNT2_REG  (*(volatile unsigned char *)0x5200019F)
+#define rEP0_FIFO       (*(volatile unsigned char *)0x520001C3)
+#define rEP1_FIFO       (*(volatile unsigned char *)0x520001C7)
+#define rEP2_FIFO       (*(volatile unsigned char *)0x520001CB)
+#define rEP3_FIFO       (*(volatile unsigned char *)0x520001CF)
+#define rEP4_FIFO       (*(volatile unsigned char *)0x520001D3)
+#define rEP1_DMA_CON        (*(volatile unsigned char *)0x52000203)
+#define rEP1_DMA_UNIT       (*(volatile unsigned char *)0x52000207)
+#define rEP1_DMA_FIFO       (*(volatile unsigned char *)0x5200020B)
+#define rEP1_DMA_TX_LO      (*(volatile unsigned char *)0x5200020F)
+#define rEP1_DMA_TX_MD      (*(volatile unsigned char *)0x52000213)
+#define rEP1_DMA_TX_HI      (*(volatile unsigned char *)0x52000217)
+#define rEP2_DMA_CON        (*(volatile unsigned char *)0x5200021B)
+#define rEP2_DMA_UNIT       (*(volatile unsigned char *)0x5200021F)
+#define rEP2_DMA_FIFO       (*(volatile unsigned char *)0x52000223)
+#define rEP2_DMA_TX_LO      (*(volatile unsigned char *)0x52000227)
+#define rEP2_DMA_TX_MD      (*(volatile unsigned char *)0x5200022B)
+#define rEP2_DMA_TX_HI      (*(volatile unsigned char *)0x5200022F)
+#define rEP3_DMA_CON        (*(volatile unsigned char *)0x52000243)
+#define rEP3_DMA_UNIT       (*(volatile unsigned char *)0x52000247)
+#define rEP3_DMA_FIFO       (*(volatile unsigned char *)0x5200024B)
+#define rEP3_DMA_TX_LO      (*(volatile unsigned char *)0x5200024F)
+#define rEP3_DMA_TX_MD      (*(volatile unsigned char *)0x52000253)
+#define rEP3_DMA_TX_HI      (*(volatile unsigned char *)0x52000257)
+#define rEP4_DMA_CON        (*(volatile unsigned char *)0x5200025B)
+#define rEP4_DMA_UNIT       (*(volatile unsigned char *)0x5200025F)
+#define rEP4_DMA_FIFO       (*(volatile unsigned char *)0x52000263)
+#define rEP4_DMA_TX_LO      (*(volatile unsigned char *)0x52000267)
+#define rEP4_DMA_TX_MD      (*(volatile unsigned char *)0x5200026B)
+#define rEP4_DMA_TX_HI      (*(volatile unsigned char *)0x5200026F)
 #else /*  little endian */
-#define rFUNC_ADDR_REG		(*(volatile unsigned char *)0x52000140)
-#define rPWR_REG		(*(volatile unsigned char *)0x52000144)
-#define rEP_INT_REG		(*(volatile unsigned char *)0x52000148)
-#define rUSB_INT_REG		(*(volatile unsigned char *)0x52000158)
-#define rEP_INT_EN_REG		(*(volatile unsigned char *)0x5200015C)
-#define rUSB_INT_EN_REG		(*(volatile unsigned char *)0x5200016C)
-#define rFRAME_NUM1_REG		(*(volatile unsigned char *)0x52000170)
-#define rFRAME_NUM2_REG		(*(volatile unsigned char *)0x52000174)
-#define rINDEX_REG		(*(volatile unsigned char *)0x52000178)
-#define rMAXP_REG		(*(volatile unsigned char *)0x52000180)
-#define rEP0_CSR		(*(volatile unsigned char *)0x52000184)
-#define rIN_CSR1_REG		(*(volatile unsigned char *)0x52000184)
-#define rIN_CSR2_REG		(*(volatile unsigned char *)0x52000188)
-#define rOUT_CSR1_REG		(*(volatile unsigned char *)0x52000190)
-#define rOUT_CSR2_REG		(*(volatile unsigned char *)0x52000194)
-#define rOUT_FIFO_CNT1_REG	(*(volatile unsigned char *)0x52000198)
-#define rOUT_FIFO_CNT2_REG	(*(volatile unsigned char *)0x5200019C)
-#define rEP0_FIFO		(*(volatile unsigned char *)0x520001C0)
-#define rEP1_FIFO		(*(volatile unsigned char *)0x520001C4)
-#define rEP2_FIFO		(*(volatile unsigned char *)0x520001C8)
-#define rEP3_FIFO		(*(volatile unsigned char *)0x520001CC)
-#define rEP4_FIFO		(*(volatile unsigned char *)0x520001D0)
-#define rEP1_DMA_CON		(*(volatile unsigned char *)0x52000200)
-#define rEP1_DMA_UNIT		(*(volatile unsigned char *)0x52000204)
-#define rEP1_DMA_FIFO		(*(volatile unsigned char *)0x52000208)
-#define rEP1_DMA_TX_LO		(*(volatile unsigned char *)0x5200020C)
-#define rEP1_DMA_TX_MD		(*(volatile unsigned char *)0x52000210)
-#define rEP1_DMA_TX_HI		(*(volatile unsigned char *)0x52000214)
-#define rEP2_DMA_CON		(*(volatile unsigned char *)0x52000218)
-#define rEP2_DMA_UNIT		(*(volatile unsigned char *)0x5200021C)
-#define rEP2_DMA_FIFO		(*(volatile unsigned char *)0x52000220)
-#define rEP2_DMA_TX_LO		(*(volatile unsigned char *)0x52000224)
-#define rEP2_DMA_TX_MD		(*(volatile unsigned char *)0x52000228)
-#define rEP2_DMA_TX_HI		(*(volatile unsigned char *)0x5200022C)
-#define rEP3_DMA_CON		(*(volatile unsigned char *)0x52000240)
-#define rEP3_DMA_UNIT		(*(volatile unsigned char *)0x52000244)
-#define rEP3_DMA_FIFO		(*(volatile unsigned char *)0x52000248)
-#define rEP3_DMA_TX_LO		(*(volatile unsigned char *)0x5200024C)
-#define rEP3_DMA_TX_MD		(*(volatile unsigned char *)0x52000250)
-#define rEP3_DMA_TX_HI		(*(volatile unsigned char *)0x52000254)
-#define rEP4_DMA_CON		(*(volatile unsigned char *)0x52000258)
-#define rEP4_DMA_UNIT		(*(volatile unsigned char *)0x5200025C)
-#define rEP4_DMA_FIFO		(*(volatile unsigned char *)0x52000260)
-#define rEP4_DMA_TX_LO		(*(volatile unsigned char *)0x52000264)
-#define rEP4_DMA_TX_MD		(*(volatile unsigned char *)0x52000268)
-#define rEP4_DMA_TX_HI		(*(volatile unsigned char *)0x5200026C)
+#define rFUNC_ADDR_REG      (*(volatile unsigned char *)0x52000140)
+#define rPWR_REG        (*(volatile unsigned char *)0x52000144)
+#define rEP_INT_REG     (*(volatile unsigned char *)0x52000148)
+#define rUSB_INT_REG        (*(volatile unsigned char *)0x52000158)
+#define rEP_INT_EN_REG      (*(volatile unsigned char *)0x5200015C)
+#define rUSB_INT_EN_REG     (*(volatile unsigned char *)0x5200016C)
+#define rFRAME_NUM1_REG     (*(volatile unsigned char *)0x52000170)
+#define rFRAME_NUM2_REG     (*(volatile unsigned char *)0x52000174)
+#define rINDEX_REG      (*(volatile unsigned char *)0x52000178)
+#define rMAXP_REG       (*(volatile unsigned char *)0x52000180)
+#define rEP0_CSR        (*(volatile unsigned char *)0x52000184)
+#define rIN_CSR1_REG        (*(volatile unsigned char *)0x52000184)
+#define rIN_CSR2_REG        (*(volatile unsigned char *)0x52000188)
+#define rOUT_CSR1_REG       (*(volatile unsigned char *)0x52000190)
+#define rOUT_CSR2_REG       (*(volatile unsigned char *)0x52000194)
+#define rOUT_FIFO_CNT1_REG  (*(volatile unsigned char *)0x52000198)
+#define rOUT_FIFO_CNT2_REG  (*(volatile unsigned char *)0x5200019C)
+#define rEP0_FIFO       (*(volatile unsigned char *)0x520001C0)
+#define rEP1_FIFO       (*(volatile unsigned char *)0x520001C4)
+#define rEP2_FIFO       (*(volatile unsigned char *)0x520001C8)
+#define rEP3_FIFO       (*(volatile unsigned char *)0x520001CC)
+#define rEP4_FIFO       (*(volatile unsigned char *)0x520001D0)
+#define rEP1_DMA_CON        (*(volatile unsigned char *)0x52000200)
+#define rEP1_DMA_UNIT       (*(volatile unsigned char *)0x52000204)
+#define rEP1_DMA_FIFO       (*(volatile unsigned char *)0x52000208)
+#define rEP1_DMA_TX_LO      (*(volatile unsigned char *)0x5200020C)
+#define rEP1_DMA_TX_MD      (*(volatile unsigned char *)0x52000210)
+#define rEP1_DMA_TX_HI      (*(volatile unsigned char *)0x52000214)
+#define rEP2_DMA_CON        (*(volatile unsigned char *)0x52000218)
+#define rEP2_DMA_UNIT       (*(volatile unsigned char *)0x5200021C)
+#define rEP2_DMA_FIFO       (*(volatile unsigned char *)0x52000220)
+#define rEP2_DMA_TX_LO      (*(volatile unsigned char *)0x52000224)
+#define rEP2_DMA_TX_MD      (*(volatile unsigned char *)0x52000228)
+#define rEP2_DMA_TX_HI      (*(volatile unsigned char *)0x5200022C)
+#define rEP3_DMA_CON        (*(volatile unsigned char *)0x52000240)
+#define rEP3_DMA_UNIT       (*(volatile unsigned char *)0x52000244)
+#define rEP3_DMA_FIFO       (*(volatile unsigned char *)0x52000248)
+#define rEP3_DMA_TX_LO      (*(volatile unsigned char *)0x5200024C)
+#define rEP3_DMA_TX_MD      (*(volatile unsigned char *)0x52000250)
+#define rEP3_DMA_TX_HI      (*(volatile unsigned char *)0x52000254)
+#define rEP4_DMA_CON        (*(volatile unsigned char *)0x52000258)
+#define rEP4_DMA_UNIT       (*(volatile unsigned char *)0x5200025C)
+#define rEP4_DMA_FIFO       (*(volatile unsigned char *)0x52000260)
+#define rEP4_DMA_TX_LO      (*(volatile unsigned char *)0x52000264)
+#define rEP4_DMA_TX_MD      (*(volatile unsigned char *)0x52000268)
+#define rEP4_DMA_TX_HI      (*(volatile unsigned char *)0x5200026C)
 #endif /*  __BIG_ENDIAN */
 
 
 /* WATCH DOG TIMER */
-#define rWTCON			(*(volatile unsigned *)0x53000000)
-#define rWTDAT			(*(volatile unsigned *)0x53000004)
-#define rWTCNT			(*(volatile unsigned *)0x53000008)
+#define rWTCON          (*(volatile unsigned *)0x53000000)
+#define rWTDAT          (*(volatile unsigned *)0x53000004)
+#define rWTCNT          (*(volatile unsigned *)0x53000008)
 
 
 /* IIC */
-#define rIICCON			(*(volatile unsigned *)0x54000000)
-#define rIICSTAT		(*(volatile unsigned *)0x54000004)
-#define rIICADD			(*(volatile unsigned *)0x54000008)
-#define rIICDS			(*(volatile unsigned *)0x5400000C)
+#define rIICCON         (*(volatile unsigned *)0x54000000)
+#define rIICSTAT        (*(volatile unsigned *)0x54000004)
+#define rIICADD         (*(volatile unsigned *)0x54000008)
+#define rIICDS          (*(volatile unsigned *)0x5400000C)
 
 
 /* IIS */
-#define rIISCON			(*(volatile unsigned *)0x55000000)
-#define rIISMOD			(*(volatile unsigned *)0x55000004)
-#define rIISPSR			(*(volatile unsigned *)0x55000008)
-#define rIISFCON		(*(volatile unsigned *)0x5500000C)
+#define rIISCON         (*(volatile unsigned *)0x55000000)
+#define rIISMOD         (*(volatile unsigned *)0x55000004)
+#define rIISPSR         (*(volatile unsigned *)0x55000008)
+#define rIISFCON        (*(volatile unsigned *)0x5500000C)
 
 #ifdef __BIG_ENDIAN
-#define IISFIF			((volatile unsigned short *)0x55000012)
+#define IISFIF          ((volatile unsigned short *)0x55000012)
 #else /*  little endian */
-#define IISFIF			((volatile unsigned short *)0x55000010)
+#define IISFIF          ((volatile unsigned short *)0x55000010)
 #endif
 
 
 /* I/O PORT */
-#define rGPACON			(*(volatile unsigned *)0x56000000)
-#define rGPADAT			(*(volatile unsigned *)0x56000004)
+#define rGPACON         (*(volatile unsigned *)0x56000000)
+#define rGPADAT         (*(volatile unsigned *)0x56000004)
 
-#define rGPBCON			(*(volatile unsigned *)0x56000010)
-#define rGPBDAT			(*(volatile unsigned *)0x56000014)
-#define rGPBUP			(*(volatile unsigned *)0x56000018)
-
-#define rGPCCON			(*(volatile unsigned *)0x56000020)
-#define rGPCDAT			(*(volatile unsigned *)0x56000024)
-#define rGPCUP			(*(volatile unsigned *)0x56000028)
-
-#define rGPDCON			(*(volatile unsigned *)0x56000030)
-#define rGPDDAT			(*(volatile unsigned *)0x56000034)
-#define rGPDUP			(*(volatile unsigned *)0x56000038)
-
-#define rGPECON			(*(volatile unsigned *)0x56000040)
-#define rGPEDAT			(*(volatile unsigned *)0x56000044)
-#define rGPEUP			(*(volatile unsigned *)0x56000048)
-
-#define rGPFCON			(*(volatile unsigned *)0x56000050)
-#define rGPFDAT			(*(volatile unsigned *)0x56000054)
-#define rGPFUP			(*(volatile unsigned *)0x56000058)
-
-#define rGPGCON			(*(volatile unsigned *)0x56000060)
-#define rGPGDAT			(*(volatile unsigned *)0x56000064)
-#define rGPGUP			(*(volatile unsigned *)0x56000068)
-
-#define rGPHCON			(*(volatile unsigned *)0x56000070)
-#define rGPHDAT			(*(volatile unsigned *)0x56000074)
-#define rGPHUP			(*(volatile unsigned *)0x56000078)
-
-#define rMISCCR			(*(volatile unsigned *)0x56000080)
-#define rDCLKCON		(*(volatile unsigned *)0x56000084)
-#define rEXTINT0		(*(volatile unsigned *)0x56000088)
-#define rEXTINT1		(*(volatile unsigned *)0x5600008C)
-#define rEXTINT2		(*(volatile unsigned *)0x56000090)
-#define rEINTFLT0		(*(volatile unsigned *)0x56000094)
-#define rEINTFLT1		(*(volatile unsigned *)0x56000098)
-#define rEINTFLT2		(*(volatile unsigned *)0x5600009C)
-#define rEINTFLT3		(*(volatile unsigned *)0x560000A0)
-#define rEINTMASK		(*(volatile unsigned *)0x560000A4)
-#define rEINTPEND		(*(volatile unsigned *)0x560000A8)
-#define rGSTATUS0		(*(volatile unsigned *)0x560000AC)
-#define rGSTATUS1		(*(volatile unsigned *)0x560000B0)
+#define rGPBCON         (*(volatile unsigned *)0x56000010)
+#define rGPBDAT         (*(volatile unsigned *)0x56000014)
+#define rGPBUP          (*(volatile unsigned *)0x56000018)
+
+#define rGPCCON         (*(volatile unsigned *)0x56000020)
+#define rGPCDAT         (*(volatile unsigned *)0x56000024)
+#define rGPCUP          (*(volatile unsigned *)0x56000028)
+
+#define rGPDCON         (*(volatile unsigned *)0x56000030)
+#define rGPDDAT         (*(volatile unsigned *)0x56000034)
+#define rGPDUP          (*(volatile unsigned *)0x56000038)
+
+#define rGPECON         (*(volatile unsigned *)0x56000040)
+#define rGPEDAT         (*(volatile unsigned *)0x56000044)
+#define rGPEUP          (*(volatile unsigned *)0x56000048)
+
+#define rGPFCON         (*(volatile unsigned *)0x56000050)
+#define rGPFDAT         (*(volatile unsigned *)0x56000054)
+#define rGPFUP          (*(volatile unsigned *)0x56000058)
+
+#define rGPGCON         (*(volatile unsigned *)0x56000060)
+#define rGPGDAT         (*(volatile unsigned *)0x56000064)
+#define rGPGUP          (*(volatile unsigned *)0x56000068)
+
+#define rGPHCON         (*(volatile unsigned *)0x56000070)
+#define rGPHDAT         (*(volatile unsigned *)0x56000074)
+#define rGPHUP          (*(volatile unsigned *)0x56000078)
+
+#define rMISCCR         (*(volatile unsigned *)0x56000080)
+#define rDCLKCON        (*(volatile unsigned *)0x56000084)
+#define rEXTINT0        (*(volatile unsigned *)0x56000088)
+#define rEXTINT1        (*(volatile unsigned *)0x5600008C)
+#define rEXTINT2        (*(volatile unsigned *)0x56000090)
+#define rEINTFLT0       (*(volatile unsigned *)0x56000094)
+#define rEINTFLT1       (*(volatile unsigned *)0x56000098)
+#define rEINTFLT2       (*(volatile unsigned *)0x5600009C)
+#define rEINTFLT3       (*(volatile unsigned *)0x560000A0)
+#define rEINTMASK       (*(volatile unsigned *)0x560000A4)
+#define rEINTPEND       (*(volatile unsigned *)0x560000A8)
+#define rGSTATUS0       (*(volatile unsigned *)0x560000AC)
+#define rGSTATUS1       (*(volatile unsigned *)0x560000B0)
+#define rGSTATUS2       (*(volatile unsigned *)0x560000B4)
+#define rGSTATUS3       (*(volatile unsigned *)0x560000B8)
+#define rGSTATUS4       (*(volatile unsigned *)0x560000BC)
 
 
 /* RTC */
 #ifdef __BIG_ENDIAN
-#define rRTCCON			(*(volatile unsigned char *)0x57000043)
-#define rTICNT			(*(volatile unsigned char *)0x57000047)
-#define rRTCALM			(*(volatile unsigned char *)0x57000053)
-#define rALMSEC			(*(volatile unsigned char *)0x57000057)
-#define rALMMIN			(*(volatile unsigned char *)0x5700005B)
-#define rALMHOUR		(*(volatile unsigned char *)0x5700005F)
-#define rALMDATE		(*(volatile unsigned char *)0x57000063)
-#define rALMMON			(*(volatile unsigned char *)0x57000067)
-#define rALMYEAR		(*(volatile unsigned char *)0x5700006B)
-#define rRTCRST			(*(volatile unsigned char *)0x5700006F)
-#define rBCDSEC			(*(volatile unsigned char *)0x57000073)
-#define rBCDMIN			(*(volatile unsigned char *)0x57000077)
-#define rBCDHOUR		(*(volatile unsigned char *)0x5700007B)
-#define rBCDDATE		(*(volatile unsigned char *)0x5700007F)
-#define rBCDDAY			(*(volatile unsigned char *)0x57000083)
-#define rBCDMON			(*(volatile unsigned char *)0x57000087)
-#define rBCDYEAR		(*(volatile unsigned char *)0x5700008B)
+#define rRTCCON         (*(volatile unsigned char *)0x57000043)
+#define rTICNT          (*(volatile unsigned char *)0x57000047)
+#define rRTCALM         (*(volatile unsigned char *)0x57000053)
+#define rALMSEC         (*(volatile unsigned char *)0x57000057)
+#define rALMMIN         (*(volatile unsigned char *)0x5700005B)
+#define rALMHOUR        (*(volatile unsigned char *)0x5700005F)
+#define rALMDATE        (*(volatile unsigned char *)0x57000063)
+#define rALMMON         (*(volatile unsigned char *)0x57000067)
+#define rALMYEAR        (*(volatile unsigned char *)0x5700006B)
+#define rRTCRST         (*(volatile unsigned char *)0x5700006F)
+#define rBCDSEC         (*(volatile unsigned char *)0x57000073)
+#define rBCDMIN         (*(volatile unsigned char *)0x57000077)
+#define rBCDHOUR        (*(volatile unsigned char *)0x5700007B)
+#define rBCDDATE        (*(volatile unsigned char *)0x5700007F)
+#define rBCDDAY         (*(volatile unsigned char *)0x57000083)
+#define rBCDMON         (*(volatile unsigned char *)0x57000087)
+#define rBCDYEAR        (*(volatile unsigned char *)0x5700008B)
 #else /*  little endian */
-#define rRTCCON			(*(volatile unsigned char *)0x57000040)
-#define rTICNT			(*(volatile unsigned char *)0x57000044)
-#define rRTCALM			(*(volatile unsigned char *)0x57000050)
-#define rALMSEC			(*(volatile unsigned char *)0x57000054)
-#define rALMMIN			(*(volatile unsigned char *)0x57000058)
-#define rALMHOUR		(*(volatile unsigned char *)0x5700005C)
-#define rALMDATE		(*(volatile unsigned char *)0x57000060)
-#define rALMMON			(*(volatile unsigned char *)0x57000064)
-#define rALMYEAR		(*(volatile unsigned char *)0x57000068)
-#define rRTCRST			(*(volatile unsigned char *)0x5700006C)
-#define rBCDSEC			(*(volatile unsigned char *)0x57000070)
-#define rBCDMIN			(*(volatile unsigned char *)0x57000074)
-#define rBCDHOUR		(*(volatile unsigned char *)0x57000078)
-#define rBCDDATE		(*(volatile unsigned char *)0x5700007C)
-#define rBCDDAY			(*(volatile unsigned char *)0x57000080)
-#define rBCDMON			(*(volatile unsigned char *)0x57000084)
-#define rBCDYEAR		(*(volatile unsigned char *)0x57000088)
+#define rRTCCON         (*(volatile unsigned char *)0x57000040)
+#define rTICNT          (*(volatile unsigned char *)0x57000044)
+#define rRTCALM         (*(volatile unsigned char *)0x57000050)
+#define rALMSEC         (*(volatile unsigned char *)0x57000054)
+#define rALMMIN         (*(volatile unsigned char *)0x57000058)
+#define rALMHOUR        (*(volatile unsigned char *)0x5700005C)
+#define rALMDATE        (*(volatile unsigned char *)0x57000060)
+#define rALMMON         (*(volatile unsigned char *)0x57000064)
+#define rALMYEAR        (*(volatile unsigned char *)0x57000068)
+#define rRTCRST         (*(volatile unsigned char *)0x5700006C)
+#define rBCDSEC         (*(volatile unsigned char *)0x57000070)
+#define rBCDMIN         (*(volatile unsigned char *)0x57000074)
+#define rBCDHOUR        (*(volatile unsigned char *)0x57000078)
+#define rBCDDATE        (*(volatile unsigned char *)0x5700007C)
+#define rBCDDAY         (*(volatile unsigned char *)0x57000080)
+#define rBCDMON         (*(volatile unsigned char *)0x57000084)
+#define rBCDYEAR        (*(volatile unsigned char *)0x57000088)
 #endif
 
 
 /* ADC */
-#define rADCCON			(*(volatile unsigned *)0x58000000)
-#define rADCTSC			(*(volatile unsigned *)0x58000004)
-#define rADCDLY			(*(volatile unsigned *)0x58000008)
-#define rADCDAT0		(*(volatile unsigned *)0x5800000C)
-#define rADCDAT1		(*(volatile unsigned *)0x58000010)
+#define rADCCON         (*(volatile unsigned *)0x58000000)
+#define rADCTSC         (*(volatile unsigned *)0x58000004)
+#define rADCDLY         (*(volatile unsigned *)0x58000008)
+#define rADCDAT0        (*(volatile unsigned *)0x5800000C)
+#define rADCDAT1        (*(volatile unsigned *)0x58000010)
 
 
 /* SPI */
-#define rSPCON0			(*(volatile unsigned *)0x59000000)
-#define rSPSTA0			(*(volatile unsigned *)0x59000004)
-#define rSPPIN0			(*(volatile unsigned *)0x59000008)
-#define rSPPRE0			(*(volatile unsigned *)0x5900000C)
-#define rSPTDAT0		(*(volatile unsigned *)0x59000010)
-#define rSPRDAT0		(*(volatile unsigned *)0x59000014)
-#define rSPCON1			(*(volatile unsigned *)0x59000020)
-#define rSPSTA1			(*(volatile unsigned *)0x59000024)
-#define rSPPIN1			(*(volatile unsigned *)0x59000028)
-#define rSPPRE1			(*(volatile unsigned *)0x5900002C)
-#define rSPTDAT1		(*(volatile unsigned *)0x59000030)
-#define rSPRDAT1		(*(volatile unsigned *)0x59000034)
+#define rSPCON0         (*(volatile unsigned *)0x59000000)
+#define rSPSTA0         (*(volatile unsigned *)0x59000004)
+#define rSPPIN0         (*(volatile unsigned *)0x59000008)
+#define rSPPRE0         (*(volatile unsigned *)0x5900000C)
+#define rSPTDAT0        (*(volatile unsigned *)0x59000010)
+#define rSPRDAT0        (*(volatile unsigned *)0x59000014)
+#define rSPCON1         (*(volatile unsigned *)0x59000020)
+#define rSPSTA1         (*(volatile unsigned *)0x59000024)
+#define rSPPIN1         (*(volatile unsigned *)0x59000028)
+#define rSPPRE1         (*(volatile unsigned *)0x5900002C)
+#define rSPTDAT1        (*(volatile unsigned *)0x59000030)
+#define rSPRDAT1        (*(volatile unsigned *)0x59000034)
 
 
 /* SD INTERFACE */
-#define rSDICON			(*(volatile unsigned *)0x5A000000)
-#define rSDIPRE			(*(volatile unsigned *)0x5A000004)
-#define rSDICmdArg		(*(volatile unsigned *)0x5A000008)
-#define rSDICmdCon		(*(volatile unsigned *)0x5A00000C)
-#define rSDICmdSta		(*(volatile unsigned *)0x5A000010)
-#define rSDIRSP0		(*(volatile unsigned *)0x5A000014)
-#define rSDIRSP1		(*(volatile unsigned *)0x5A000018)
-#define rSDIRSP2		(*(volatile unsigned *)0x5A00001C)
-#define rSDIRSP3		(*(volatile unsigned *)0x5A000020)
-#define rSDIDTimer		(*(volatile unsigned *)0x5A000024)
-#define rSDIBSize		(*(volatile unsigned *)0x5A000028)
-#define rSDIDatCon		(*(volatile unsigned *)0x5A00002C)
-#define rSDIDatCnt		(*(volatile unsigned *)0x5A000030)
-#define rSDIDatSta		(*(volatile unsigned *)0x5A000034)
-#define rSDIFSTA		(*(volatile unsigned *)0x5A000038)
+#define rSDICON         (*(volatile unsigned *)0x5A000000)
+#define rSDIPRE         (*(volatile unsigned *)0x5A000004)
+#define rSDICmdArg      (*(volatile unsigned *)0x5A000008)
+#define rSDICmdCon      (*(volatile unsigned *)0x5A00000C)
+#define rSDICmdSta      (*(volatile unsigned *)0x5A000010)
+#define rSDIRSP0        (*(volatile unsigned *)0x5A000014)
+#define rSDIRSP1        (*(volatile unsigned *)0x5A000018)
+#define rSDIRSP2        (*(volatile unsigned *)0x5A00001C)
+#define rSDIRSP3        (*(volatile unsigned *)0x5A000020)
+#define rSDIDTimer      (*(volatile unsigned *)0x5A000024)
+#define rSDIBSize       (*(volatile unsigned *)0x5A000028)
+#define rSDIDatCon      (*(volatile unsigned *)0x5A00002C)
+#define rSDIDatCnt      (*(volatile unsigned *)0x5A000030)
+#define rSDIDatSta      (*(volatile unsigned *)0x5A000034)
+#define rSDIFSTA        (*(volatile unsigned *)0x5A000038)
 #ifdef __BIG_ENDIAN
-#define rSDIDAT			(*(volatile unsigned char *)0x5A00003F)
+#define rSDIDAT         (*(volatile unsigned char *)0x5A00003F)
 #else
-#define rSDIDAT			(*(volatile unsigned char *)0x5A00003C)
+#define rSDIDAT         (*(volatile unsigned char *)0x5A00003C)
 #endif
-#define rSDIIntMsk		(*(volatile unsigned *)0x5A000040)
+#define rSDIIntMsk      (*(volatile unsigned *)0x5A000040)
 
 #endif
 
+#define rGSTATUS1       (*(volatile unsigned *)0x560000B0)
+#define isS3C2410 		((rGSTATUS1 & 0xffff0000) == 0x32410000)
+
 #endif /*__S3C24X0_H__*/
diff -urN u-boot-1.1.6/include/stdio_dev.h u-boot-1.1.6_fdt/include/stdio_dev.h
--- u-boot-1.1.6/include/stdio_dev.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6_fdt/include/stdio_dev.h	2018-10-22 16:55:49.349572081 +0800
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2000
+ * Paolo Scaffardi, AIRVENT SAM s.p.a - RIMINI(ITALY), arsenio@tin.it
+ */
+
+#ifndef _STDIO_DEV_H_
+#define _STDIO_DEV_H_
+
+//#include <stdio.h>
+#include <linux/list.h>
+
+/*
+ * STDIO DEVICES
+ */
+
+#define DEV_FLAGS_INPUT	 0x00000001	/* Device can be used as input	console */
+#define DEV_FLAGS_OUTPUT 0x00000002	/* Device can be used as output console */
+#define DEV_FLAGS_DM     0x00000004	/* Device priv is a struct udevice * */
+
+/* Device information */
+struct stdio_dev {
+	int	flags;			/* Device flags: input/output/system	*/
+	int	ext;			/* Supported extensions			*/
+	char	name[32];		/* Device name				*/
+
+/* GENERAL functions */
+
+	int (*start)(struct stdio_dev *dev);	/* To start the device */
+	int (*stop)(struct stdio_dev *dev);	/* To stop the device */
+
+/* OUTPUT functions */
+
+	/* To put a char */
+	void (*putc)(struct stdio_dev *dev, const char c);
+	/* To put a string (accelerator) */
+	void (*puts)(struct stdio_dev *dev, const char *s);
+
+/* INPUT functions */
+
+	/* To test if a char is ready... */
+	int (*tstc)(struct stdio_dev *dev);
+	int (*getc)(struct stdio_dev *dev);	/* To get that char */
+
+/* Other functions */
+
+	void *priv;			/* Private extensions			*/
+	struct list_head list;
+};
+
+/*
+ * VARIABLES
+ */
+extern struct stdio_dev *stdio_devices[];
+extern char *stdio_names[MAX_FILES];
+
+/*
+ * PROTOTYPES
+ */
+int	stdio_register (struct stdio_dev * dev);
+int stdio_register_dev(struct stdio_dev *dev, struct stdio_dev **devp);
+
+/**
+ * stdio_init_tables() - set up stdio tables ready for devices
+ *
+ * This does not add any devices, but just prepares stdio for use.
+ */
+int stdio_init_tables(void);
+
+/**
+ * stdio_add_devices() - Add stdio devices to the table
+ *
+ * This makes calls to all the various subsystems that use stdio, to make
+ * them register with stdio.
+ */
+int stdio_add_devices(void);
+
+/**
+ * stdio_init() - Sets up stdio ready for use
+ *
+ * This calls stdio_init_tables() and stdio_add_devices()
+ */
+int stdio_init(void);
+
+void	stdio_print_current_devices(void);
+//#if CONFIG_IS_ENABLED(SYS_STDIO_DEREGISTER)
+int stdio_deregister(const char *devname, int force);
+int stdio_deregister_dev(struct stdio_dev *dev, int force);
+//#endif
+struct list_head* stdio_get_list(void);
+struct stdio_dev* stdio_get_by_name(const char* name);
+struct stdio_dev* stdio_clone(struct stdio_dev *dev);
+
+#ifdef CONFIG_LCD
+int	drv_lcd_init (void);
+#endif
+#if defined(CONFIG_VIDEO) || defined(CONFIG_CFB_CONSOLE)
+int	drv_video_init (void);
+#endif
+#ifdef CONFIG_KEYBOARD
+int	drv_keyboard_init (void);
+#endif
+#ifdef CONFIG_USB_TTY
+int	drv_usbtty_init (void);
+#endif
+#ifdef CONFIG_NETCONSOLE
+int	drv_nc_init (void);
+#endif
+#ifdef CONFIG_JTAG_CONSOLE
+int drv_jtag_console_init (void);
+#endif
+#ifdef CONFIG_CBMEM_CONSOLE
+int cbmemc_init(void);
+#endif
+
+#endif
diff -urN u-boot-1.1.6/include/usb.h u-boot-1.1.6_fdt/include/usb.h
--- u-boot-1.1.6/include/usb.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/include/usb.h	2018-10-22 15:53:21.565641224 +0800
@@ -202,6 +202,7 @@
 
 #endif
 /* routines */
+void Port_Init(void);
 int usb_init(void); /* initialize the USB Controller */
 int usb_stop(void); /* stop the USB Controller */
 
diff -urN u-boot-1.1.6/lib_arm/armlinux.c u-boot-1.1.6_fdt/lib_arm/armlinux.c
--- u-boot-1.1.6/lib_arm/armlinux.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/lib_arm/armlinux.c	2018-10-22 15:53:21.565641224 +0800
@@ -29,6 +29,7 @@
 #ifdef CONFIG_HAS_DATAFLASH
 #include <dataflash.h>
 #endif
+#include <ft_build.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -86,12 +87,31 @@
 	image_header_t *hdr = &header;
 	bd_t *bd = gd->bd;
 
+	char	*of_flat_tree = NULL;
+	ulong	of_data = 0;
+
 #ifdef CONFIG_CMDLINE_TAG
 	char *commandline = getenv ("bootargs");
 #endif
 
 	theKernel = (void (*)(int, int, uint))ntohl(hdr->ih_ep);
 
+	/* 100ask for device tree, no initrd image used */
+	if (argc == 4) {
+		of_flat_tree = (char *) simple_strtoul(argv[3], NULL, 16);
+
+		if  (be32_to_cpu(*(ulong *)of_flat_tree) == OF_DT_HEADER) {
+			printf ("\nStarting kernel with device tree at 0x%x...\n\n", of_flat_tree);
+
+			cleanup_before_linux ();			
+			theKernel (0, bd->bi_arch_number, of_flat_tree);
+					
+		} else {
+			printf("Bad magic of device tree at 0x%x!\n\n", of_flat_tree);
+		}
+		
+	}
+
 	/*
 	 * Check if there is an initrd image
 	 */
@@ -261,7 +281,83 @@
 #ifdef CONFIG_USB_DEVICE
 	{
 		extern void udc_disconnect (void);
-		udc_disconnect ();
+                //udc_disconnect (); // cancled by www.100ask.net
+	}
+#endif
+
+	cleanup_before_linux ();
+
+	theKernel (0, bd->bi_arch_number, bd->bi_boot_params);
+}
+
+void do_bootm_rawLinux (ulong addr)
+{
+	ulong len = 0, checksum;
+	ulong initrd_start, initrd_end;
+	ulong data;
+	void (*theKernel)(int zero, int arch, uint params);
+	image_header_t *hdr = &header;
+	bd_t *bd = gd->bd;
+
+#ifdef CONFIG_CMDLINE_TAG
+	char *commandline = getenv ("bootargs");
+#endif
+
+	theKernel = (void (*)(int, int, uint))addr;
+
+	{
+		/*
+		 * no initrd image
+		 */
+		SHOW_BOOT_PROGRESS (14);
+
+		len = data = 0;
+	}
+
+
+	{
+		initrd_start = 0;
+		initrd_end = 0;
+	}
+
+
+#if defined (CONFIG_SETUP_MEMORY_TAGS) || \
+    defined (CONFIG_CMDLINE_TAG) || \
+    defined (CONFIG_INITRD_TAG) || \
+    defined (CONFIG_SERIAL_TAG) || \
+    defined (CONFIG_REVISION_TAG) || \
+    defined (CONFIG_LCD) || \
+    defined (CONFIG_VFD)
+	setup_start_tag (bd);
+#ifdef CONFIG_SERIAL_TAG
+	setup_serial_tag (&params);
+#endif
+#ifdef CONFIG_REVISION_TAG
+	setup_revision_tag (&params);
+#endif
+#ifdef CONFIG_SETUP_MEMORY_TAGS
+	setup_memory_tags (bd);
+#endif
+#ifdef CONFIG_CMDLINE_TAG
+	setup_commandline_tag (bd, commandline);
+#endif
+#ifdef CONFIG_INITRD_TAG
+	if (initrd_start && initrd_end)
+		setup_initrd_tag (bd, initrd_start, initrd_end);
+#endif
+#if defined (CONFIG_VFD) || defined (CONFIG_LCD)
+	setup_videolfb_tag ((gd_t *) gd);
+#endif
+	setup_end_tag (bd);
+#endif
+
+	/* we assume that the kernel is in place */
+	printf ("\nStarting kernel ...\n\n");
+
+#ifdef CONFIG_USB_DEVICE
+	{
+		extern void udc_disconnect (void);
+                //udc_disconnect (); // cancled by www.100ask.net
 	}
 #endif
 
diff -urN u-boot-1.1.6/lib_arm/board.c u-boot-1.1.6_fdt/lib_arm/board.c
--- u-boot-1.1.6/lib_arm/board.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/lib_arm/board.c	2018-10-22 15:53:21.565641224 +0800
@@ -70,7 +70,7 @@
 #endif
 
 const char version_string[] =
-	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")"CONFIG_IDENT_STRING;
+	U_BOOT_VERSION" enable Ethernet alltime, support fdt command(" __DATE__ " - " __TIME__ ")"CONFIG_IDENT_STRING;
 
 #ifdef CONFIG_DRIVER_CS8900
 extern void cs8900_get_enetaddr (uchar * addr);
@@ -178,7 +178,7 @@
 }
 
 #ifndef CFG_NO_FLASH
-static void display_flash_config (ulong size)
+void display_flash_config (ulong size)
 {
 	puts ("Flash: ");
 	print_size (size, "\n");
@@ -360,10 +360,15 @@
 	misc_init_r ();
 #endif
 
-	/* enable exceptions */
-	enable_interrupts ();
+	Port_Init();
+	if (!PreLoadedONRAM) {
+		/* enable exceptions */
+		enable_interrupts ();
+	    /* add by www.100ask.net */
+	    usb_init();
+	}
 
-	/* Perform network card initialisation if necessary */
+    /* Perform network card initialisation if necessary */
 #ifdef CONFIG_DRIVER_CS8900
 	cs8900_get_enetaddr (gd->bd->bi_enetaddr);
 #endif
diff -urN u-boot-1.1.6/lib_generic/string.c u-boot-1.1.6_fdt/lib_generic/string.c
--- u-boot-1.1.6/lib_generic/string.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/lib_generic/string.c	2018-10-22 17:09:32.933556887 +0800
@@ -576,3 +576,67 @@
 }
 
 #endif
+
+long trailing_strtoln(const char *str, const char *end)
+{
+	const char *p;
+
+	if (!end)
+		end = str + strlen(str);
+	if (isdigit(end[-1])) {
+		for (p = end - 1; p > str; p--) {
+			if (!isdigit(*p))
+				return simple_strtoul(p + 1, NULL, 10);
+		}
+	}
+
+	return -1;
+}
+
+long trailing_strtol(const char *str)
+{
+	return trailing_strtoln(str, NULL);
+}
+
+/**
+ * strncasecmp - Case insensitive, length-limited string comparison
+ * @s1: One string
+ * @s2: The other string
+ * @len: the maximum number of characters to compare
+ */
+int strncasecmp(const char *s1, const char *s2, size_t len)
+{
+	/* Yes, Virginia, it had better be unsigned */
+	unsigned char c1, c2;
+
+	c1 = 0;	c2 = 0;
+	if (len) {
+		do {
+			c1 = *s1; c2 = *s2;
+			s1++; s2++;
+			if (!c1)
+				break;
+			if (!c2)
+				break;
+			if (c1 == c2)
+				continue;
+			c1 = tolower(c1);
+			c2 = tolower(c2);
+			if (c1 != c2)
+				break;
+		} while (--len);
+	}
+	return (int)c1 - (int)c2;
+}
+
+/**
+ * strcasecmp - Case insensitive string comparison
+ * @s1: One string
+ * @s2: The other string
+ */
+int strcasecmp(const char *s1, const char *s2)
+{
+	return strncasecmp(s1, s2, -1U);
+}
+
+
diff -urN u-boot-1.1.6/lib_generic/vsprintf.c u-boot-1.1.6_fdt/lib_generic/vsprintf.c
--- u-boot-1.1.6/lib_generic/vsprintf.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/lib_generic/vsprintf.c	2018-10-22 16:47:54.461580842 +0800
@@ -55,7 +55,7 @@
 	return simple_strtoul(cp,endp,base);
 }
 
-#ifdef CFG_64BIT_STRTOUL
+//#ifdef CFG_64BIT_STRTOUL
 unsigned long long simple_strtoull (const char *cp, char **endp, unsigned int base)
 {
 	unsigned long long result = 0, value;
@@ -83,7 +83,7 @@
 		*endp = (char *) cp;
 	return result;
 }
-#endif /* CFG_64BIT_STRTOUL */
+//#endif /* CFG_64BIT_STRTOUL */
 
 /* we use this so that we can do without the ctype library */
 #define is_digit(c)	((c) >= '0' && (c) <= '9')
diff -urN u-boot-1.1.6/Makefile u-boot-1.1.6_fdt/Makefile
--- u-boot-1.1.6/Makefile	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/Makefile	2018-10-22 16:00:40.089633134 +0800
@@ -125,7 +125,7 @@
 CROSS_COMPILE = powerpc-linux-
 endif
 ifeq ($(ARCH),arm)
-CROSS_COMPILE = arm-linux-
+CROSS_COMPILE = arm-linux-gnueabi-
 endif
 ifeq ($(ARCH),i386)
 ifeq ($(HOSTARCH),i386)
@@ -205,9 +205,10 @@
 LIBS += dtt/libdtt.a
 LIBS += drivers/libdrivers.a
 LIBS += drivers/nand/libnand.a
+LIBS += common/fdt/libfdt.a
 LIBS += drivers/nand_legacy/libnand_legacy.a
+LIBS += drivers/usb/libusb.a
 LIBS += drivers/sk98lin/libsk98lin.a
-LIBS += post/libpost.a post/cpu/libcpu.a
 LIBS += common/libcommon.a
 LIBS += $(BOARDLIBS)
 
@@ -215,7 +216,8 @@
 .PHONY : $(LIBS)
 
 # Add GCC lib
-PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
+#PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
+PLATFORM_LIBS += 
 
 # The "tools" are needed early, so put this first
 # Don't include stuff already done in $(LIBS)
@@ -266,11 +268,15 @@
 			-Map u-boot.map -o u-boot
 
 $(OBJS):
+	echo $(OBJS)	
 		$(MAKE) -C cpu/$(CPU) $(if $(REMOTE_BUILD),$@,$(notdir $@))
 
 $(LIBS):
 		$(MAKE) -C $(dir $(subst $(obj),,$@))
 
+usb:
+	$(MAKE) -C drivers/usb
+
 $(SUBDIRS):
 		$(MAKE) -C $@ all
 
@@ -1879,6 +1885,9 @@
 smdk2410_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 NULL s3c24x0
 
+100ask24x0_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0
+
 SX1_config :		unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm925t sx1
 
diff -urN u-boot-1.1.6/net/net.c u-boot-1.1.6_fdt/net/net.c
--- u-boot-1.1.6/net/net.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_fdt/net/net.c	2018-10-22 15:53:21.565641224 +0800
@@ -301,7 +301,7 @@
 		NetArpWaitTxPacketSize = 0;
 	}
 
-	eth_halt();
+	//eth_halt();
 #ifdef CONFIG_NET_MULTI
 	eth_set_current();
 #endif
@@ -547,7 +547,7 @@
 				sprintf(buf, "%lX", (unsigned long)load_addr);
 				setenv("fileaddr", buf);
 			}
-			eth_halt();
+			//eth_halt();
 			return NetBootFileXferSize;
 
 		case NETLOOP_FAIL:
